{
    "prefix": "This code defines a function 'rule2matrix' that converts a list of SMILES strings into a feature matrix using RDKit and SMARTS patterns. The function applies a set of 12 rules, each designed to detect specific structural features in molecules that predict high or low target values, as per the provided natural language descriptions. The function outputs a DataFrame where each column corresponds to one rule and each row corresponds to one SMILES string from the input list. The values are assigned as 1, -1, or 0, depending on whether the molecule matches the rule predicting a high target value, matches the rule predicting a low target value, or does not match the rule, respectively. The code includes error handling to ensure that if any error occurs when applying a rule to a molecule, a value of 0 is returned for that rule and molecule.",
    "imports": "from rdkit import Chem\nimport pandas as pd",
    "code": "def rule2matrix(smiles_list):\n    from rdkit import Chem\n    from rdkit.Chem import rdchem\n\n    # Helper function to check for para-substituted groups in aromatic carboxylic acids\n    def check_para_substitution(mol, substituent_patterns):\n        \"\"\"\n        Checks if an aromatic carboxylic acid has a substituent at the para position matching any of the patterns.\n        \"\"\"\n        matches = mol.GetSubstructMatches(Chem.MolFromSmarts('[c][CX3](=O)[O;H1,-1]'))  # Aromatic carboxylic acid\n        for match in matches:\n            aromatic_carbon_idx = match[0]\n            carboxyl_carbon_idx = match[1]\n            # Get aromatic ring the carboxylic acid is attached to\n            rings = mol.GetRingInfo().AtomRings()\n            aromatic_ring = None\n            for ring in rings:\n                if aromatic_carbon_idx in ring:\n                    aromatic_ring = ring\n                    break\n            if aromatic_ring:\n                # Find the atom opposite to the carboxylic acid in the ring (para position)\n                idx_in_ring = aromatic_ring.index(aromatic_carbon_idx)\n                para_idx = aromatic_ring[(idx_in_ring + 3) % len(aromatic_ring)]\n                para_atom = mol.GetAtomWithIdx(para_idx)\n                # Check if para atom has a substituent matching any of the patterns\n                for neighbor in para_atom.GetNeighbors():\n                    if neighbor.GetIdx() not in aromatic_ring:\n                        neighbor_idx = neighbor.GetIdx()\n                        neighbor_fragment = Chem.MolFragmentToSmiles(mol, atomsToUse=[neighbor_idx], isomericSmiles=True)\n                        neighbor_mol = Chem.MolFromSmiles(neighbor_fragment)\n                        for pattern in substituent_patterns:\n                            if neighbor_mol and neighbor_mol.HasSubstructMatch(pattern):\n                                return True\n        return False\n\n    # --- Define functional groups ---\n\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid_smarts = '[CX3](=O)[O;H1,-1]'\n    carboxylic_acid = Chem.MolFromSmarts(carboxylic_acid_smarts)\n\n    # Aromatic carboxylic acid group\n    aromatic_carboxylic_acid_smarts = '[c][CX3](=O)[O;H1,-1]'\n    aromatic_carboxylic_acid = Chem.MolFromSmarts(aromatic_carboxylic_acid_smarts)\n\n    # Electron-withdrawing groups (EWGs)\n    nitro_group = Chem.MolFromSmarts('[N+](=O)[O-]')\n    halomethyl_group = Chem.MolFromSmarts('[CH2][F,Cl,Br,I]')\n    halogen = Chem.MolFromSmarts('[F,Cl,Br,I]')\n    cf3_group = Chem.MolFromSmarts('[CX4]([F])([F])[F]')\n    ewg_list = [nitro_group, halomethyl_group, halogen, cf3_group]\n\n    # Electron-donating groups (EDGs)\n    amino_group = Chem.MolFromSmarts('[NX3;H2,H1][#6]')\n    hydroxyl_group = Chem.MolFromSmarts('[OX2H]')\n    methoxy_group = Chem.MolFromSmarts('[OX2][CH3]')\n    methyl_group = Chem.MolFromSmarts('[CH3]')\n    edg_list = [amino_group, hydroxyl_group, methoxy_group, methyl_group]\n\n    # Sulfur functional groups\n    thiol_group = Chem.MolFromSmarts('[SX2H]')\n    thioether_group = Chem.MolFromSmarts('[SX2][#6]')\n    sulfur_groups = [thiol_group, thioether_group]\n\n    # Terminal amino group (primary aliphatic amine)\n    terminal_amino_group = Chem.MolFromSmarts('[NX3;H2][CX4][CX4]')\n\n    # Pyridine ring with carboxylic acid at position 4\n    pyridine_4_carboxylic_acid = Chem.MolFromSmarts('n1cccc([CX3](=O)[O;H1,-1])c1')\n\n    # Multiple hydroxyl groups adjacent to carboxylic acid\n    multiple_adjacent_hydroxyls = Chem.MolFromSmarts('[CX4H]([OX2H])[CX4H]([OX2H])[CX4][CX3](=O)[O;H1,-1]')\n\n    # Bulky side chains or rigid structures\n    indole_group = Chem.MolFromSmarts('c1cc2ccccc2[nH]1')\n    pyrazole_group = Chem.MolFromSmarts('c1ccn[nH]1')\n    bulky_groups = [indole_group, pyrazole_group]\n\n    # Aldehyde groups adjacent to aromatic ring\n    aromatic_aldehyde = Chem.MolFromSmarts('[c][CX3H1]=O')\n\n    # Ether linkage\n    ether_linkage = Chem.MolFromSmarts('[#6][OX2][#6]')\n\n    # Amino groups\n    amino_group_any = Chem.MolFromSmarts('[NX3;H2,H1,H0][#6]')\n\n    # Additional carbonyl groups\n    ketone_group = Chem.MolFromSmarts('[#6][CX3](=O)[#6]')\n    lactone_group = Chem.MolFromSmarts('[#6]1[#6][#6][#6][#6][O]1')\n\n    # Highly fluorinated alkyl chains\n    fluorinated_alkyl_chain = Chem.MolFromSmarts('C(F)(F)F')\n\n    # Initialize results list\n    results = []\n\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*12)\n            continue\n        row = []\n\n        # Rule 1\n        try:\n            match_rule1 = 0\n            matches = mol.GetSubstructMatches(aromatic_carboxylic_acid)\n            if matches:\n                if check_para_substitution(mol, ewg_list):\n                    match_rule1 = 1\n            row.append(match_rule1)\n        except Exception:\n            row.append(0)\n\n        # Rule 2\n        try:\n            match_rule2 = 0\n            matches = mol.GetSubstructMatches(aromatic_carboxylic_acid)\n            if matches:\n                if check_para_substitution(mol, edg_list):\n                    match_rule2 = -1\n            row.append(match_rule2)\n        except Exception:\n            row.append(0)\n\n        # Rule 3\n        try:\n            if mol.HasSubstructMatch(carboxylic_acid) and any(mol.HasSubstructMatch(sg) for sg in sulfur_groups):\n                row.append(1)\n            else:\n                row.append(0)\n        except Exception:\n            row.append(0)\n\n        # Rule 4\n        try:\n            match_rule4 = 0\n            amino_matches = mol.GetSubstructMatches(terminal_amino_group)\n            acid_matches = mol.GetSubstructMatches(carboxylic_acid)\n            if amino_matches and acid_matches:\n                for a_match in amino_matches:\n                    for c_match in acid_matches:\n                        path = Chem.rdmolops.GetShortestPath(mol, a_match[0], c_match[0])\n                        if len(path) >= 5:  # Medium to long chain\n                            match_rule4 = 1\n                            break\n                    if match_rule4 == 1:\n                        break\n            row.append(match_rule4)\n        except Exception:\n            row.append(0)\n\n        # Rule 5\n        try:\n            if mol.HasSubstructMatch(pyridine_4_carboxylic_acid):\n                row.append(1)\n            else:\n                row.append(0)\n        except Exception:\n            row.append(0)\n\n        # Rule 6\n        try:\n            if mol.HasSubstructMatch(multiple_adjacent_hydroxyls):\n                row.append(-1)\n            else:\n                row.append(0)\n        except Exception:\n            row.append(0)\n\n        # Rule 7\n        try:\n            if mol.HasSubstructMatch(carboxylic_acid):\n                exclude_patterns = [\n                    amino_group_any,\n                    hydroxyl_group,\n                    sulfur_groups[0],\n                    sulfur_groups[1],\n                    ether_linkage,\n                    Chem.MolFromSmarts('[a]')  # Aromatic atoms\n                ]\n                if not any(mol.HasSubstructMatch(pat) for pat in exclude_patterns):\n                    row.append(-1)\n                else:\n                    row.append(0)\n            else:\n                row.append(0)\n        except Exception:\n            row.append(0)\n\n        # Rule 8\n        try:\n            if mol.HasSubstructMatch(carboxylic_acid) and any(mol.HasSubstructMatch(bg) for bg in bulky_groups):\n                row.append(-1)\n            else:\n                row.append(0)\n        except Exception:\n            row.append(0)\n\n        # Rule 9\n        try:\n            if mol.HasSubstructMatch(aromatic_aldehyde):\n                row.append(-1)\n            else:\n                row.append(0)\n        except Exception:\n            row.append(0)\n\n        # Rule 10\n        try:\n            if mol.HasSubstructMatch(carboxylic_acid) and mol.HasSubstructMatch(ether_linkage) and mol.HasSubstructMatch(amino_group_any):\n                row.append(1)\n            else:\n                row.append(0)\n        except Exception:\n            row.append(0)\n\n        # Rule 11\n        try:\n            if mol.HasSubstructMatch(carboxylic_acid) and (mol.HasSubstructMatch(ketone_group) or mol.HasSubstructMatch(lactone_group)):\n                row.append(1)\n            else:\n                row.append(0)\n        except Exception:\n            row.append(0)\n\n        # Rule 12\n        try:\n            if mol.HasSubstructMatch(carboxylic_acid) and mol.HasSubstructMatch(fluorinated_alkyl_chain):\n                row.append(-1)\n            else:\n                row.append(0)\n        except Exception:\n            row.append(0)\n\n        # Append row to results\n        results.append(row)\n\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {i+1}' for i in range(12)])\n    return df\n"
}