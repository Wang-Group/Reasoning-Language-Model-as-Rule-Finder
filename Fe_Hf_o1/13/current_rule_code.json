{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups using corrected patterns from suggestions\n\n    # Carboxylic acid group (-COOH) and carboxylate anion\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    carboxylate_anion = '[CX3](=O)[O-]'\n\n    # Primary amine group (-NH2)\n    primary_amine = '[NX3H2]'\n\n    # Secondary amine (-NH-)\n    secondary_amine = '[NX3H1][#6]'\n\n    # Electron-withdrawing groups (EWGs)\n    nitro_group = '[NX3+](=O)[O-]'\n    halogen = '[F,Cl,Br,I]'\n\n    # Electron-donating groups (EDGs)\n    hydroxyl_group = '[OX2H]'\n    methoxy_group = '[OX2][CH3]'\n    amino_group_aromatic = '[c][NX3H2]'\n\n    # Aromatic ring (generic)\n    aromatic_ring = '[a]1aaaaa1'\n\n    # Sulfur-containing groups\n    thiol = '[SX2H]'\n    thioether = '[SX2][#6][#6]'\n\n    # Ether linkage\n    ether_linkage = '[#6][OX2][#6]'\n\n    # Acetamido group\n    acetamido_group = '[NX3][CX3](=O)[#6]'\n\n    # Heteroaromatic ring with nitrogen atoms (e.g., pyridine)\n    pyridine_ring = 'n1ccccc1'\n\n    # Aldehyde group (-CHO)\n    aldehyde_group = '[CX3H1](=O)[#6]'\n\n    # Fluorinated aliphatic chain\n    fluorinated_chain = '[CX4]([F])([F])[F]'\n\n    # Ketone group within aliphatic chain\n    ketone_in_chain = '[#6][CX3](=O)[#6]'\n\n    # Bulky aromatic systems (e.g., fused rings)\n    fused_aromatic = '[r3,r4,r5,r6,r7,r8,r9,r10]'\n\n    # Ortho-hydroxyl group to carboxylic acid on aromatic ring\n    ortho_hydroxyl_carboxylic_acid = 'c1cc(O)ccc1C(=O)O'\n\n    # Define electron-withdrawing group patterns\n    ewg_patterns = [nitro_group, halogen]\n\n    # Define electron-donating group patterns\n    edg_patterns = [hydroxyl_group, methoxy_group, amino_group_aromatic]\n\n    # Define rules with patterns and conditions\n    rules = [\n        # Rule 1\n        {\n            'number': 1,\n            'description': 'Rule 1: Modifiers that are linear aliphatic amino acids with a primary amino group (-NH2) and a single terminal carboxylic acid group (-COOH), with a carbon chain length of five or more carbons, result in high Fe/Hf values.',\n            'patterns': [primary_amine, carboxylic_acid],\n            'conditions': 'chain_length',\n            'prediction': 1\n        },\n        # Rule 2\n        {\n            'number': 2,\n            'description': 'Rule 2: Aromatic carboxylic acids with strong electron-withdrawing groups, such as nitro (-NO2) or halogens, at the para position result in high Fe/Hf values.',\n            'patterns': ['[c][CX3](=O)[OX2H1]'],  # Aromatic carboxylic acid\n            'ewg_patterns': ewg_patterns,\n            'conditions': 'para_substitution',\n            'prediction': 1\n        },\n        # Rule 3\n        {\n            'number': 3,\n            'description': 'Rule 3: Modifiers containing sulfur-functional groups such as thiol (-SH) or thioether (-S-) alongside a carboxylic acid group (-COOH) result in high Fe/Hf values.',\n            'patterns': [carboxylic_acid],\n            'sub_patterns': [thiol, thioether],\n            'prediction': 1\n        },\n        # Rule 4\n        {\n            'number': 4,\n            'description': 'Rule 4: Modifiers featuring flexible ether linkages (-O-) with terminal coordinating groups such as amino (-NH2) or carboxyl (-COOH) result in high Fe/Hf values.',\n            'patterns': [ether_linkage],\n            'sub_patterns': [primary_amine, carboxylic_acid],\n            'prediction': 1\n        },\n        # Rule 5\n        {\n            'number': 5,\n            'description': 'Rule 5: Modifiers containing multiple coordinating groups, such as amino acids with additional amino or acetamido groups, result in high Fe/Hf values due to enhanced chelation.',\n            'patterns': [carboxylic_acid],\n            'sub_patterns': [primary_amine, acetamido_group],\n            'conditions': 'multiple_coordinating_groups',\n            'prediction': 1\n        },\n        # Rule 6\n        {\n            'number': 6,\n            'description': 'Rule 6: Aromatic carboxylic acids with electron-donating groups such as amino (-NH2), hydroxyl (-OH), or methoxy (-OCH3) at the para position result in low Fe/Hf values.',\n            'patterns': ['[c][CX3](=O)[OX2H1]'],  # Aromatic carboxylic acid\n            'edg_patterns': edg_patterns,\n            'conditions': 'para_substitution',\n            'prediction': -1\n        },\n        # Rule 7\n        {\n            'number': 7,\n            'description': 'Rule 7: Modifiers containing multiple hydroxyl groups (-OH) on aliphatic chains or cyclic structures result in low Fe/Hf values.',\n            'patterns': [carboxylic_acid, hydroxyl_group],\n            'conditions': 'multiple_hydroxyls',\n            'prediction': -1\n        },\n        # Rule 8\n        {\n            'number': 8,\n            'description': 'Rule 8: Simple aliphatic carboxylic acids without additional strong coordinating groups result in low Fe/Hf values.',\n            'patterns': [carboxylic_acid],\n            'exclude_patterns': [primary_amine, secondary_amine, thiol, thioether, ether_linkage, aromatic_ring, '[#7,#8,#16,#15]'],  # Exclude other coordinating groups\n            'prediction': -1\n        },\n        # Additional rules (9-15) would be defined similarly...\n    ]\n\n    # Compile SMARTS patterns\n    for rule in rules:\n        rule['compiled_patterns'] = [Chem.MolFromSmarts(p) for p in rule.get('patterns', [])]\n        rule['compiled_sub_patterns'] = [Chem.MolFromSmarts(p) for p in rule.get('sub_patterns', [])]\n        rule['compiled_exclude_patterns'] = [Chem.MolFromSmarts(p) for p in rule.get('exclude_patterns', [])]\n        rule['compiled_ewg_patterns'] = [Chem.MolFromSmarts(p) for p in rule.get('ewg_patterns', [])]\n        rule['compiled_edg_patterns'] = [Chem.MolFromSmarts(p) for p in rule.get('edg_patterns', [])]\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                for pat in rule.get('compiled_exclude_patterns', []):\n                    if mol.HasSubstructMatch(pat):\n                        match = False\n                        break\n                if not match:\n                    row.append(0)\n                    continue\n                # Check required patterns\n                for pat in rule.get('compiled_patterns', []):\n                    if not mol.HasSubstructMatch(pat):\n                        match = False\n                        break\n                if not match:\n                    row.append(0)\n                    continue\n                # Additional conditions\n                if rule.get('conditions') == 'chain_length':\n                    # Implement chain length condition for Rule 1\n                    n_atoms = mol.GetSubstructMatches(Chem.MolFromSmarts(primary_amine))\n                    c_atoms = mol.GetSubstructMatches(Chem.MolFromSmarts(carboxylic_acid))\n                    condition_met = False\n                    for n_match in n_atoms:\n                        n_idx = n_match[0]\n                        for c_match in c_atoms:\n                            c_idx = c_match[0]\n                            path = Chem.rdmolops.GetShortestPath(mol, n_idx, c_idx)\n                            # Check that path is linear, contains only carbons\n                            if len(path) >= 7:\n                                linear = True\n                                for idx in path[1:-1]:\n                                    atom = mol.GetAtomWithIdx(idx)\n                                    if atom.GetSymbol() != 'C' or atom.GetDegree() != 2:\n                                        linear = False\n                                        break\n                                if linear:\n                                    condition_met = True\n                                    break\n                        if condition_met:\n                            break\n                    if not condition_met:\n                        match = False\n                elif rule.get('conditions') == 'para_substitution':\n                    # Implement para substitution condition for Rule 2 and Rule 6\n                    # Find aromatic carboxylic acid matches\n                    ca_matches = mol.GetSubstructMatches(rule['compiled_patterns'][0])\n                    if not ca_matches:\n                        match = False\n                    else:\n                        condition_met = False\n                        for ca_match in ca_matches:\n                            ca_atom_idx = ca_match[0]\n                            ca_atom = mol.GetAtomWithIdx(ca_atom_idx)\n                            ring_info = mol.GetRingInfo()\n                            atom_rings = ring_info.AtomRings()\n                            # Find rings containing the carboxylic acid\n                            rings_with_ca = [ring for ring in atom_rings if ca_atom_idx in ring]\n                            for ring in rings_with_ca:\n                                # Find position of carboxylic acid in ring\n                                pos_ca = ring.index(ca_atom_idx)\n                                ring_size = len(ring)\n                                # Get atom at position opposite (para position)\n                                pos_para = (pos_ca + ring_size // 2) % ring_size\n                                para_atom_idx = ring[pos_para]\n                                para_atom = mol.GetAtomWithIdx(para_atom_idx)\n                                # Check for EWG or EDG at para position\n                                if rule.get('compiled_ewg_patterns'):\n                                    for ewg_pat in rule['compiled_ewg_patterns']:\n                                        if para_atom.HasSubstructMatch(ewg_pat):\n                                            condition_met = True\n                                            break\n                                elif rule.get('compiled_edg_patterns'):\n                                    for edg_pat in rule['compiled_edg_patterns']:\n                                        if para_atom.HasSubstructMatch(edg_pat):\n                                            condition_met = True\n                                            break\n                                if condition_met:\n                                    break\n                            if condition_met:\n                                break\n                        if not condition_met:\n                            match = False\n                elif rule.get('conditions') == 'multiple_hydroxyls':\n                    # Implement multiple hydroxyls condition for Rule 7\n                    hydroxyl_matches = mol.GetSubstructMatches(Chem.MolFromSmarts(hydroxyl_group))\n                    if len(hydroxyl_matches) < 2:\n                        match = False\n                elif rule.get('conditions') == 'multiple_coordinating_groups':\n                    # Implement multiple coordinating groups condition for Rule 5\n                    count = 0\n                    for pat in rule.get('compiled_sub_patterns', []):\n                        matches = mol.GetSubstructMatches(pat)\n                        count += len(matches)\n                    if count < 2:\n                        match = False\n                # Check sub-patterns if any\n                if 'compiled_sub_patterns' in rule:\n                    for pat in rule['compiled_sub_patterns']:\n                        if not mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # On error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df"
}