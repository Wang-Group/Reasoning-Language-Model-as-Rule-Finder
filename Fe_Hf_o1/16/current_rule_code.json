{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. Each rule corresponds to structural features defined via SMARTS patterns. The code checks each SMILES for matches against the rules and assigns a value of 1, -1, or 0 accordingly. The output is a DataFrame where each column represents a rule and each row represents a SMILES string.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Import necessary modules\n    from rdkit import Chem\n    import pandas as pd\n\n    # Define rules\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are linear aliphatic carboxylic acids with a terminal primary amino group (omega-amino acids) increase Fe/Hf.',\n            'patterns': [\n                '[NX3H2][CH2][CH2][CH2][CH2][CX3](=O)[OX2H1]',\n                '[NX3H2][CH2][CH2][CH2][CH2][CH2][CX3](=O)[OX2H1]',\n                '[NX3H2][CH2][CH2][CH2][CH2][CH2][CH2][CX3](=O)[OX2H1]',\n                '[NX3H2][CH2][CH2][CH2][CH2][CH2][CH2][CH2][CX3](=O)[OX2H1]'\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers that are aromatic carboxylic acids substituted with strong electron-withdrawing groups at the para position increase Fe/Hf.',\n            'patterns': [\n                '[c][C](=O)[O]',\n                '[c][N+](=O)[O-]',\n                '[c][F,Cl,Br,I]',\n                '[c][CX4](F)(F)F'\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers containing sulfur atoms (thiol -SH or thioether -S- groups) enhance Fe/Hf.',\n            'patterns': [\n                '[SX2H]',\n                '[#16X2][#6]'\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers with nitrogen-containing heteroaromatic rings, where the nitrogen is positioned to coordinate with Fe ions, increase Fe/Hf.',\n            'patterns': [\n                'n1ccccc1',\n                'c1ccncc1',\n                'c1ccnc(c1)[C](=O)[O,H]'\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers with perfluorinated alkyl chains decrease Fe/Hf.',\n            'patterns': [\n                '[CX4](F)(F)(F)',\n                '[C](F)(F)(F)',\n                '[CF2][CF2][CF2]'\n            ],\n            'prediction': -1\n        }\n    ]\n\n    # Compile patterns\n    for rule in rules:\n        compiled_patterns = []\n        for smarts in rule['patterns']:\n            mol = Chem.MolFromSmarts(smarts)\n            compiled_patterns.append(mol)\n        rule['compiled_patterns'] = compiled_patterns\n\n    # Initialize result list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                # Check if the molecule matches any of the compiled patterns\n                rule_match = False\n                for pat in rule['compiled_patterns']:\n                    if mol.HasSubstructMatch(pat):\n                        rule_match = True\n                        break\n                if rule_match:\n                    # Molecule matches this rule\n                    row.append(rule['prediction'])\n                else:\n                    # Molecule does not match this rule\n                    row.append(0)\n            except:\n                # In case of error, append 0\n                row.append(0)\n        results.append(row)\n\n    # Create DataFrame\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df\n"
}