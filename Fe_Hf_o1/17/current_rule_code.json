{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit. It applies specific structural rules to determine if each SMILES matches certain criteria, indicating whether the structural description of the rule matches the SMILES and predicts a high or low Fe/Hf value.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and features based on the rules\n    \n    # Rule 1: Modifiers containing a primary amino group (-NH2) connected by an aliphatic chain of at least three carbons to the carboxyl group\n    # High Fe/Hf value (+1)\n    primary_amine = '[NX3;H2]'  # Primary amine (-NH2)\n    aliphatic_chain = '[C;!R][C;!R][C;!R]'  # Aliphatic chain of at least three carbons\n    carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1]'  # Carboxyl group (-COOH or -COO-)\n    \n    # Rule 2: Modifiers containing thiol (-SH) groups\n    # High Fe/Hf value (+1)\n    thiol_group = '[#16X2H]'  # Thiol group (-SH)\n    \n    # Rule 3: Aromatic carboxylic acids with electron-withdrawing groups at the para position\n    # High Fe/Hf value (+1)\n    aromatic_ring = 'c1ccccc1'\n    para_nitro = 'c1ccc([NX3+](=O)[O-])cc1'  # Nitro group at para position\n    para_halomethyl = 'c1ccc(C[Cl,Br,I,F])cc1'  # Halomethyl group at para position\n    # Exclude electron-donating groups at para position\n    para_methyl = 'c1ccc(C)cc1'\n    para_amino = 'c1ccc(N)cc1'\n    \n    # Rule 4: Modifiers containing a pyridine ring\n    # High Fe/Hf value (+1)\n    pyridine_ring = 'n1ccccc1'\n    \n    # Rule 5: Modifiers with flexible ether linkages and terminal coordinating groups\n    # High Fe/Hf value (+1)\n    ether_linkage = '[#6][OX2][#6]'  # Ether linkage (-O-)\n    terminal_amino = '[NX3;H2,H1;!$(N=*),!$(N-C=[O,N,S])]'  # Amino group (-NH2 or -NH-)\n    terminal_carboxyl = carboxylic_acid\n    \n    # Rule 6: Amino acids with aromatic side chains lacking bulky substituents\n    # High Fe/Hf value (+1)\n    amino_acid = '[NX3;H2,H1][CX4H,CX4H2][CX3](=O)[OX1H0-,OX2H1]'\n    aromatic_side_chain = 'c1ccccc1'\n    # Exclude bulky groups (e.g., indole)\n    indole = 'c1cc2ccccc2[nH]1'\n    \n    # Rule 7: Modifiers with multiple carboxyl groups capable of chelation\n    # High Fe/Hf value (+1)\n    dicarboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1][CX4][CX3](=O)[OX1H0-,OX2H1]'  # Two carboxyl groups separated by one carbon\n    amino_acid_dicarboxylic = '[NX3;H2,H1][CX4][CX3](=O)[OX1H0-,OX2H1][CX4][CX3](=O)[OX1H0-,OX2H1]'  # Amino acid with carboxylate side chain\n    \n    # Rule 8: Modifiers with electron-donating groups at the para position of aromatic carboxylic acids\n    # Low Fe/Hf value (-1)\n    para_amino = 'c1ccc(N)cc1'  # Amino group at para position\n    para_hydroxy = 'c1ccc(O)cc1'  # Hydroxy group at para position\n    \n    # Rule 9: Simple aliphatic carboxylic acids without additional strong coordinating functional groups\n    # Low Fe/Hf value (-1)\n    simple_aliphatic_acid = '[CX3](=O)[OX1H0-,OX2H1][C;!R]'  # Carboxylic acid attached to an aliphatic chain\n    \n    # Rule 10: Modifiers with bulky or sterically hindered groups near coordinating sites\n    # Low Fe/Hf value (-1)\n    bulky_group = 'c1cc2ccccc2[nH]1'  # Indole ring (bulky group)\n    acetamido_group = '[NX3][CX3](=O)[#6]'  # Acetamido group\n    \n    # Rule 11: Modifiers with multiple adjacent hydroxyl (-OH) groups near the carboxyl group (polyhydroxy carboxylic acids)\n    # Low Fe/Hf value (-1)\n    polyhydroxy = '[OX2H][CX4]([OX2H])[CX4]([OX2H])[CX4]([OX2H])[CX3](=O)[OX1H0-,OX2H1]'  # Multiple adjacent hydroxyl groups\n    \n    # Rule 12: Modifiers with perfluorinated alkyl chains attached to the carboxyl group\n    # Low Fe/Hf value (-1)\n    perfluoro_alkyl_chain = '[CX4]([F,Cl,Br,I])([F,Cl,Br,I])[CX4]([F,Cl,Br,I])([F,Cl,Br,I])[CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Rule 13: Modifiers containing conjugated carbonyl groups adjacent to the carboxyl group without additional strong coordinating groups\n    # Low Fe/Hf value (-1)\n    conjugated_carbonyl = '[CX3](=O)[CX3](=O)[#6]'\n    \n    # Rule 14: Modifiers with unique chelating structures, such as fused aromatic systems containing carbonyl groups\n    # High Fe/Hf value (+1)\n    fused_aromatic_carbonyl = 'O=C2Oc1ccccc1C2=O'  # 1,3-dioxo-2-benzofuran\n    \n    # Rule 15: Modifiers with flexible aliphatic chains terminating with coordinating functional groups on both ends\n    # High Fe/Hf value (+1)\n    terminal_primary_amine = '[NX3;H2][CX4]'  # Terminal primary amine\n    flexible_chain = '[C;!R]'  # Flexible aliphatic chain\n    \n    # Compile SMARTS patterns for each rule\n    rule_smarts = [\n        {\n            'number': 1,\n            'description': 'Modifiers containing a primary amino group (-NH2) connected by an aliphatic chain of at least three carbons to the carboxyl group',\n            'patterns': [primary_amine, aliphatic_chain + carboxylic_acid],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers containing thiol (-SH) groups',\n            'patterns': [thiol_group],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Aromatic carboxylic acids with electron-withdrawing groups at the para position',\n            'patterns': [aromatic_ring, para_nitro + para_halomethyl],\n            'exclude_patterns': [para_methyl, para_amino],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers containing a pyridine ring',\n            'patterns': [pyridine_ring],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers with flexible ether linkages and terminal coordinating groups',\n            'patterns': [ether_linkage, terminal_amino + terminal_carboxyl],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Amino acids with aromatic side chains lacking bulky substituents',\n            'patterns': [amino_acid, aromatic_side_chain],\n            'exclude_patterns': [indole],\n            'prediction': 1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers with multiple carboxyl groups capable of chelation',\n            'patterns': [dicarboxylic_acid + amino_acid_dicarboxylic],\n            'prediction': 1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers with electron-donating groups at the para position of aromatic carboxylic acids',\n            'patterns': [para_amino + para_hydroxy],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Simple aliphatic carboxylic acids without additional strong coordinating functional groups',\n            'patterns': [simple_aliphatic_acid],\n            'exclude_patterns': [primary_amine, thiol_group, ether_linkage],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers with bulky or sterically hindered groups near coordinating sites',\n            'patterns': [bulky_group + acetamido_group],\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers with multiple adjacent hydroxyl (-OH) groups near the carboxyl group',\n            'patterns': [polyhydroxy],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers with perfluorinated alkyl chains attached to the carboxyl group',\n            'patterns': [perfluoro_alkyl_chain],\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers containing conjugated carbonyl groups adjacent to the carboxyl group',\n            'patterns': [conjugated_carbonyl],\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers with unique chelating structures, such as fused aromatic systems containing carbonyl groups',\n            'patterns': [fused_aromatic_carbonyl],\n            'prediction': 1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers with flexible aliphatic chains terminating with coordinating functional groups on both ends',\n            'patterns': [terminal_primary_amine + flexible_chain + terminal_carboxyl],\n            'prediction': 1\n        }\n    ]\n    \n    # Compile patterns\n    for rule in rule_smarts:\n        compiled_patterns = []\n        for patt in rule['patterns']:\n            mol = Chem.MolFromSmarts(patt)\n            if mol is not None:\n                compiled_patterns.append(mol)\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_exclude = []\n            for patt in rule['exclude_patterns']:\n                mol = Chem.MolFromSmarts(patt)\n                if mol is not None:\n                    compiled_exclude.append(mol)\n            rule['compiled_exclude_patterns'] = compiled_exclude\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rule_smarts))\n            continue\n        row = []\n        for rule in rule_smarts:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for patt in rule['compiled_exclude_patterns']:\n                        if mol.HasSubstructMatch(patt):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for patt in rule['compiled_patterns']:\n                    if not mol.HasSubstructMatch(patt):\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rule_smarts])\n    return df\n"
}