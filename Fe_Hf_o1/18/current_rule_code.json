{
    "prefix": "This code defines the function `rule2matrix`, which converts a list of SMILES strings into a feature matrix based on specified rules using RDKit. Each rule corresponds to a substructure pattern or a combination of patterns, matching the molecular features described in the rules. The function returns a pandas DataFrame where each column represents a rule and each row corresponds to a SMILES string from the input list. The values are assigned according to the following criteria:\n- A value of 0 if the rule does not match the SMILES.\n- A value of 1 if the rule matches the SMILES and predicts a high Fe/Hf value.\n- A value of -1 if the rule matches the SMILES and predicts a low Fe/Hf value.\nThe code handles possible errors by assigning a value of 0 for any rule that cannot be evaluated for a given SMILES.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    \n    # Primary amine group (-NH2)\n    terminal_primary_amine = '[NX3;H2]'\n    \n    # Linear unbranched alkyl chain of variable length (3 to 6 carbons)\n    linear_alkyl_chain = '[CH2;X2]{3,6}'\n    \n    # Rule 1 pattern: Terminal primary amine connected via linear alkyl chain to carboxylic acid\n    rule1_pattern = terminal_primary_amine + '-' + linear_alkyl_chain + '-' + carboxylic_acid\n    \n    # Electron-withdrawing groups (EWGs)\n    nitro_group = '[N+](=O)[O-]'\n    bromomethyl_group = '[CH2Br]'\n    sulfanyl_group = '[SH]'\n    ewg_list = [nitro_group, bromomethyl_group, sulfanyl_group]\n    \n    # Aromatic carboxylic acid\n    aromatic_carboxylic_acid = '[c][CX3](=O)[OX2H1]'\n    \n    # Rule 2 patterns: Aromatic carboxylic acid with EWG at para position\n    # Due to complexity, we'll check for aromatic carboxylic acid and EWG on aromatic ring\n    ewg_on_aromatic = ['[c]' + ewg for ewg in ewg_list]\n    \n    # Pyridine ring\n    pyridine_ring = '[n][c]1[c][c][c][c][c]1'\n    \n    # Sulfhydryl (thiol) group\n    thiol_group = '[SX2H]'\n    \n    # Ether linkage (-O-) in aliphatic chains\n    ether_linkage = '[#6][OX2][#6]'\n    \n    # Hydroxyl group\n    hydroxyl_group = '[OX2H]'\n    \n    # Multiple hydroxyl groups (polyols)\n    polyol = hydroxyl_group\n    \n    # Carbonyl group adjacent to carboxyl group\n    adjacent_carbonyl = '[CX3](=O)[CX3](=O)[#6]'\n    \n    # Fluorinated alkyl chains\n    fluorinated_alkyl_chain = '[CX4]([F])([F])[F]'\n    \n    # Amino acids capable of forming chelate rings\n    chelating_amino_acid = '[$([NX3;H2][CX4][CX3](=O)[OX2H1])]'  # Simplified pattern\n    \n    # Bulky aromatic side chains near donor atoms\n    bulky_aromatic_side_chain = '[a][CH2][NX3;H2]'  # Simplified pattern\n    \n    # Electron-rich heterocycles without additional donor groups\n    electron_rich_heterocycle = '[nH]1[n][c][c][c][c]1'  # Example: pyrazole ring\n    \n    # Ortho-hydroxyl groups on aromatic carboxylic acids\n    ortho_hydroxyl_aromatic_carboxylic_acid = '[c]1[c][c][c](O)[c](C(=O)[O])[c]1'\n    \n    # Amide linkages adjacent to carboxyl groups\n    amide_adjacent_to_carboxyl = '[CX3](=O)[NX3][CX3](=O)[OX2H1]'\n    \n    # Compile SMARTS patterns\n    patterns = {\n        'Rule 1': Chem.MolFromSmarts(rule1_pattern),\n        'Rule 2': [Chem.MolFromSmarts(aromatic_carboxylic_acid)] + [Chem.MolFromSmarts(pat) for pat in ewg_on_aromatic],\n        'Rule 3': Chem.MolFromSmarts(pyridine_ring),\n        'Rule 4': Chem.MolFromSmarts(thiol_group),\n        'Rule 5': [Chem.MolFromSmarts(ether_linkage), Chem.MolFromSmarts(carboxylic_acid)],\n        'Rule 6': Chem.MolFromSmarts(carboxylic_acid),\n        'Rule 7': [Chem.MolFromSmarts(aromatic_carboxylic_acid), Chem.MolFromSmarts('[c][NX3;H2,H1]')],\n        'Rule 8': Chem.MolFromSmarts(polyol),\n        'Rule 9': [Chem.MolFromSmarts(aromatic_carboxylic_acid), Chem.MolFromSmarts('[c][OX2H]'), Chem.MolFromSmarts('[c][OX2][CH3]')],\n        'Rule 10': Chem.MolFromSmarts(amide_adjacent_to_carboxyl),\n        # Add patterns for Rules 11 to 15 as needed\n    }\n    \n    # Define the rules with their associated predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers with terminal primary amino groups in linear aliphatic carboxylic acids predict high Fe/Hf values.',\n            'patterns': [patterns['Rule 1']],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers that are aromatic carboxylic acids with strong electron-withdrawing groups at the para position predict high Fe/Hf values.',\n            'patterns': patterns['Rule 2'],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers containing pyridine rings predict high Fe/Hf values.',\n            'patterns': [patterns['Rule 3']],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers with sulfhydryl (thiol) groups predict high Fe/Hf values.',\n            'patterns': [patterns['Rule 4']],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers with ether linkages and terminal donor groups predict high Fe/Hf values.',\n            'patterns': patterns['Rule 5'],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers that are simple aliphatic carboxylic acids without additional donor groups predict low Fe/Hf values.',\n            'patterns': [patterns['Rule 6']],\n            'exclude_patterns': [patterns['Rule 1'], patterns['Rule 4'], patterns['Rule 5']],\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers that are aromatic carboxylic acids with electron-donating groups at the para position predict low Fe/Hf values.',\n            'patterns': patterns['Rule 7'],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers with multiple hydroxyl groups (polyols) predict low Fe/Hf values.',\n            'patterns': [patterns['Rule 8']],\n            'count_threshold': {'[OX2H]': 2},\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers with carbonyl groups adjacent to carboxyl groups predict low Fe/Hf values.',\n            'patterns': [Chem.MolFromSmarts(adjacent_carbonyl)],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers with fluorinated alkyl chains predict low Fe/Hf values.',\n            'patterns': [Chem.MolFromSmarts(fluorinated_alkyl_chain)],\n            'prediction': -1\n        },\n        # Add rules 11 to 15 as needed\n    ]\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = False\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for pat in rule['exclude_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    else:\n                        match = True\n                else:\n                    match = True\n                if match:\n                    # Check required patterns\n                    for pat in rule['patterns']:\n                        if isinstance(pat, list):\n                            # For patterns that are lists (Rule 2), require all to match\n                            if not any(mol.HasSubstructMatch(p) for p in pat):\n                                match = False\n                                break\n                        else:\n                            if not mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                if match:\n                    if 'count_threshold' in rule:\n                        threshold_met = True\n                        for pat_smarts, threshold in rule['count_threshold'].items():\n                            pat = Chem.MolFromSmarts(pat_smarts)\n                            matches = mol.GetSubstructMatches(pat)\n                            if len(matches) < threshold:\n                                threshold_met = False\n                                break\n                        if threshold_met:\n                            row.append(rule['prediction'])\n                        else:\n                            row.append(0)\n                    else:\n                        row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}