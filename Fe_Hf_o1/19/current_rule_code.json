{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. It implements a set of 15 rules, each corresponding to specific structural criteria defined in natural language. For each SMILES string, the code assigns a value of 1, -1, or 0 per rule, depending on whether the structural patterns match and predict a high target value (1), match and predict a low target value (-1), or do not match (0). The result is a DataFrame with rows representing the input SMILES strings and columns representing the rules.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and substructures\n    \n    # Terminal primary amino group (-NH2)\n    terminal_amino = '[NX3H2][CX4;!$(C(-N)(-N))]'\n    \n    # Terminal carboxylic acid group (-COOH)\n    terminal_carboxylic_acid = '[CX3](=O)[OX2H1]'\n    \n    # Unbranched aliphatic chain of at least four carbons\n    unbranched_aliphatic_chain_4plus = '[CX4H2][CX4H2][CX4H2][CX4H2H1]'\n    \n    # Aromatic ring\n    aromatic_ring = '[a]'\n    \n    # Strong electron-withdrawing groups at para position\n    nitro_para = 'c1ccc([NX3+](=O)[O-])cc1'\n    halogen_para = 'c1ccc([F,Cl,Br,I])cc1'\n    pyridyl_para = 'c1ccc(nc1)cc1'\n    \n    # Sulfur-containing groups capable of coordinating\n    thiol = '[SX2H]'\n    thioether = '[#16X2][#6]'\n    methylthio = '[#16X2][CH3]'\n    \n    # Polyether chain (-[OCH2CH2]_n-)\n    polyether_chain = '(-OCC)n'\n    \n    # Terminal coordinating groups (e.g., -COOH, -NH2)\n    terminal_coordinating_groups = '[NX3H2,O,NX2H1]'\n    \n    # Fused aromatic rings with carbonyl groups\n    fused_aromatic_carbonyl = '[a][C](=O)[a]'\n    \n    # Linear aliphatic carboxylic acids without additional coordinating groups\n    linear_aliphatic_carboxylic_acid = '[CX4][CX4][CX4][CX4][CX3](=O)[OX2H1]'\n    \n    # Electron-donating groups at para position\n    amino_para = 'c1ccc([NX3H2,NX3H1][#6])cc1'\n    hydroxy_para = 'c1ccc([OX2H])cc1'\n    methyl_para = 'c1ccc(C)cc1'\n    \n    # Multiple adjacent hydroxyl groups (polyols)\n    polyol = '[#6]-[OX2H]-[OX2H]-[OX2H]'\n    \n    # Bulky aromatic side chains\n    bulky_aromatic_side_chain = '[CX3](C1=CC=CC=C1)'\n    indole_side_chain = '[CX3](C1=CC2=C(C=C1)NC=C2)'\n    \n    # Aldehyde groups adjacent to carboxylate\n    aldehyde_adjacent_carboxylate = '[#6][CX3](=O)[CX3H](=O)'\n    \n    # Perfluoroalkyl chains\n    perfluoroalkyl = '[CX4](F)(F)[F]'\n    \n    # Nitrogen-containing aromatic heterocycles with carboxylic acid\n    nitrogen_heterocycle_carboxylic_acid = '[n][c][c](C(=O)O)[c][c][n]'\n    \n    # Aliphatic dicarboxylic acids without additional coordinating groups\n    aliphatic_dicarboxylic_acid = '[CX3](=O)[OX2H1][CX4][CX3](=O)[OX2H1]'\n    \n    # Hydroxy groups ortho to carboxylate\n    ortho_hydroxy_carboxylic_acid = 'c1cc(OH)c(C(=O)O)cc1'\n    \n    # Methoxy groups on aromatic ring\n    methoxy_aromatic = 'c1cc(OC)ccc1C(=O)O'\n    \n    # Start defining the rules\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are linear aliphatic amino acids with a terminal amino group and a terminal carboxylic acid group connected by an unbranched carbon chain of at least four carbons predict a high Fe/Hf value (True).',\n            'patterns': [\n                terminal_amino,\n                unbranched_aliphatic_chain_4plus,\n                terminal_carboxylic_acid\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers that are aromatic carboxylic acids with strong electron-withdrawing groups at the para position predict a high Fe/Hf value (True).',\n            'patterns': [\n                aromatic_ring,\n                '[CX3](=O)[OX2H1]',\n                '[c][c]([NX3+](=O)[O-])[c]',  # Nitro group at para position\n                'c1ccc([F,Cl,Br,I])cc1'  # Halogen at para position\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers containing sulfur atoms capable of coordinating with metals predict a high Fe/Hf value (True).',\n            'patterns': [\n                '[#16]',  # Any sulfur atom\n                '[CX3](=O)[OX2H1]'  # Carboxylic acid group\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers that are aliphatic carboxylic acids with polyether chains and terminal coordinating groups predict a high Fe/Hf value (True).',\n            'patterns': [\n                '[$([OX2])[#6]]{2,}',  # Two or more ether linkages\n                '[CX3](=O)[OX2H1]',  # Carboxylic acid group\n                '[$([OX2H1,NX3H2,NX3H1])]'  # Terminal coordinating group\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers that are aromatic carboxylic acids fused with additional carbonyl-containing rings predict a high Fe/Hf value (True).',\n            'patterns': [\n                fused_aromatic_carbonyl,\n                '[CX3](=O)[OX2H1]'  # Carboxylic acid group\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers that are linear aliphatic carboxylic acids without additional coordinating groups predict a low Fe/Hf value (False).',\n            'patterns': [\n                linear_aliphatic_carboxylic_acid\n            ],\n            'exclude_patterns': [\n                '[NX3]',  # Exclude amines\n                '[OX2H]',  # Exclude additional hydroxyl groups\n                '[#16]',  # Exclude sulfur atoms\n                aromatic_ring  # Exclude aromatic rings\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers that are aromatic carboxylic acids with electron-donating groups at the para position predict a low Fe/Hf value (False).',\n            'patterns': [\n                aromatic_ring,\n                '[CX3](=O)[OX2H1]',\n                '[c][c]([NX3H2])[c]',  # Amino group at para position\n                '[c][c]([OX2H])[c]',  # Hydroxy group at para position\n                '[c][c](C)[c]'  # Methyl group at para position\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers containing multiple adjacent hydroxyl groups (polyols) predict a low Fe/Hf value (False).',\n            'patterns': [\n                polyol,\n                '[CX3](=O)[OX2H1]'  # Carboxylic acid group\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers that are amino acids with bulky aromatic side chains predict a low Fe/Hf value (False).',\n            'patterns': [\n                '[NX3][CX4][CX3](C1=CC=CC=C1)',  # Phenylalanine-like side chain\n                '[NX3][CX4][CX3](C1=CC2=C(C=C1)NC=C2)',  # Tryptophan-like side chain\n                '[CX3](=O)[OX2H1]'  # Carboxylic acid group\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers that are aromatic carboxylic acids with aldehyde groups adjacent to the carboxylate predict a low Fe/Hf value (False).',\n            'patterns': [\n                aromatic_ring,\n                '[CX3](=O)[OX2H1]',\n                '[c][CX3H](=O)'  # Aldehyde group adjacent\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers containing perfluoroalkyl chains predict a low Fe/Hf value (False).',\n            'patterns': [\n                perfluoroalkyl,\n                '[CX3](=O)[OX2H1]'  # Carboxylic acid group\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers that are nitrogen-containing aromatic heterocycles with carboxylic acid groups predict a low Fe/Hf value (False).',\n            'patterns': [\n                nitrogen_heterocycle_carboxylic_acid\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers that are aliphatic dicarboxylic acids without additional coordinating groups predict a low Fe/Hf value (False).',\n            'patterns': [\n                aliphatic_dicarboxylic_acid\n            ],\n            'exclude_patterns': [\n                '[NX3]',  # Exclude amines\n                '[OX2H]',  # Exclude additional hydroxyl groups\n                '[#16]',  # Exclude sulfur atoms\n                aromatic_ring  # Exclude aromatic rings\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers that are aromatic carboxylic acids with hydroxy groups ortho to the carboxylate predict a low Fe/Hf value (False).',\n            'patterns': [\n                ortho_hydroxy_carboxylic_acid\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers that are aromatic carboxylic acids with methoxy groups on the aromatic ring predict a high Fe/Hf value (True).',\n            'patterns': [\n                methoxy_aromatic\n            ],\n            'prediction': 1\n        }\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for smarts in rule.get('patterns', []):\n            compiled_patterns.append(Chem.MolFromSmarts(smarts))\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for smarts in rule['exclude_patterns']:\n                compiled_excludes.append(Chem.MolFromSmarts(smarts))\n            rule['compiled_exclude_patterns'] = compiled_excludes\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for pat in rule['compiled_exclude_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for pat in rule['compiled_patterns']:\n                    if not mol.HasSubstructMatch(pat):\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}