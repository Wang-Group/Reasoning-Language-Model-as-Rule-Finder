{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. It defines a set of rules based on structural features described by SMARTS patterns. Each rule is associated with patterns that, if matched in a molecule, predict either a high (+1) or low (-1) target value for that molecule. The function `rule2matrix` processes each SMILES string, applies the rules, and returns a DataFrame where each column corresponds to a rule and each row corresponds to a SMILES string.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and structural features\n    \n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    \n    # Primary amino group (-NH2)\n    primary_amine = '[NX3H2]'\n    \n    # Thiol group (-SH)\n    thiol = '[SX2H]'\n    \n    # Thioether group (-S-)\n    thioether = '[#16X2]([#6])[#6]'\n    \n    # Pyridine ring\n    pyridine_ring = 'n1cccc1'\n    \n    # Aromatic carboxylic acid\n    aromatic_carboxylic_acid = '[c][CX3](=O)[OX2H1]'\n    \n    # Electron-withdrawing groups on aromatic ring (e.g., nitro, halogens)\n    nitro_group = '[NX3](=O)=O'\n    halogen = '[c][F,Cl,Br,I]'\n    \n    # Polyether chain (-O-CH2CH2-)\n    polyether_chain = '([#6][OX2][#6][#6][OX2][#6])'\n    \n    # Aromatic amino acid (amino group attached to aliphatic chain with aromatic side chain)\n    aromatic_side_chain = '[CX3H1]([#6])[c]'\n    \n    # Multiple adjacent hydroxyl groups (polyols)\n    polyol = '[OX2H][CX4][OX2H]'\n    \n    # Amide group (-CONH-)\n    amide = '[NX3][CX3](=O)[#6]'\n    \n    # Nonaromatic heterocycles with nitrogen\n    nonaromatic_heterocycle_nitrogen = '[NR3r5,NR3r6]'\n    \n    # Electron-donating groups on aromatic ring (e.g., hydroxyl, methoxy)\n    edg_on_aromatic = '[c][OX2H,OX1-,OX2][#1,#6]'\n    \n    # Aliphatic hydroxyl group (-OH) in long chain\n    aliphatic_hydroxyl = '[CX4][OX2H]'\n    \n    # Multiple electron-withdrawing groups (e.g., fluorine atoms in aliphatic chain)\n    multiple_fluorines = '[CX4]([F])([F])[F]'\n    \n    # Ketone group adjacent to aromatic ring\n    aromatic_ketone = '[c][CX3](=O)[#6]'\n    \n    # Thioether and amide together\n    thioether_and_amide = '[NX3][CX3](=O)[#6][SX2][#6]'\n    \n    # Define the rules with their associated patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers containing both an amino group (-NH2) and a carboxylic acid group (-COOH) separated by an aliphatic chain of at least four carbon atoms predict a high Fe/Hf value.',\n            'patterns': [[primary_amine], [carboxylic_acid]],\n            'chain_length': 4,\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers featuring a pyridine ring and a carboxylic acid group (-COOH) attached directly or via a short aliphatic chain predict a high Fe/Hf value.',\n            'patterns': [[pyridine_ring], [carboxylic_acid]],\n            'max_chain_length': 3,\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers containing both a thiol group (-SH) and a carboxylic acid group (-COOH) predict a high Fe/Hf value if they are appropriately spaced to allow chelation.',\n            'patterns': [[thiol], [carboxylic_acid]],\n            'max_chain_length': 4,\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers that are carboxylic acids (aromatic or aliphatic) without additional strong coordinating groups predict a low Fe/Hf value.',\n            'patterns': [[carboxylic_acid]],\n            'exclude_patterns': [[primary_amine], [thiol], [thioether], [pyridine_ring], [polyether_chain]],\n            'prediction': -1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers that are aromatic carboxylic acids with electron-withdrawing groups (e.g., nitro -NO2) on the ring predict a high Fe/Hf value.',\n            'patterns': [[aromatic_carboxylic_acid], [nitro_group]],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers featuring polyether chains ending with a carboxylic acid group (-COOH) predict a high Fe/Hf value.',\n            'patterns': [[polyether_chain], [carboxylic_acid]],\n            'prediction': 1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers that are amino acids with aromatic side chains capable of participating in coordination predict a high Fe/Hf value.',\n            'patterns': [[aromatic_side_chain], [primary_amine], [carboxylic_acid]],\n            'prediction': 1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers containing multiple adjacent hydroxyl groups (-OH) (polyols) along with a carboxylic acid group (-COOH) predict a low Fe/Hf value.',\n            'patterns': [[polyol], [carboxylic_acid]],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers featuring a combination of amide bonds (-CONH-) and additional coordination sites such as an amino group (-NH2) or thioether (-S-) predict a high Fe/Hf value.',\n            'patterns': [[amide], [primary_amine, thioether]],\n            'prediction': 1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers containing nonaromatic heterocycles with nitrogen atoms that are less accessible for coordination predict a low Fe/Hf value.',\n            'patterns': [[nonaromatic_heterocycle_nitrogen]],\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers that are aromatic carboxylic acids with electron-donating groups (e.g., hydroxyl -OH, methoxy -OCH3) on the ring predict a low Fe/Hf value unless additional coordinating groups are present.',\n            'patterns': [[aromatic_carboxylic_acid], [edg_on_aromatic]],\n            'exclude_patterns': [[primary_amine], [thiol], [thioether], [pyridine_ring]],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers with long-chain aliphatic hydroxyl groups (-OH) and a carboxylic acid group (-COOH) predict a high Fe/Hf value.',\n            'patterns': [[aliphatic_hydroxyl], [carboxylic_acid]],\n            'chain_length': 6,\n            'prediction': 1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers containing multiple electron-withdrawing groups (e.g., fluorine atoms) in the aliphatic chain predict a low Fe/Hf value.',\n            'patterns': [[multiple_fluorines], [carboxylic_acid]],\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers containing ketone groups (C=O) adjacent to an aromatic ring and a carboxylic acid group (-COOH) predict a high Fe/Hf value when the ketone can participate in coordination.',\n            'patterns': [[aromatic_ketone], [carboxylic_acid]],\n            'prediction': 1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers containing both thioether groups (-S-) and amide bonds (-CONH-) along with a carboxylic acid group (-COOH) predict a high Fe/Hf value.',\n            'patterns': [[thioether_and_amide], [carboxylic_acid]],\n            'prediction': 1\n        }\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for group in rule.get('patterns', []):\n            compiled_group = [Chem.MolFromSmarts(p) for p in group]\n            compiled_patterns.append(compiled_group)\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for group in rule['exclude_patterns']:\n                compiled_group = [Chem.MolFromSmarts(p) for p in group]\n                compiled_excludes.append(compiled_group)\n            rule['compiled_exclude_patterns'] = compiled_excludes\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for group in rule['compiled_exclude_patterns']:\n                        for pat in group:\n                            if mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                        if not match:\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for compiled_group in rule['compiled_patterns']:\n                    group_match = False\n                    for pat in compiled_group:\n                        if mol.HasSubstructMatch(pat):\n                            group_match = True\n                            break\n                    if not group_match:\n                        match = False\n                        break\n                # Additional checks for chain length if specified\n                if match and 'chain_length' in rule:\n                    # Find all paths between the atoms of interest\n                    atom_pairs = []\n                    # For rule 1, between amino nitrogen and carboxylic acid carbon\n                    if rule['number'] == 1:\n                        amine_nitrogens = mol.GetSubstructMatches(Chem.MolFromSmarts(primary_amine))\n                        carboxyl_carbons = mol.GetSubstructMatches(Chem.MolFromSmarts(carboxylic_acid))\n                        for n in amine_nitrogens:\n                            for c in carboxyl_carbons:\n                                atom_pairs.append((n[0], c[0]))\n                    # For rule 12, between hydroxyl group and carboxylic acid\n                    elif rule['number'] == 12:\n                        hydroxyl_oxygens = mol.GetSubstructMatches(Chem.MolFromSmarts(aliphatic_hydroxyl))\n                        carboxyl_carbons = mol.GetSubstructMatches(Chem.MolFromSmarts(carboxylic_acid))\n                        for o in hydroxyl_oxygens:\n                            for c in carboxyl_carbons:\n                                atom_pairs.append((o[0], c[0]))\n                    else:\n                        atom_pairs = []\n                    path_found = False\n                    for pair in atom_pairs:\n                        path = Chem.GetShortestPath(mol, pair[0], pair[1])\n                        # Count the number of carbons in the path\n                        carbon_count = sum(1 for idx in path if mol.GetAtomWithIdx(idx).GetAtomicNum() == 6)\n                        if carbon_count >= rule['chain_length']:\n                            path_found = True\n                            break\n                    if not path_found:\n                        match = False\n                # Additional checks for max chain length if specified\n                if match and 'max_chain_length' in rule:\n                    # For rule 2 and 3\n                    atom_pairs = []\n                    if rule['number'] == 2:\n                        pyridine_nitrogens = mol.GetSubstructMatches(Chem.MolFromSmarts(pyridine_ring))\n                        carboxyl_carbons = mol.GetSubstructMatches(Chem.MolFromSmarts(carboxylic_acid))\n                        for n in pyridine_nitrogens:\n                            for c in carboxyl_carbons:\n                                atom_pairs.append((n[0], c[0]))\n                    elif rule['number'] == 3:\n                        thiol_sulfurs = mol.GetSubstructMatches(Chem.MolFromSmarts(thiol))\n                        carboxyl_carbons = mol.GetSubstructMatches(Chem.MolFromSmarts(carboxylic_acid))\n                        for s in thiol_sulfurs:\n                            for c in carboxyl_carbons:\n                                atom_pairs.append((s[0], c[0]))\n                    else:\n                        atom_pairs = []\n                    path_found = False\n                    for pair in atom_pairs:\n                        path = Chem.GetShortestPath(mol, pair[0], pair[1])\n                        # Count the number of atoms in the path excluding the endpoints\n                        path_length = len(path) - 2\n                        if path_length <= rule['max_chain_length']:\n                            path_found = True\n                            break\n                    if not path_found:\n                        match = False\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df"
}