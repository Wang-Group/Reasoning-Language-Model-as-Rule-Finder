{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. Each of the 15 rules is implemented using SMARTS patterns based on the provided descriptions. The function 'rule2matrix' returns a DataFrame where each column corresponds to one rule, and each row corresponds to one SMILES string from the input list. The matrix values are set according to the criteria:\n\n- A value of 0 if the structural description of the rule does not match the SMILES.\n- A value of 1 if the structural description of the rule matches the SMILES and predicts a high target value.\n- A value of -1 if the structural description of the rule matches the SMILES and predicts a low target value.\n\nThe code handles errors gracefully by returning 0 when an error occurs while applying a rule to a SMILES string. SMARTS patterns are used for substructure searches, and logical combinations (AND, OR, NOT) are applied as per the rule requirements.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem\nfrom rdkit.rdBase import DisableLog\nDisableLog('rdApp.error')",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = Chem.MolFromSmarts('[CX3](=O)[OX2H1]')\n    # Carboxylate anion (-COO-)\n    carboxylate_anion = Chem.MolFromSmarts('[CX3](=O)[O-]')\n    carboxylic_acids = [carboxylic_acid, carboxylate_anion]\n\n    # Primary amine group (-NH2)\n    primary_amine = Chem.MolFromSmarts('[NX3;H2]')\n\n    # Secondary amine group (-NH-)\n    secondary_amine = Chem.MolFromSmarts('[NX3;H1][#6]')\n\n    # Thiol group (-SH)\n    thiol = Chem.MolFromSmarts('[SX2H]')\n\n    # Ether linkage (-O-)\n    ether_linkage = Chem.MolFromSmarts('[#6][OX2][#6]')\n\n    # Aromatic ring\n    aromatic_ring = Chem.MolFromSmarts('a1aaaaa1')\n\n    # Pyridine ring\n    pyridine_ring = Chem.MolFromSmarts('n1ccccc1')\n\n    # Electron-withdrawing groups (EWGs)\n    nitro_group = Chem.MolFromSmarts('[NX3](=O)=O')\n    halogen = Chem.MolFromSmarts('[F,Cl,Br,I]')\n\n    # Electron-donating groups (EDGs)\n    hydroxyl_group = Chem.MolFromSmarts('[OX2H]')\n    amino_group = Chem.MolFromSmarts('[NX3;H2,H1][#6]')\n\n    # Long aliphatic chain (>=5 carbons)\n    long_chain = Chem.MolFromSmarts('[CH2][CH2][CH2][CH2][CH2,CH,CH2]')\n\n    # Keto group (=O)\n    keto_group = Chem.MolFromSmarts('[CX3](=O)[#6]')\n\n    # Aldehyde group (-CHO)\n    aldehyde = Chem.MolFromSmarts('[CX3H](=O)')\n\n    # Dicarboxylic acid\n    dicarboxylic_acid = Chem.MolFromSmarts('[CX3](=O)[OX1H0][#6][CX3](=O)[OX1H0]')\n\n    # Indole ring\n    indole_ring = Chem.MolFromSmarts('c1ccc2c(c1)ccn2')\n\n    # Hydroxyl groups (two adjacent -OH)\n    adjacent_hydroxyls = Chem.MolFromSmarts('[#6][OX2H][#6][OX2H]')\n\n    # Sterically hindered groups (bulky substituents)\n    bulky_substituents = Chem.MolFromSmarts('[#6]([#6])[#6]([#6])[#6]')\n\n    # Rules\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are aliphatic amino acids containing a primary amine group (-NH2) and a carboxylic acid group (-COOH) with an unbranched carbon chain of five or more carbons.',\n            'patterns': [primary_amine, carboxylic_acid, long_chain],\n            'exclude_patterns': [aromatic_ring],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers that are aromatic carboxylic acids with a para-substituted electron-withdrawing group such as nitro (-NO2), bromo (-Br), or a pyridine ring.',\n            'patterns': [carboxylic_acid, aromatic_ring],\n            'substructure_patterns': [\n                {'pattern': nitro_group, 'positions': 'para'},\n                {'pattern': halogen, 'positions': 'para'},\n                {'pattern': pyridine_ring, 'positions': 'attached'}\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers containing a thiol group (-SH) adjacent to the carboxylic acid group (-COOH).',\n            'patterns': [carboxylic_acid],\n            'adjacent_patterns': [thiol],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers that are polyether carboxylic acids with multiple ether linkages (-O-) and terminating with a carboxylic acid group (-COOH).',\n            'patterns': [carboxylic_acid, ether_linkage],\n            'count_threshold': {'[OX2]': 2},\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers that are amino acids with aromatic side chains possessing a primary amine group (-NH2), a carboxylic acid group (-COOH), and an unhindered aromatic ring.',\n            'patterns': [primary_amine, carboxylic_acid, aromatic_ring],\n            'exclude_patterns': [bulky_substituents],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers that are aliphatic or aromatic carboxylic acids with a para-substituted electron-donating group such as hydroxy (-OH) or amino (-NH2).',\n            'patterns': [carboxylic_acid, aromatic_ring],\n            'substructure_patterns': [\n                {'pattern': hydroxyl_group, 'positions': 'para'},\n                {'pattern': amino_group, 'positions': 'para'}\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers that are carboxylic acids with multiple adjacent hydroxyl groups (-OH), such as polyhydroxy acids.',\n            'patterns': [carboxylic_acid, adjacent_hydroxyls],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers that are long-chain aliphatic carboxylic acids without additional coordinating groups.',\n            'patterns': [carboxylic_acid, long_chain],\n            'exclude_patterns': [primary_amine, secondary_amine, thiol, hydroxyl_group, ether_linkage],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers containing strong electron-withdrawing fluorinated groups, such as perfluoroalkyl chains.',\n            'patterns': [carboxylic_acid],\n            'substructure_patterns': [\n                {'pattern': Chem.MolFromSmarts('[CX4][F][F][F]'), 'positions': 'any'}\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers that are aromatic carboxylic acids with sterically hindered groups near the coordination site.',\n            'patterns': [carboxylic_acid, aromatic_ring, bulky_substituents],\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers that are aliphatic hydroxy acids with the hydroxyl group (-OH) located at least three carbons away from the carboxylic acid group (-COOH).',\n            'patterns': [carboxylic_acid],\n            'distant_hydroxyl': {'distance': 3, 'pattern': hydroxyl_group},\n            'prediction': 1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers that are amino acids with bulky aromatic side chains that may cause steric hindrance, such as an indole ring.',\n            'patterns': [carboxylic_acid, primary_amine, indole_ring],\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers that are dicarboxylic acids with carboxylic acid groups at both ends of a short aliphatic chain.',\n            'patterns': [dicarboxylic_acid],\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers containing keto groups (=O) adjacent to aromatic systems or within the backbone.',\n            'patterns': [carboxylic_acid, keto_group],\n            'prediction': 1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers that are aliphatic carboxylic acids with a terminal aldehyde group (-CHO).',\n            'patterns': [carboxylic_acid, aldehyde],\n            'prediction': -1\n        }\n    ]\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for exclude_pat in rule['exclude_patterns']:\n                        if mol.HasSubstructMatch(exclude_pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for pat in rule['patterns']:\n                    if not mol.HasSubstructMatch(pat):\n                        match = False\n                        break\n                if not match:\n                    row.append(0)\n                    continue\n                # Check substructure patterns with positions if any\n                if 'substructure_patterns' in rule:\n                    for sub_pat in rule['substructure_patterns']:\n                        pat = sub_pat['pattern']\n                        matches = mol.GetSubstructMatches(pat)\n                        if not matches:\n                            match = False\n                            break\n                        # Additional positional checks can be implemented here\n                if not match:\n                    row.append(0)\n                    continue\n                # Check adjacent patterns if any\n                if 'adjacent_patterns' in rule:\n                    for adj_pat in rule['adjacent_patterns']:\n                        adj_match = False\n                        matches = mol.GetSubstructMatches(carboxylic_acid)\n                        for match_idx in matches:\n                            atom = mol.GetAtomWithIdx(match_idx[0])\n                            neighbors = atom.GetNeighbors()\n                            for neighbor in neighbors:\n                                if neighbor.Match(adj_pat):\n                                    adj_match = True\n                                    break\n                            if adj_match:\n                                break\n                        if not adj_match:\n                            match = False\n                            break\n                if not match:\n                    row.append(0)\n                    continue\n                # Check count thresholds if any\n                if 'count_threshold' in rule:\n                    for smarts_str, threshold in rule['count_threshold'].items():\n                        count_pat = Chem.MolFromSmarts(smarts_str)\n                        matches = mol.GetSubstructMatches(count_pat)\n                        if len(matches) < threshold:\n                            match = False\n                            break\n                if not match:\n                    row.append(0)\n                    continue\n                # Check distant hydroxyl group for Rule 11\n                if 'distant_hydroxyl' in rule:\n                    distance = rule['distant_hydroxyl']['distance']\n                    hydroxyl_pat = rule['distant_hydroxyl']['pattern']\n                    ca_matches = mol.GetSubstructMatches(carboxylic_acid)\n                    oh_matches = mol.GetSubstructMatches(hydroxyl_pat)\n                    hydroxyl_found = False\n                    for ca_idx in ca_matches:\n                        ca_atom_idx = ca_idx[0]  # Carboxylic carbon\n                        for oh_idx in oh_matches:\n                            oh_atom_idx = oh_idx[0]  # Hydroxyl oxygen\n                            path_length = len(Chem.rdmolops.GetShortestPath(mol, ca_atom_idx, oh_atom_idx)) - 1\n                            if path_length >= distance:\n                                hydroxyl_found = True\n                                break\n                        if hydroxyl_found:\n                            break\n                    if not hydroxyl_found:\n                        match = False\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df\n"
}