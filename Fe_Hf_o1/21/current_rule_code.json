{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit based on the specified rules.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and structural features\n    \n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX1H1]'\n    \n    # Primary aliphatic amine group (-NH2)\n    primary_aliph_amine = '[NX3;H2][CX4]'\n    \n    # Aromatic carboxylic acid group\n    aromatic_carboxylic_acid = '[c][CX3](=O)[OX1H1]'\n    \n    # EWGs (Electron-Withdrawing Groups)\n    halogen = '[F,Cl,Br,I]'\n    nitro_group = '[NX3](=O)[O-]'\n    trifluoromethyl = '[CX4](F)(F)F'\n    ewg_patterns = [halogen, nitro_group, trifluoromethyl]\n    \n    # EDGs (Electron-Donating Groups)\n    amino_group = '[NX3;H2,NX3;H1;!$(N-C=O)][CX4]'\n    hydroxyl_group = '[OX2H][CX4]'\n    methoxy_group = '[OX2][CH3]'\n    edg_patterns = [amino_group, hydroxyl_group, methoxy_group]\n    \n    # Thiol group (-SH)\n    thiol_group = '[SX2H]'\n    \n    # Thioether group (-S-)\n    thioether_group = '[SX2][CX4]'\n    \n    # Ether linkage (-O-)\n    ether_linkage = '[#6][OX2][#6]'\n    \n    # Pyridine ring\n    pyridine_ring = 'n1ccccc1'\n    \n    # Polyhydroxylated aliphatic acids (multiple -OH groups)\n    polyhydroxylated_aliphatic_acid = '[OX2H]'\n    \n    # Aliphatic hydroxy acid with terminal hydroxyl group\n    terminal_hydroxy_group = '[OX2H][CX4H2][CX4H2][CX4H2][C](=O)[OX1H1]'  # Approximate pattern\n    \n    # Dicarboxylic acids with unfavorable geometry\n    unfavorable_dicarboxylic_acid = '[CX3](=O)[OX1H1][CX4][CX3](=O)[OX1H1]'\n    \n    # Aromatic ring with ortho-hydroxyl or ortho-carbonyl groups\n    ortho_hydroxyl_or_carbonyl = '[c][c](O)[c](=O)[c]'\n    \n    # Define the rules\n    rules = [\n        {\n            'number': 1,\n            'description': 'High Fe/Hf: Modifiers that are \u03c9-amino aliphatic carboxylic acids with a terminal primary amino group at the end opposite the carboxylic acid.',\n            'patterns': [\n                carboxylic_acid,\n                primary_aliph_amine\n            ],\n            'exclude_patterns': [\n                '[a]',  # Exclude aromatic atoms\n                '[CX4;!H3;!H4]'  # Exclude branching carbons\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'High Fe/Hf: Modifiers that are aromatic carboxylic acids with electron-withdrawing groups (EWGs) at the para position.',\n            'patterns': [\n                aromatic_carboxylic_acid\n            ],\n            'ewg_patterns': ewg_patterns,\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Low Fe/Hf: Modifiers that are aromatic carboxylic acids with electron-donating groups (EDGs) at the para position.',\n            'patterns': [\n                aromatic_carboxylic_acid\n            ],\n            'edg_patterns': edg_patterns,\n            'prediction': -1\n        },\n        {\n            'number': 4,\n            'description': 'High Fe/Hf: Modifiers containing sulfur functional groups, such as thiols (-SH) or thioethers (-S-).',\n            'patterns': [\n                carboxylic_acid,\n                [thiol_group, thioether_group]\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'High Fe/Hf: Modifiers that have nitrogen-containing heterocyclic rings (e.g., pyridine) attached to a carboxylic acid.',\n            'patterns': [\n                carboxylic_acid,\n                pyridine_ring\n            ],\n            'prediction': 1\n        },\n        {\n            'number':6,\n            'description': 'Low Fe/Hf: Modifiers that are polyhydroxylated aliphatic acids (containing multiple hydroxyl groups).',\n            'patterns': [\n                carboxylic_acid,\n                polyhydroxylated_aliphatic_acid\n            ],\n            'min_count': {polyhydroxylated_aliphatic_acid:2},\n            'prediction': -1\n        },\n        {\n            'number':7,\n            'description': 'Low Fe/Hf: Modifiers that are aliphatic carboxylic acids without additional strong coordinating functional groups.',\n            'patterns': [\n                carboxylic_acid\n            ],\n            'exclude_patterns': [\n                '[N]', '[O]', '[S]',  # Exclude N, O, S atoms (other than the ones in carboxylic acid)\n                '[a]'  # Exclude aromatic atoms\n            ],\n            'prediction': -1\n        },\n        {\n            'number':8,\n            'description': 'High Fe/Hf: Modifiers that are \u03b1-amino acids with side chains capable of coordinating with Fe ions.',\n            'patterns': [\n                carboxylic_acid,\n                '[NX3;H2]',  # Primary amine\n                '[C][C][C](=[O])[O]'  # Approximate for \u03b1-amino acid\n            ],\n            'prediction':1\n        },\n        {\n            'number':9,\n            'description': 'High Fe/Hf: Modifiers that are aliphatic carboxylic acids with ether linkages in the chain and terminal functional groups capable of coordination.',\n            'patterns': [\n                carboxylic_acid,\n                ether_linkage\n            ],\n            'prediction':1\n        },\n        {\n            'number':10,\n            'description': 'High Fe/Hf: Modifiers that are long-chain aliphatic hydroxy acids with a terminal hydroxyl group.',\n            'patterns': [\n                terminal_hydroxy_group\n            ],\n            'prediction':1\n        },\n        # More rules can be added similarly\n    ]\n    \n    # Compile patterns\n    for rule in rules:\n        # Compile required patterns\n        compiled_patterns = []\n        for pat in rule.get('patterns', []):\n            if isinstance(pat, list):\n                compiled_group = [Chem.MolFromSmarts(p) for p in pat]\n                compiled_patterns.append(compiled_group)\n            else:\n                compiled_patterns.append(Chem.MolFromSmarts(pat))\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        exclude_patterns = rule.get('exclude_patterns', [])\n        rule['compiled_exclude_patterns'] = [Chem.MolFromSmarts(pat) for pat in exclude_patterns]\n        # Compile EWG/EDG patterns if any\n        if 'ewg_patterns' in rule:\n            rule['compiled_ewg_patterns'] = [Chem.MolFromSmarts(pat) for pat in rule['ewg_patterns']]\n        if 'edg_patterns' in rule:\n            rule['compiled_edg_patterns'] = [Chem.MolFromSmarts(pat) for pat in rule['edg_patterns']]\n        # Compile min_count patterns if any\n        if 'min_count' in rule:\n            rule['compiled_min_count'] = {Chem.MolFromSmarts(pat):count for pat, count in rule['min_count'].items()}\n    \n    # Initialize results list\n    results = []\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                for ex_pat in rule.get('compiled_exclude_patterns', []):\n                    if mol.HasSubstructMatch(ex_pat):\n                        match = False\n                        break\n                if not match:\n                    row.append(0)\n                    continue\n                # Check required patterns\n                for pat in rule['compiled_patterns']:\n                    if isinstance(pat, list):\n                        # Group of patterns, match any\n                        group_match = False\n                        for sub_pat in pat:\n                            if mol.HasSubstructMatch(sub_pat):\n                                group_match = True\n                                break\n                        if not group_match:\n                            match = False\n                            break\n                    else:\n                        if not mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                if not match:\n                    row.append(0)\n                    continue\n                # Check min_count patterns if any\n                if 'compiled_min_count' in rule:\n                    for pat, count in rule['compiled_min_count'].items():\n                        matches = mol.GetSubstructMatches(pat)\n                        if len(matches) < count:\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # For rules with EWG/EDG patterns at para position\n                if 'compiled_ewg_patterns' in rule:\n                    match = check_substituent_at_para(mol, rule['compiled_ewg_patterns'], functional_group='EWG')\n                    if not match:\n                        row.append(0)\n                        continue\n                if 'compiled_edg_patterns' in rule:\n                    match = check_substituent_at_para(mol, rule['compiled_edg_patterns'], functional_group='EDG')\n                    if not match:\n                        row.append(0)\n                        continue\n                # If all conditions are satisfied\n                row.append(rule['prediction'])\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df\n\ndef check_substituent_at_para(mol, patterns, functional_group='EWG'):\n    # Function to check if any of the patterns are present at the para position relative to a carboxylic acid group on an aromatic ring\n    # Find aromatic carboxylic acid groups\n    carboxylic_acid_pat = Chem.MolFromSmarts('[c][CX3](=O)[OX1H1]')\n    matches = mol.GetSubstructMatches(carboxylic_acid_pat)\n    if not matches:\n        return False\n    for match in matches:\n        aromatic_c_idx = match[0]  # Index of the aromatic carbon connected to COOH\n        # Get the benzene ring that aromatic_c_idx is part of\n        ring_info = mol.GetRingInfo()\n        atom_rings = ring_info.AtomRings()\n        for ring in atom_rings:\n            if aromatic_c_idx in ring and len(ring) == 6:\n                # Found a benzene ring\n                # Find the atom at para position\n                idx_in_ring = ring.index(aromatic_c_idx)\n                para_idx = ring[(idx_in_ring + 3) % 6]\n                para_atom = mol.GetAtomWithIdx(para_idx)\n                # Check if the atom at para position has substituents matching the patterns\n                for nbr in para_atom.GetNeighbors():\n                    if nbr.GetIdx() not in ring:\n                        # Neighbor not in ring (i.e., substituent)\n                        bond = mol.GetBondBetweenAtoms(para_atom.GetIdx(), nbr.GetIdx())\n                        patt = Chem.MolFromSmiles(Chem.MolToSmiles(mol, rootedAtAtom=para_atom.GetIdx()))\n                        for pat in patterns:\n                            if pat.HasSubstructMatch(patt):\n                                return True\n    return False\n"
}