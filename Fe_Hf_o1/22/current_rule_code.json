{
    "prefix": "This code converts a list of SMILES strings into a feature matrix based on the provided rules using RDKit. Each rule corresponds to a specific structural pattern that influences the Fe/Hf value. The code checks for the presence or absence of these patterns in each molecule and assigns a value according to the rule. A value of 1 indicates the rule matches and predicts a high Fe/Hf value, -1 indicates a match with a low Fe/Hf prediction, and 0 indicates no match.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    \n    # Primary amino group (-NH2)\n    primary_amino = '[NX3H2]'\n    \n    # Aliphatic chain of five or more carbons (non-aromatic)\n    aliphatic_chain_5plus = 'CCCC[C;!R]'\n    \n    # Thiol group (-SH)\n    thiol = '[SX2H]'\n    \n    # Ether linkage (-O-)\n    ether_linkage = '[#6][OX2][#6]'\n    \n    # Coordinating groups (amino or methoxy)\n    amino_group = '[NX3;H2,H1;!$(NC=O)]'\n    methoxy_group = '[OX2][CH3]'\n    \n    # Pyridine ring\n    pyridine_ring = '[n][c]:[c]:[c]:[c]:[c]'\n    \n    # Flexible aliphatic linker (non-aromatic chain of two or more carbons)\n    aliphatic_linker = 'CCC'\n    \n    # Simple carboxylic acid without additional coordinating groups\n    simple_carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Exclude patterns for Rule 5\n    exclude_coordinating_groups = '[#7,#8,#16]'  # Exclude N, O, S\n    \n    # Hydroxyl group on aliphatic chain\n    hydroxyl_aliphatic = '[C][C][C][C][C][OX2H]'\n    \n    # Electron-donating groups on aromatic ring connected via flexible linkers\n    edg_on_aromatic = '[c][OX2H,OX2][C][C][C](=O)[OX1H0-,OX2H1]'\n    \n    # Multiple carboxylic acid groups\n    multiple_carboxylic_acids = '[$([CX3](=O)[OX1H0-,OX2H1]),$([CX3](=O)[O-])][#6][CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Electron-withdrawing groups (e.g., fluorinated chains, trifluoromethyl groups)\n    ewgs = '[CX4][F,Cl,Br,I]'\n    \n    # Bulky, rigid structures with no additional coordinating groups\n    bulky_rigid = '[c]1[c][c][c][c][c]1'\n    \n    # Oxygen-containing heterocycles directly attached to carboxylic acid groups\n    oxygen_heterocycle = '[o][c][c](=O)[OX1H0-,OX2H1]'\n    \n    # Sulfur in side chains (e.g., sulfides, thioethers)\n    sulfur_side_chain = '[#16][#6]'\n    \n    # Amide linkages adjacent to coordinating groups\n    amide_adjacent = '[NX3][CX3](=O)[#7,#8,#16]'\n    \n    # Hydroxyl groups attached directly to aromatic rings (phenolic groups)\n    phenolic_oh = '[c][OX2H]'\n    \n    # Compile SMARTS patterns\n    smarts_patterns = {\n        'Rule 1': {\n            'patterns': [primary_amino, aliphatic_chain_5plus],\n            'prediction': 1\n        },\n        'Rule 2': {\n            'patterns': [thiol],\n            'prediction': 1\n        },\n        'Rule 3': {\n            'patterns': [ether_linkage, amino_group + ',' + methoxy_group],\n            'prediction': 1\n        },\n        'Rule 4': {\n            'patterns': [pyridine_ring, aliphatic_linker],\n            'prediction': 1\n        },\n        'Rule 5': {\n            'patterns': [simple_carboxylic_acid],\n            'exclude': [exclude_coordinating_groups],\n            'prediction': -1\n        },\n        'Rule 6': {\n            'patterns': [hydroxyl_aliphatic],\n            'prediction': 1\n        },\n        'Rule 7': {\n            'patterns': [edg_on_aromatic],\n            'prediction': 1\n        },\n        'Rule 8': {\n            'patterns': [multiple_carboxylic_acids],\n            'prediction': -1\n        },\n        'Rule 9': {\n            'patterns': [ewgs],\n            'prediction': -1\n        },\n        'Rule 10': {\n            'patterns': [bulky_rigid],\n            'exclude': [amide_adjacent],\n            'prediction': -1\n        },\n        'Rule 11': {\n            'patterns': [sulfur_side_chain],\n            'prediction': 1\n        },\n        'Rule 12': {\n            'patterns': [amide_adjacent],\n            'prediction': 1\n        },\n        'Rule 13': {\n            'patterns': [phenolic_oh],\n            'prediction': -1\n        },\n        'Rule 14': {\n            'patterns': [bulky_rigid],\n            'prediction': -1\n        },\n        'Rule 15': {\n            'patterns': [oxygen_heterocycle],\n            'prediction': -1\n        }\n    }\n    \n    # Compile patterns\n    for rule in smarts_patterns.values():\n        compiled_patterns = []\n        for pattern in rule.get('patterns', []):\n            subpatterns = pattern.split(',')  # Handle multiple patterns separated by commas\n            compiled_subpatterns = [Chem.MolFromSmarts(p.strip()) for p in subpatterns]\n            compiled_patterns.append(compiled_subpatterns)\n        rule['compiled_patterns'] = compiled_patterns\n        \n        # Compile exclude patterns if any\n        if 'exclude' in rule:\n            compiled_exclude = []\n            for pattern in rule['exclude']:\n                compiled_exclude.append(Chem.MolFromSmarts(pattern))\n            rule['compiled_exclude'] = compiled_exclude\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(smarts_patterns))\n            continue\n        row = []\n        for rule_name, rule in smarts_patterns.items():\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'compiled_exclude' in rule:\n                    for pat in rule['compiled_exclude']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for pattern_group in rule['compiled_patterns']:\n                    group_match = False\n                    for pat in pattern_group:\n                        if mol.HasSubstructMatch(pat):\n                            group_match = True\n                            break\n                    if not group_match:\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=smarts_patterns.keys())\n    return df\n"
}