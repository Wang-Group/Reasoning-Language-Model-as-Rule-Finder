{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. Each rule corresponds to a specific chemical structural pattern that predicts either a high or low Fe/Hf value. The function 'rule2matrix' processes each SMILES string, checks for matches against the defined rules using SMARTS patterns, and constructs a DataFrame with the results.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import rdMolDescriptors",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and structural features based on the rules\n    \n    # Rule 1: Aliphatic amino acids with terminal primary amino group (-NH2) and carboxylate group, carbon chains of 5 to 8 carbons\n    rule1_smarts = '[N;X3;H2][C;X4][C;X4][C;X4][C;X4][C;X3](=O)[O;H1,-1]'\n    \n    # Rule 2: Aromatic carboxylic acids with strong EWGs at para position\n    ewg_para_smarts = '[c][c](C(=O)[O;H1,-1])[c][c][c][$(c[F,Cl,Br,I]),$(c[N+](=O)[O-])]'\n    \n    # Rule 3: Aromatic carboxylic acids with EDGs at para position\n    edg_para_smarts = '[c][c](C(=O)[O;H1,-1])[c][c][c][$(c[NH2,NH,R]);!$(c[N+](=O)[O-])]'\n    \n    # Rule 4: Heterocyclic aromatic rings with nitrogen atoms positioned to coordinate (e.g., pyridine rings at 4-position)\n    rule4_smarts = '[n][c][c][c](C(=O)[O;H1,-1])[c][c]'\n    \n    # Rule 5: Aliphatic carboxylic acids with terminal hydroxy groups (-OH)\n    rule5_smarts = '[O;H1][C;X4][C;X4][C;X4][C;X3](=O)[O;H1,-1]'\n    \n    # Rule 6: Modifiers with multiple coordinating functional groups (amino, hydroxy, ether linkages) in flexible aliphatic chains\n    rule6_smarts = '[$([N;X3;H2]),$([O;H1]),$([O][C;X4])][C;X4][C;X4][C;X4][C;X3](=O)[O;H1,-1]'\n    \n    # Rule 7: Modifiers containing sulfur atoms in functional groups such as thiol (-SH) or thioether (-S-)\n    rule7_smarts = '[$([S;X2;H1]),$([S][C;X4])][C;X4][C;X3](=O)[O;H1,-1]'\n    \n    # Rule 8: Modifiers containing perfluorinated alkyl chains\n    rule8_smarts = '[C](F)(F)[C](F)(F)F'\n    \n    # Rule 9: Modifiers with multiple hydroxyl groups on rigid or bulky aliphatic chains\n    rule9_smarts = '[C;X4]([O;H1])([O;H1])[C;X3](=O)[O;H1,-1]'\n    \n    # Rule 10: Bulky or rigid aromatic structures without additional coordinating groups\n    rule10_smarts = '[c][c]([C;X3](=O)[O;H1,-1])[c][c][c][c]'\n    \n    # Rule 11: Dicarboxylic acids with adjacent carbonyl groups (e.g., alpha-keto diacids)\n    rule11_smarts = 'O=C[C;X3](=O)[O;H1,-1]'\n    \n    # Rule 12: Aromatic carboxylic acids with methoxy groups on the aromatic ring and additional coordinating groups\n    rule12_smarts = '[c][c](C(=O)[O;H1,-1])[c][c](OC)[c][c]'\n    \n    # Rule 13: Aldehyde groups adjacent to carboxylic acids on aromatic rings\n    rule13_smarts = '[c][c](C=O)[c][c](C(=O)[O;H1,-1])[c][c]'\n    \n    # Rule 14: Flexible ether linkages with terminal coordinating groups (e.g., amino or carboxylate)\n    rule14_smarts = '[O][C;X4][C;X4][O][C;X4][C;X3](=O)[O;H1,-1]'\n    \n    # Rule 15: Fused aromatic systems containing additional carbonyl groups facilitating coordination\n    rule15_smarts = '[o][c](C(=O)[O;H1,-1])[c]1[c](=O)[c][c][c][o]1'\n    \n    # List of rules with their SMARTS patterns and predictions\n    rules = [\n        {'number': 1, 'smarts': rule1_smarts, 'prediction': 1},\n        {'number': 2, 'smarts': ewg_para_smarts, 'prediction': 1},\n        {'number': 3, 'smarts': edg_para_smarts, 'prediction': -1},\n        {'number': 4, 'smarts': rule4_smarts, 'prediction': 1},\n        {'number': 5, 'smarts': rule5_smarts, 'prediction': 1},\n        {'number': 6, 'smarts': rule6_smarts, 'prediction': 1},\n        {'number': 7, 'smarts': rule7_smarts, 'prediction': 1},\n        {'number': 8, 'smarts': rule8_smarts, 'prediction': -1},\n        {'number': 9, 'smarts': rule9_smarts, 'prediction': -1},\n        {'number': 10, 'smarts': rule10_smarts, 'prediction': -1},\n        {'number': 11, 'smarts': rule11_smarts, 'prediction': -1},\n        {'number': 12, 'smarts': rule12_smarts, 'prediction': 1},\n        {'number': 13, 'smarts': rule13_smarts, 'prediction': -1},\n        {'number': 14, 'smarts': rule14_smarts, 'prediction': 1},\n        {'number': 15, 'smarts': rule15_smarts, 'prediction': 1},\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        rule['pattern'] = Chem.MolFromSmarts(rule['smarts'])\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                if mol.HasSubstructMatch(rule['pattern']):\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except:\n                # In case of an error, append 0\n                row.append(0)\n        results.append(row)\n    \n    # Create DataFrame with results\n    columns = [f\"Rule {rule['number']}\" for rule in rules]\n    df = pd.DataFrame(results, columns=columns)\n    return df\n"
}