{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit. It defines multiple rules based on structural features from the provided natural language descriptions, and applies these rules to each SMILES string. For each rule, it uses SMARTS patterns to identify matching substructures within the SMILES molecules. The output is a DataFrame where each column corresponds to a rule, and each row corresponds to a SMILES string. A value of 0 indicates no match, 1 indicates a match that predicts a high target value (Fe/Hf_high_or_low_value = True), and -1 indicates a match that predicts a low target value (Fe/Hf_high_or_low_value = False).",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define the rules with their associated patterns and predictions\n    # Each rule is a dictionary containing 'number', 'description', 'patterns', and 'prediction'\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers with Terminal Amino Groups on Aliphatic Chains (\u03c9-Amino Acids)',\n            'patterns': [\n                '[NX3;H2][CH2][CH2][CH2][CH2][CX3](=O)[OX1H1]',  # Terminal amino group and carboxylic acid\n                '[NX3;H2][CH2][CH2][CH2][CX3](=O)[OX1H1]',         # Near-terminal amino group\n            ],\n            'exclude_patterns': [\n                '[R]'  # Exclude rings\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers Containing Sulfur-Containing Functional Groups (Thiol or Thioether Groups)',\n            'patterns': [\n                '[SX2H]',  # Thiol group\n                '[#16X2][#6]',  # Thioether group\n                '[CX3](=O)[OX1H1]',  # Carboxylic acid group\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers with Strong Electron-Withdrawing Groups (EWGs) on Aromatic Rings',\n            'patterns': [\n                '[c][CX3](=O)[OX1H1]',  # Aromatic carboxylic acid\n                '[c;$([c]1[c][c][c][c][c]1)][NX3+](=O)[O-]',  # Nitro group on aromatic ring\n                '[c][CH2][F,Cl,Br,I]',  # Halomethyl group on aromatic ring\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers with Additional Coordinating Groups Attached via Flexible Aliphatic Linkers',\n            'patterns': [\n                '[c][CH2][CH2][CH2][CX3](=O)[OX1H1]',  # Aromatic ring connected via aliphatic linker to carboxylic acid\n                '[n][CH2][CH2][CH2][CX3](=O)[OX1H1]',  # Pyridine ring connected via aliphatic linker\n                '[c][CH2][CH2][CX3](=O)[OX1H1]',       # Shorter linker\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers with Polyether Chains Containing Donor Atoms',\n            'patterns': [\n                '([#6][OX2]){2,}[#6][CX3](=O)[OX1H1]',  # Polyether chain ending with carboxylic acid\n                '[OX2][CX2][OX2][CX2][OX2][CX2][OX2][CX3](=O)[OX1H1]',  # Explicit ether chain\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers with Hydroxyl Groups Distant from the Carboxylate Group on Aliphatic Chains',\n            'patterns': [\n                '[OX2H][CH2][CH2][CH2][CH2][CX3](=O)[OX1H1]',  # Hydroxyl group distant from carboxylic acid\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers with Multiple Carboxylate Groups and Short Aliphatic Chains (Dicarboxylic Acids with Short Chains)',\n            'patterns': [\n                '[CX3](=O)[OX1H1][CH2][CH2][CX3](=O)[OX1H1]',  # Dicarboxylic acid with short chain\n                '[CX3](=O)[OX1H1][CH2][CX3](=O)[OX1H1]',        # Even shorter chain\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers Without Additional Strong Coordinating Groups (Simple Carboxylic Acids)',\n            'patterns': [\n                '[CX3](=O)[OX1H1]',  # Carboxylic acid group\n            ],\n            'exclude_patterns': [\n                '[NX3]',    # Exclude amine groups\n                '[SX2]',    # Exclude sulfur-containing groups\n                '[OX2H]',   # Exclude additional hydroxyl groups\n                '[c]',      # Exclude aromatic rings\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers with Electron-Donating Groups (EDGs) on Aromatic Rings Without Additional Coordinating Atoms',\n            'patterns': [\n                '[c][CX3](=O)[OX1H1]',     # Aromatic carboxylic acid\n                '[c][OX2H]',               # Hydroxyl group on aromatic ring\n                '[c][NX3;H2]',             # Amino group on aromatic ring\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers with Multiple Hydroxyl Groups Near the Carboxylate (Polyols)',\n            'patterns': [\n                '[CX3](=O)[OX1H1][CH](O)[CH](O)[CH](O)',  # Multiple hydroxyl groups near carboxylate\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers with Rigid Heteroaromatic Rings Directly Attached to Carboxylate Groups',\n            'patterns': [\n                '[n][c][c][CX3](=O)[OX1H1]',  # Heteroaromatic ring attached to carboxylate\n                '[n][c][CX3](=O)[OX1H1]',\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers with Electron-Rich Aromatic Rings (e.g., Indole Rings) Attached to Amino Acids',\n            'patterns': [\n                '[n][c]1[c][c][c][c]1[CH2][CH](NH2)[CX3](=O)[OX1H1]',  # Indole ring attached to amino acid\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers with Heavily Fluorinated Aliphatic Chains',\n            'patterns': [\n                '[CX4]([F,Cl,Br,I])([F,Cl,Br,I])([F,Cl,Br,I])[CX3](=O)[OX1H1]',  # Trifluoromethyl group adjacent to carboxylic acid\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers with Carbonyl Groups Adjacent to the Carboxylate Group (\u03b1-Keto Acids)',\n            'patterns': [\n                '[CX3](=O)[CX3](=O)[OX1H1]',  # \u03b1-Keto acid\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers with Trifluoroacetyl Groups',\n            'patterns': [\n                '[CX3](=O)[CX4]([F,Cl,Br,I])([F,Cl,Br,I])[F,Cl,Br,I]',  # Trifluoroacetyl group\n            ],\n            'prediction': -1\n        },\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for smarts in rule.get('patterns', []):\n            try:\n                pat = Chem.MolFromSmarts(smarts)\n                compiled_patterns.append(pat)\n            except Exception:\n                compiled_patterns.append(None)\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for smarts in rule['exclude_patterns']:\n                try:\n                    pat = Chem.MolFromSmarts(smarts)\n                    compiled_excludes.append(pat)\n                except Exception:\n                    compiled_excludes.append(None)\n            rule['compiled_exclude_patterns'] = compiled_excludes\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'compiled_exclude_patterns' in rule:\n                    for pat in rule['compiled_exclude_patterns']:\n                        if pat is not None and mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for pat in rule['compiled_patterns']:\n                    if pat is not None:\n                        if not mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    else:\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df\n"
}