{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit, following specific rules to identify structural features associated with high or low target values. Each column represents a rule, and each row represents a SMILES string from the input list. The matrix contains values of 0 if the rule does not match the SMILES, 1 if the rule matches and predicts a high target value, and -1 if the rule matches and predicts a low target value.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and structural features\n    # Corrected and improved patterns based on the suggestions\n\n    # Common patterns\n\n    # Carboxylic acid group (-COOH) including both neutral and anionic forms\n    carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1]'\n    carboxylic_acid_patterns = [carboxylic_acid]\n\n    # Primary amino group (-NH2)\n    primary_amino_group = '[NX3;H2]'\n\n    # Ether linkage (-O-)\n    ether_linkage = '[OX2H][CX4]'\n\n    # Thiol group (-SH)\n    thiol_group = '[SX2H]'\n\n    # Thioether group (-S-)\n    # As per suggestion 3\n    thioether_group = '[SX2][#6]'\n\n    # Aromatic ring\n    aromatic_ring = 'c1ccccc1'  # Benzene ring\n\n    # Halogen\n    halogen = '[F,Cl,Br,I]'\n\n    # Nitro group\n    nitro_group = '[NX3](=O)[O-]'\n\n    # Pyridine ring\n    pyridine_ring = 'n1ccccc1'  # Pyridine ring\n\n    # Hydroxyl group (-OH)\n    hydroxyl_group = '[OX2H]'\n\n    # Hydroxyl group attached to carbon\n    hydroxyl_on_carbon = '[CX4][OX2H]'\n\n    # Define rules and their SMARTS patterns\n\n    rules = []\n\n    # Rule 1: Modifiers that are aliphatic carboxylic acids with a terminal primary amino group (-NH2) on the end of an alkyl chain (\u03c9-amino acids)\n    rule1_pattern = '[NX3;H2][CH2]{2,}[CH2][CX3](=O)[OX1H0-,OX2H1]'\n    rules.append({\n        'number': 1,\n        'description': 'Aliphatic carboxylic acids with a terminal primary amino group (-NH2) on the end of an alkyl chain (\u03c9-amino acids)',\n        'patterns': [rule1_pattern],\n        'prediction': 1\n    })\n\n    # Rule 2: Aromatic carboxylic acids with para-substituted strong electron-withdrawing group capable of enhancing metal coordination, such as nitro (-NO2), halomethyl (-CH2X), or pyridyl rings\n    # Need to ensure that the substituent is in the para position relative to the carboxylic acid group\n    rule2_patterns = [\n        # Para-nitrobenzoic acid\n        '[OX2H][c]1ccc([NX3](=O)[O-])cc1',\n        '[OX2H][c]1ccc([NX3](=O)[OX1])cc1',\n        # Para-halomethylbenzoic acid\n        '[OX2H][c]1ccc(C[Cl,Br,I,F])cc1',\n        # Para-pyridyl substituted benzoic acid\n        '[OX2H][c]1ccc(c2ncccc2)cc1',\n        # Include 1,3-dioxo-2-benzofuran-5-carboxylic acid\n        '[OX2H][c]1ccc2c(=O)oc(=O)c2c1'\n    ]\n    rules.append({\n        'number': 2,\n        'description': 'Aromatic carboxylic acids with para-substituted strong electron-withdrawing groups',\n        'patterns': rule2_patterns,\n        'prediction': 1\n    })\n\n    # Rule 3: Modifiers containing sulfur-functional groups (thiols (-SH) or thioethers (-S-)), along with a carboxylic acid group\n    rules.append({\n        'number': 3,\n        'description': 'Modifiers containing sulfur-functional groups (thiols or thioethers) along with a carboxylic acid group',\n        'sulfur_patterns': [thiol_group, thioether_group],\n        'carboxylic_acid_patterns': carboxylic_acid_patterns,\n        'prediction': 1\n    })\n\n    # Rule 4: Modifiers that are aliphatic carboxylic acids with polyether chains containing multiple ether linkages (-O-) and terminal amino groups (-NH2)\n    # Let's assume polyether chain is at least two ether linkages\n    rule4_pattern = '[NX3;H2][CX4]([OX2][CX4]){2,}[CX3](=O)[OX1H0-,OX2H1]'\n    rules.append({\n        'number': 4,\n        'description': 'Aliphatic carboxylic acids with polyether chains containing multiple ether linkages (-O-) and terminal amino groups (-NH2)',\n        'patterns': [rule4_pattern],\n        'prediction': 1\n    })\n\n    # Rule 5: Modifiers that are amino acids with side chains capable of metal coordination\n    # Amino acid backbone\n    amino_acid_backbone = '[NX3H2][CX4H]([*])[CX3](=O)[OX1H0-,OX2H1]'\n    # Side chain patterns\n    side_chain_patterns = [\n        '[CX3](=O)[OX1H0-,OX2H1]',  # Carboxylic acid side chain\n        'c',  # Aromatic ring side chain\n        thiol_group,  # Thiol side chain\n        '[NX3;H2]',  # Amino group side chain\n    ]\n    rules.append({\n        'number': 5,\n        'description': 'Modifiers that are amino acids with side chains capable of metal coordination',\n        'backbone_pattern': amino_acid_backbone,\n        'side_chain_patterns': side_chain_patterns,\n        'prediction': 1\n    })\n\n    # Rule 6: Modifiers that are aromatic carboxylic acids with para-substituted electron-donating groups\n    # Such as hydroxyl (-OH), amino (-NH2), alkyl (-CH3), or formyl (-CHO) groups\n    rule6_patterns = [\n        # Para-hydroxybenzoic acid\n        '[OX2H][c]1ccc([OX2H])cc1',\n        # Para-aminobenzoic acid\n        '[OX2H][c]1ccc([NX3;H2])cc1',\n        # Para-methylbenzoic acid\n        '[OX2H][c]1ccc(C)cc1',\n        # Para-formylbenzoic acid\n        '[OX2H][c]1ccc(C=O)cc1'\n    ]\n    rules.append({\n        'number': 6,\n        'description': 'Aromatic carboxylic acids with para-substituted electron-donating groups',\n        'patterns': rule6_patterns,\n        'prediction': -1\n    })\n\n    # Rule 7: Modifiers that are aliphatic carboxylic acids without additional coordinating functional groups or with groups that do not enhance metal coordination\n    # Exclude patterns are primary amino group, thiol, thioether, ether linkage, aromatic ring, and substituents that enhance coordination\n    exclude_patterns_rule7 = [\n        primary_amino_group,\n        thiol_group,\n        thioether_group,\n        ether_linkage,\n        'c'  # Any aromatic carbon\n    ]\n    rules.append({\n        'number': 7,\n        'description': 'Aliphatic carboxylic acids without additional coordinating functional groups',\n        'patterns': carboxylic_acid_patterns,\n        'exclude_patterns': exclude_patterns_rule7,\n        'prediction': -1\n    })\n\n    # Rule 8: Modifiers containing multiple hydroxyl groups (-OH), such as polyols or sugar acids\n    rules.append({\n        'number': 8,\n        'description': 'Modifiers containing multiple hydroxyl groups (-OH), such as polyols or sugar acids',\n        'hydroxyl_pattern': hydroxyl_on_carbon,\n        'hydroxyl_count_threshold': 2,  # At least two hydroxyl groups\n        'prediction': -1\n    })\n\n    # Rule 9: Modifiers that are heteroaromatic carboxylic acids where the heteroatom is adjacent to the carboxyl group\n    rule9_patterns = [\n        # Nicotinic acid (pyridine-3-carboxylic acid)\n        '[n][c]c(cc1)C(=O)[OX1H0-,OX2H1]',\n        # Pyrazole-4-carboxylic acid\n        '[n][n][c](cc1)C(=O)[OX1H0-,OX2H1]',\n        # 2-oxo-1H-pyridine-4-carboxylic acid\n        'O=C1NC=CC=C1C(=O)[OX1H0-,OX2H1]'\n    ]\n    rules.append({\n        'number': 9,\n        'description': 'Heteroaromatic carboxylic acids where the heteroatom is adjacent to the carboxyl group',\n        'patterns': rule9_patterns,\n        'prediction': -1\n    })\n\n    # Rule 10: Modifiers that are amino acids with bulky or sterically hindered side chains, such as tryptophan and glutamic acid\n    # Bulky side chains\n    # Tryptophan side chain (indole ring)\n    bulky_side_chain_patterns = [\n        # Indole ring\n        'c1cc2c(c1)cccn2',  # Indole group\n        # Side chain carboxylate (glutamic acid)\n        '[CH2][CH2][CX3](=O)[OX1H0-,OX2H1]'\n    ]\n    rules.append({\n        'number': 10,\n        'description': 'Amino acids with bulky or sterically hindered side chains',\n        'backbone_pattern': amino_acid_backbone,\n        'side_chain_patterns': bulky_side_chain_patterns,\n        'prediction': -1\n    })\n\n    # Compile patterns\n    for rule in rules:\n        if 'patterns' in rule:\n            rule['compiled_patterns'] = [Chem.MolFromSmarts(pat) for pat in rule['patterns']]\n        if 'exclude_patterns' in rule:\n            rule['compiled_exclude_patterns'] = [Chem.MolFromSmarts(pat) for pat in rule['exclude_patterns']]\n        if 'sulfur_patterns' in rule:\n            rule['compiled_sulfur_patterns'] = [Chem.MolFromSmarts(pat) for pat in rule['sulfur_patterns']]\n        if 'carboxylic_acid_patterns' in rule:\n            rule['compiled_carboxylic_acid_patterns'] = [Chem.MolFromSmarts(pat) for pat in rule['carboxylic_acid_patterns']]\n        if 'backbone_pattern' in rule:\n            rule['compiled_backbone_pattern'] = Chem.MolFromSmarts(rule['backbone_pattern'])\n        if 'side_chain_patterns' in rule:\n            rule['compiled_side_chain_patterns'] = [Chem.MolFromSmarts(pat) for pat in rule['side_chain_patterns']]\n        if 'hydroxyl_pattern' in rule:\n            rule['compiled_hydroxyl_pattern'] = Chem.MolFromSmarts(rule['hydroxyl_pattern'])\n\n    # Process each SMILES string\n    results = []\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = False\n                # For rules with exclude patterns\n                if 'exclude_patterns' in rule:\n                    exclude = False\n                    for ex_pat in rule['compiled_exclude_patterns']:\n                        if mol.HasSubstructMatch(ex_pat):\n                            exclude = True\n                            break\n                    if exclude:\n                        row.append(0)\n                        continue\n                # Rule-specific matching\n                if rule['number'] == 3:\n                    # Need to match both sulfur group and carboxylic acid\n                    sulfur_match = any(mol.HasSubstructMatch(pat) for pat in rule['compiled_sulfur_patterns'])\n                    carboxylic_acid_match = any(mol.HasSubstructMatch(pat) for pat in rule['compiled_carboxylic_acid_patterns'])\n                    if sulfur_match and carboxylic_acid_match:\n                        match = True\n                elif rule['number'] == 5 or rule['number'] ==10:\n                    # Need to match amino acid backbone and appropriate side chain\n                    backbone_match = mol.HasSubstructMatch(rule['compiled_backbone_pattern'])\n                    if backbone_match:\n                        side_chain_match = any(mol.HasSubstructMatch(pat) for pat in rule['compiled_side_chain_patterns'])\n                        if side_chain_match:\n                            match = True\n                elif rule['number'] == 8:\n                    # Need to check if molecule contains multiple hydroxyl groups attached to carbons\n                    hydroxyl_matches = mol.GetSubstructMatches(rule['compiled_hydroxyl_pattern'])\n                    if len(hydroxyl_matches) >= rule['hydroxyl_count_threshold']:\n                        match = True\n                else:\n                    for pat in rule['compiled_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = True\n                            break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df"
}