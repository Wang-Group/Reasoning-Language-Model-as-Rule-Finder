{
    "prefix": "This code defines a function 'rule2matrix' that takes a list of SMILES strings as input and converts them into a feature matrix based on specific chemical rules using RDKit. Each rule corresponds to a column in the output DataFrame, and each SMILES string corresponds to a row. The rules are designed to predict high or low Fe/Hf values based on the presence or absence of certain structural features in the molecules, using SMARTS patterns for substructure searching.\n\nThe function handles errors gracefully by assigning a value of 0 when an error occurs while applying a rule to a SMILES string.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define the SMARTS patterns for various functional groups and features\n    \n    # Common patterns\n    carboxylic_acid_pattern = '[CX3](=O)[OX2H1]'  # Carboxylic acid group\n    primary_aliphatic_amine_pattern = '[NX3H2;!$([N][!C]);!$([N][a])]'  # Primary aliphatic amine\n    secondary_aliphatic_amine_pattern = '[NX3H1;!$([N][!C]);!$([N][a])]'  # Secondary aliphatic amine\n    thiol_pattern = '[SX2H]'  # Thiol group\n    hydroxyl_pattern = '[OX2H]'  # Hydroxyl group\n    ether_oxygen_pattern = '[#6][OX2][#6]'  # Ether linkage\n    pyridine_ring_pattern = 'n1ccccc1'  # Pyridine ring\n    \n    # Electron-withdrawing groups (EWGs)\n    nitro_group_pattern = '[NX3](=O)=O'  # Nitro group\n    halogen_pattern = '[F,Cl,Br,I]'      # Halogens\n    trifluoromethyl_pattern = '[CX4](F)(F)F'  # Trifluoromethyl group\n    \n    # Electron-donating groups (EDGs)\n    amino_group_pattern = '[NX3][CX4]'  # Amino group attached to carbon\n    alkoxy_group_pattern = '[OX2][CX4]'         # Alkoxy group\n    \n    # Aromatic carboxylic acid group\n    aromatic_carboxylic_acid_pattern = '[c][CX3](=O)[OX2H1]'\n    \n    # Pre-compile the SMARTS patterns\n    carboxylic_acid = Chem.MolFromSmarts(carboxylic_acid_pattern)\n    primary_aliphatic_amine = Chem.MolFromSmarts(primary_aliphatic_amine_pattern)\n    secondary_aliphatic_amine = Chem.MolFromSmarts(secondary_aliphatic_amine_pattern)\n    thiol = Chem.MolFromSmarts(thiol_pattern)\n    hydroxyl = Chem.MolFromSmarts(hydroxyl_pattern)\n    ether_oxygen = Chem.MolFromSmarts(ether_oxygen_pattern)\n    pyridine_ring = Chem.MolFromSmarts(pyridine_ring_pattern)\n    nitro_group = Chem.MolFromSmarts(nitro_group_pattern)\n    halogen = Chem.MolFromSmarts(halogen_pattern)\n    trifluoromethyl = Chem.MolFromSmarts(trifluoromethyl_pattern)\n    amino_group = Chem.MolFromSmarts(amino_group_pattern)\n    alkoxy_group = Chem.MolFromSmarts(alkoxy_group_pattern)\n    aromatic_carboxylic_acid = Chem.MolFromSmarts(aromatic_carboxylic_acid_pattern)\n    \n    # Define the rules, their patterns, and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'Rule 1: Modifiers containing amino groups (\u2013NH\u2082) on flexible aliphatic chains terminating with carboxylic acid groups result in high Fe/Hf values.',\n            'patterns': [primary_aliphatic_amine, carboxylic_acid],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Rule 2: Modifiers with multiple coordinating groups (e.g., amino, thiol, hydroxyl, ether oxygens) on flexible aliphatic chains result in high Fe/Hf values.',\n            'patterns': [carboxylic_acid],\n            'additional_patterns': [primary_aliphatic_amine, secondary_aliphatic_amine, thiol, hydroxyl, ether_oxygen],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Rule 3: Modifiers featuring nitrogen-containing aromatic rings connected via flexible linkers to carboxylic acids result in high Fe/Hf values.',\n            'patterns': [pyridine_ring, carboxylic_acid],\n            'exclude_patterns': [Chem.MolFromSmarts('n1cc(c(=O)O)ccc1')],  # Exclude direct attachments\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Rule 4: Aromatic carboxylic acids with EWGs result in high Fe/Hf values; those with EDGs result in low Fe/Hf values.',\n            'patterns': [aromatic_carboxylic_acid],\n            'e_w_g_patterns': [nitro_group, halogen, trifluoromethyl],\n            'e_d_g_patterns': [amino_group, hydroxyl, alkoxy_group],\n            'prediction_high': 1,\n            'prediction_low': -1\n        },\n        {\n            'number': 5,\n            'description': 'Rule 5: Modifiers lacking additional coordinating groups beyond the carboxylic acid result in low Fe/Hf values.',\n            'patterns': [carboxylic_acid],\n            'exclude_patterns': [primary_aliphatic_amine, secondary_aliphatic_amine, thiol, hydroxyl, ether_oxygen, pyridine_ring],\n            'prediction': -1\n        }\n    ]\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = False\n                # For each rule, check the required patterns\n                if rule['number'] == 1:\n                    # Rule 1: Both primary aliphatic amine and carboxylic acid\n                    if mol.HasSubstructMatch(primary_aliphatic_amine) and mol.HasSubstructMatch(carboxylic_acid):\n                        match = True\n                elif rule['number'] == 2:\n                    # Rule 2: Carboxylic acid and at least one additional coordinating group\n                    if mol.HasSubstructMatch(carboxylic_acid):\n                        for pat in rule['additional_patterns']:\n                            if mol.HasSubstructMatch(pat):\n                                match = True\n                                break\n                elif rule['number'] == 3:\n                    # Rule 3: Pyridine ring and carboxylic acid not directly attached\n                    if mol.HasSubstructMatch(pyridine_ring) and mol.HasSubstructMatch(carboxylic_acid):\n                        # Exclude cases where carboxylic acid is directly attached to pyridine ring\n                        exclude_match = False\n                        for exclude_pat in rule.get('exclude_patterns', []):\n                            if mol.HasSubstructMatch(exclude_pat):\n                                exclude_match = True\n                                break\n                        if not exclude_match:\n                            match = True\n                elif rule['number'] == 4:\n                    # Rule 4: Aromatic carboxylic acid with EWG (High) or EDG (Low)\n                    if mol.HasSubstructMatch(aromatic_carboxylic_acid):\n                        ewg_match = False\n                        edg_match = False\n                        for ewg_pat in rule['e_w_g_patterns']:\n                            if mol.HasSubstructMatch(ewg_pat):\n                                ewg_match = True\n                                break\n                        for edg_pat in rule['e_d_g_patterns']:\n                            if mol.HasSubstructMatch(edg_pat):\n                                edg_match = True\n                                break\n                        if ewg_match:\n                            match = True\n                            row.append(rule['prediction_high'])\n                            continue  # Skip to next rule\n                        elif edg_match:\n                            match = True\n                            row.append(rule['prediction_low'])\n                            continue  # Skip to next rule\n                        else:\n                            match = False\n                    else:\n                        match = False\n                elif rule['number'] == 5:\n                    # Rule 5: Carboxylic acid without additional coordinating groups\n                    if mol.HasSubstructMatch(carboxylic_acid):\n                        exclude_match = False\n                        for exclude_pat in rule['exclude_patterns']:\n                            if mol.HasSubstructMatch(exclude_pat):\n                                exclude_match = True\n                                break\n                        if not exclude_match:\n                            match = True\n                if match:\n                    if 'prediction' in rule:\n                        row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df"
}