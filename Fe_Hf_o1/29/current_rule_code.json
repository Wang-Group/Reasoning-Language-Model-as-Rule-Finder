{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. Each column corresponds to one of the specified rules, and each row corresponds to a SMILES string from the input list. The feature matrix entries are determined based on whether the SMILES matches the structural description of each rule: 1 if it matches and predicts a high Fe/Hf value, -1 if it matches and predicts a low Fe/Hf value, and 0 if it does not match. The code uses SMARTS patterns to identify substructures corresponding to each rule.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "\ndef rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    carboxylate_anion = '[CX3](=O)[O-]'\n    primary_amine = '[NX3H2]'\n    thiol = '[SX2H]'\n    pyridine_ring = '[n]1ccccc1'\n    aromatic_ring = 'c1ccccc1'\n    halogens = '[F,Cl,Br,I]'\n    nitro_group = '[N+](=O)[O-]'\n    aldehyde = '[CX3H1](=O)'\n    hydroxyl_group = '[OX2H]'\n    ether_linkage = '[#6][OX2][#6]'\n    amino_acid_pattern = '[NX3][CX4H]([*])[CX3](=O)[OX2H1]'\n    aliphatic_chain_five = '[C;X4H2][C;X4H2][C;X4H2][C;X4H2][C;X4H2]'\n    aliphatic_chain_seven = '[C;X4H2][C;X4H2][C;X4H2][C;X4H2][C;X4H2][C;X4H2][C;X4H2]'\n    indole_ring = 'c1cc2c(c1)ccc2'\n    multiple_oh = '[OX2H]'\n\n    # Define the rules with their associated patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers containing a terminal amino group (-NH2) on an aliphatic chain of at least five carbons, with a carboxylic acid group (-COOH) at the other end.',\n            'patterns': [\n                [primary_amine],  # Terminal amino group\n                [carboxylic_acid, carboxylate_anion],  # Carboxylic acid group\n            ],\n            'chain_length': 5,\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers that are aromatic carboxylic acids substituted with strong electron-withdrawing groups (EWGs) such as nitro (-NO2) or halogens at the para position.',\n            'patterns': [\n                [aromatic_ring],\n                [carboxylic_acid, carboxylate_anion],  # Carboxylic acid group attached to aromatic ring\n                [halogens, nitro_group],  # EWG at para position\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers containing a thiol group (-SH) attached to an aromatic ring or an aliphatic chain, along with a carboxylic acid group (-COOH).',\n            'patterns': [\n                [thiol],  # Thiol group\n                [carboxylic_acid, carboxylate_anion],  # Carboxylic acid group\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers featuring a pyridine ring connected via a conjugated system to a carboxylic acid group (-COOH).',\n            'patterns': [\n                [pyridine_ring],  # Pyridine ring\n                [carboxylic_acid, carboxylate_anion],  # Carboxylic acid group\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers that are amino acids with hydrophobic side chains containing sulfur atoms.',\n            'patterns': [\n                [amino_acid_pattern],  # Amino acid pattern\n                [thiol],  # Sulfur atom in side chain (thiol)\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers containing multiple ether linkages (-O-) within an aliphatic chain, and possessing a terminal donor group such as amino (-NH2) or methoxy (-OCH3), along with a carboxylic acid group (-COOH).',\n            'patterns': [\n                [ether_linkage],  # Ether linkage\n                [primary_amine, '[OX2][CH3]'],  # Terminal donor group\n                [carboxylic_acid, carboxylate_anion],  # Carboxylic acid group\n            ],\n            'count_threshold': {'[OX2][CX4]': 2},  # At least 2 ether linkages\n            'prediction': 1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers that are aliphatic carboxylic acids with no additional functional groups beyond the carboxylic acid (-COOH).',\n            'patterns': [\n                [carboxylic_acid, carboxylate_anion],  # Carboxylic acid group\n            ],\n            'exclude_patterns': [\n                [primary_amine, thiol, ether_linkage, halogens, aromatic_ring, pyridine_ring, hydroxyl_group],\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers that are aromatic carboxylic acids substituted with electron-donating groups (EDGs) such as hydroxyl (-OH) or amino (-NH2) groups.',\n            'patterns': [\n                [aromatic_ring],\n                [carboxylic_acid, carboxylate_anion],  # Carboxylic acid group attached to aromatic ring\n                [hydroxyl_group, primary_amine],  # EDG on aromatic ring\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers with an aromatic ring connected to an aliphatic chain bearing a hydroxyl group (-OH), along with a carboxylic acid group (-COOH).',\n            'patterns': [\n                [aromatic_ring],\n                [hydroxyl_group],\n                [carboxylic_acid, carboxylate_anion],\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers that are amino acids with bulky side chains containing electron-rich heterocycles, such as indole rings.',\n            'patterns': [\n                [amino_acid_pattern],\n                [indole_ring],\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers containing multiple hydroxyl groups (-OH) on an aliphatic chain, without other strong coordinating groups.',\n            'patterns': [\n                [multiple_oh],\n                [carboxylic_acid, carboxylate_anion],\n            ],\n            'count_threshold': {'[OX2H]': 2},  # At least 2 hydroxyl groups\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers that are aromatic carboxylic acids with an aldehyde group (-CHO) at the para or ortho position.',\n            'patterns': [\n                [aromatic_ring],\n                [carboxylic_acid, carboxylate_anion],\n                [aldehyde],\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers with electron-deficient aromatic heterocycles where the carboxylic acid group (-COOH) is directly attached to the ring.',\n            'patterns': [\n                [pyridine_ring, 'n1cccnc1', 'c1cnc[nH]1'],  # Electron-deficient heterocycles\n                [carboxylic_acid, carboxylate_anion],\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers containing a terminal hydroxyl group (-OH) on an aliphatic chain of seven or more carbons, with a carboxylic acid group (-COOH) at the other end.',\n            'patterns': [\n                [hydroxyl_group],\n                [carboxylic_acid, carboxylate_anion],\n            ],\n            'chain_length': 7,\n            'prediction': 1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers that are cyclic anhydrides or lactones derived from aromatic carboxylic acids, possessing additional carbonyl groups.',\n            'patterns': [\n                ['O=C1OC(=O)c2ccccc12'],  # General pattern for cyclic anhydrides/lactones\n            ],\n            'prediction': 1\n        },\n    ]\n\n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for group in rule.get('patterns', []):\n            compiled_group = [Chem.MolFromSmarts(p) for p in group]\n            compiled_patterns.append(compiled_group)\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for group in rule['exclude_patterns']:\n                compiled_group = [Chem.MolFromSmarts(p) for p in group]\n                compiled_excludes.append(compiled_group)\n            rule['compiled_exclude_patterns'] = compiled_excludes\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for group in rule['compiled_exclude_patterns']:\n                        for pat in group:\n                            if mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                        if not match:\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for compiled_group in rule['compiled_patterns']:\n                    group_match = False\n                    for pat in compiled_group:\n                        matches = mol.GetSubstructMatches(pat)\n                        if matches:\n                            # If a count threshold is specified for this pattern\n                            if 'count_threshold' in rule and pat.GetSmarts() in rule['count_threshold']:\n                                threshold = rule['count_threshold'][pat.GetSmarts()]\n                                if len(matches) >= threshold:\n                                    group_match = True\n                                    break\n                            else:\n                                group_match = True\n                                break\n                    if not group_match:\n                        match = False\n                        break\n                # Additional checks for chain length if specified\n                if match and 'chain_length' in rule:\n                    chain_length = rule['chain_length']\n                    # Find indices of functional groups\n                    fg1_pattern = Chem.MolFromSmarts(rule['compiled_patterns'][0][0].GetSmarts())\n                    fg2_pattern = Chem.MolFromSmarts(rule['compiled_patterns'][1][0].GetSmarts())\n                    fg1_matches = mol.GetSubstructMatches(fg1_pattern)\n                    fg2_matches = mol.GetSubstructMatches(fg2_pattern)\n                    path_match = False\n                    for fg1 in fg1_matches:\n                        for fg2 in fg2_matches:\n                            path = Chem.rdmolops.GetShortestPath(mol, fg1[0], fg2[0])\n                            num_carbons = sum(1 for idx in path if mol.GetAtomWithIdx(idx).GetAtomicNum() == 6)\n                            if num_carbons >= chain_length:\n                                path_match = True\n                                break\n                        if path_match:\n                            break\n                    if not path_match:\n                        match = False\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}