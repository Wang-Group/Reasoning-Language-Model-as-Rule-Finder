{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit. It processes each molecule according to a set of rules defined based on structural features, and outputs a DataFrame where each column corresponds to a rule, and each value indicates whether the rule applies to the molecule (1 for high Fe/Hf value, -1 for low Fe/Hf value, 0 otherwise).",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid_patterns = ['[CX3](=O)[OX2H1]', '[CX3](=O)[O-]']\n\n    # Primary aliphatic amine group (-NH2)\n    primary_aliph_amine_pattern = '[NX3H2,NX4H3+;!$([N][!C])]'\n\n    # Secondary aliphatic amine group (-NHR)\n    secondary_aliph_amine_pattern = '[NX3H1,NX4H2+;!$([N][!C])]([C])'\n\n    # Aromatic carboxylic acid\n    aromatic_carboxylic_acid_pattern = '[c][CX3](=O)[OX2H1]'\n\n    # Nitro group on aromatic ring\n    nitro_group_on_aromatic_pattern = '[c][N+](=O)[O-]'\n\n    # Halogen on aromatic ring\n    halogen_on_aromatic_pattern = '[c][F,Cl,Br,I]'\n\n    # Thiol group (-SH)\n    thiol_pattern = '[SX2H]'\n\n    # Thioether group (-S-)\n    thioether_pattern = '[SX2;!$(S=[O,N])]([#6])[#6]'\n\n    # Pyridine ring\n    pyridine_ring_pattern = 'n1ccccc1'\n\n    # Ether linkage (-O-) in aliphatic chain\n    ether_linkage_pattern = '[CX4][OX2][CX4]'\n\n    # Hydroxyl group (-OH)\n    hydroxyl_group_pattern = '[OX2H]'\n\n    # Aromatic hydroxyl group (-OH on aromatic ring)\n    aromatic_hydroxyl_pattern = '[c][OX2H]'\n\n    # Aromatic amino group (-NH2 on aromatic ring)\n    aromatic_amino_pattern = '[c][NX3H2]'\n\n    # Exclude patterns for Rule 6\n    exclude_amines_pattern = '[NX3]'\n    exclude_sulfur_groups_pattern = '[SX2]'\n    exclude_ethers_pattern = '[OX2;!$([OX2][CX3](=O)[OX1H1])]'  # Exclude ether linkages not in carboxylic acid\n\n    # Define the rules\n    rules = [\n        {\n            'number': 1,\n            'description': 'High Fe/Hf Value (True): Modifiers containing nitrogen-based functional groups (e.g., amino groups), especially attached to aliphatic chains.',\n            'patterns': [\n                carboxylic_acid_patterns,\n                [primary_aliph_amine_pattern, secondary_aliph_amine_pattern]\n            ],\n            'exclude_patterns': [\n                '[c][NX3]',  # Exclude aromatic amine\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'High Fe/Hf Value (True): Modifiers that are aromatic carboxylic acids with strong electron-withdrawing groups (EWGs), such as nitro (-NO2) or halogens.',\n            'patterns': [\n                [aromatic_carboxylic_acid_pattern],\n                [nitro_group_on_aromatic_pattern, halogen_on_aromatic_pattern]\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'High Fe/Hf Value (True): Modifiers containing sulfur-functional groups (thiol (-SH) or thioether (-S-)), especially when combined with carboxyl groups.',\n            'patterns': [\n                carboxylic_acid_patterns,\n                [thiol_pattern, thioether_pattern]\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'High Fe/Hf Value (True): Modifiers containing pyridine rings or other nitrogen-containing heterocycles, especially when combined with carboxyl groups.',\n            'patterns': [\n                carboxylic_acid_patterns,\n                [pyridine_ring_pattern]\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'High Fe/Hf Value (True): Modifiers containing polyether chains with multiple ether linkages (-O-) and carboxyl groups.',\n            'patterns': [\n                carboxylic_acid_patterns,\n                [ether_linkage_pattern]\n            ],\n            'count_threshold': {ether_linkage_pattern: 2},  # Require at least 2 ether linkages\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Low Fe/Hf Value (False): Modifiers that are aliphatic carboxylic acids without additional coordinating functional groups.',\n            'patterns': [\n                carboxylic_acid_patterns\n            ],\n            'exclude_patterns': [\n                exclude_amines_pattern,\n                exclude_sulfur_groups_pattern,\n                exclude_ethers_pattern,\n                '[OX2H]'   # Exclude hydroxyl groups\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Low Fe/Hf Value (False): Modifiers that are aromatic carboxylic acids with electron-donating groups (EDGs) such as hydroxyl (-OH) or amino (-NH2) groups directly attached to the ring.',\n            'patterns': [\n                [aromatic_carboxylic_acid_pattern],\n                [aromatic_hydroxyl_pattern, aromatic_amino_pattern]\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Low Fe/Hf Value (False): Modifiers containing multiple hydroxyl groups (-OH) on aliphatic chains.',\n            'patterns': [\n                carboxylic_acid_patterns,\n                [hydroxyl_group_pattern]\n            ],\n            'count_threshold': {hydroxyl_group_pattern: 2},\n            'prediction': -1\n        }\n        # ... Additional rules can be added here\n    ]\n\n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for group in rule['patterns']:\n            compiled_group = [Chem.MolFromSmarts(p) for p in group]\n            compiled_patterns.append(compiled_group)\n        rule['compiled_patterns'] = compiled_patterns\n\n        if 'exclude_patterns' in rule:\n            compiled_exclude_patterns = [Chem.MolFromSmarts(p) for p in rule['exclude_patterns']]\n            rule['compiled_exclude_patterns'] = compiled_exclude_patterns\n\n    # Process the SMILES list\n    results = []\n    for smiles in smiles_list:\n        mol = Chem.MolFromSmiles(smiles)\n        if mol is None:\n            # If molecule can't be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns\n                if 'compiled_exclude_patterns' in rule:\n                    for pat in rule['compiled_exclude_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for compiled_group in rule['compiled_patterns']:\n                    group_match = False\n                    for pat in compiled_group:\n                        matches = mol.GetSubstructMatches(pat)\n                        if matches:\n                            # If a count threshold is specified for this pattern\n                            if 'count_threshold' in rule and pat.GetSmarts() in rule['count_threshold']:\n                                threshold = rule['count_threshold'][pat.GetSmarts()]\n                                if len(matches) >= threshold:\n                                    group_match = True\n                                    break\n                            else:\n                                group_match = True\n                                break\n                    if not group_match:\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}