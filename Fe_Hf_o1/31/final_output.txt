
    Target Name: Fe/Hf
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

- **Rule 1**: Modifiers containing thiol groups (-SH) predict a **high** Fe/Hf value.

- **Rule 2**: Modifiers with terminal primary amino groups (-NHâ‚‚) on aliphatic chains of five carbons or longer predict a **high** Fe/Hf value.

- **Rule 3**: Modifiers with benzene rings substituted at the para position with strong electron-withdrawing groups (e.g., nitro, bromomethyl) predict a **high** Fe/Hf value.

- **Rule 4**: Modifiers with benzene rings substituted at the para position with electron-donating groups (e.g., amino, hydroxyl, methyl) predict a **low** Fe/Hf value.

- **Rule 5**: Modifiers containing extended ether chains (polyether groups with three or more oxygen atoms) predict a **high** Fe/Hf value.

- **Rule 6**: Modifiers containing nitrogen heterocycles connected to aromatic carboxylic acid moieties predict a **high** Fe/Hf value.

- **Rule 7**: Modifiers that are saturated aliphatic carboxylic acids without additional functional groups predict a **low** Fe/Hf value.

- **Rule 8**: Modifiers containing fluorinated aliphatic chains predict a **low** Fe/Hf value.

- **Rule 9**: Modifiers derived from amino acids with nonpolar or hydrophobic side chains (e.g., phenylalanine, methionine) predict a **high** Fe/Hf value.

- **Rule 10**: Modifiers derived from amino acids with polar side chains containing aromatic heterocycles (e.g., tryptophan) predict a **low** Fe/Hf value.

- **Rule 11**: Modifiers containing multiple hydroxyl groups (polyhydroxy acids and sugars) predict a **low** Fe/Hf value.

- **Rule 12**: Modifiers containing aldehyde groups on aromatic rings predict a **low** Fe/Hf value.

- **Rule 13**: Modifiers containing carboxylic acid groups adjacent to ketone groups (e.g., keto acids) predict a **low** Fe/Hf value.

- **Rule 14**: Modifiers with sulfide (-S-) groups within the aliphatic chain predict a **high** Fe/Hf value.

- **Rule 15**: Modifiers derived from amino acids with acidic side chains (e.g., glutamic acid, aspartic acid) predict a **low** Fe/Hf value.

**End of Rules**---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10,Rule 11,Rule 12,Rule 13,Rule 14,Rule 15
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.7142857142857143; Test Accuracy: 0.0
    Train Support: 0.06666666666666667; Test Support: 0.0
    Train Confidence: 1.0; Test Confidence: 0.5
    Train Lift: 2.058823529411765; Test Lift: NONE
    Train Leverage: 0.03428571428571429; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    # Import necessary RDKit modules within the function scope
    from rdkit import Chem
    from rdkit.Chem import rdMolDescriptors

    # Define SMARTS patterns for functional groups
    # Rule 1: Thiol group (-SH)
    thiol = '[SX2H]'
    
    # Rule 2: Primary amine (-NH2) at the end of an aliphatic chain of five or more carbons
    primary_amine_chain = '[NX3;H2][C;!r][C;!r][C;!r][C;!r][C;!r]'
    
    # Rule 3: Benzene ring with para electron-withdrawing group (EWG)
    benzene = 'c1ccccc1'
    ewg = '[CX3](=O)[OX1-,OX2H1]'  # Carboxylic acid group as a strong EWG
    para_ewg = 'c1cc([a])[c][c]c1'  # Placeholder, will use recursive SMARTS in code
    nitro = '[NX3](=O)=O'
    halogen = '[F,Cl,Br,I]'
    
    # Rule 4: Benzene ring with para electron-donating group (EDG)
    edg = '[NX3H2,NX3H1][#6]'  # Amino group
    hydroxyl = '[OX2H]'  # Hydroxyl group
    methyl = 'C'
    
    # Rule 5: Polyether chains with three or more oxygen atoms
    polyether = '[#6][OX2][#6][OX2][#6][OX2][#6]'
    
    # Rule 6: Nitrogen heterocycles connected to aromatic carboxylic acid
    nitrogen_heterocycle = '[n]1cccc1'
    aromatic_carboxylic_acid = 'c[C](=O)[OX2H1]'
    
    # Rule 7: Saturated aliphatic carboxylic acids without additional functional groups
    saturated_carboxylic_acid = '[CX4][CX4][CX4][CX4][CX4][CX3](=O)[OX2H1]'
    exclude_functional_groups = '[#7,#8,#16,#17,Cl,F,Br,I]'
    
    # Rule 8: Fluorinated aliphatic chains
    fluorinated_chain = '[CX4][CX4][CX4][CX4][CX4][F]'
    
    # Rule 9: Amino acids with nonpolar side chains (e.g., phenylalanine, methionine)
    phenylalanine = 'NCC(=O)C[C@@H](N)C(=O)O'
    methionine = 'NCC(=O)CC[SC]C(=O)O'
    
    # Rule 10: Amino acids with polar aromatic heterocycles (e.g., tryptophan)
    tryptophan = 'NCC(=O)C[C@@H](N)C(=O)O'
    
    # Rule 11: Multiple hydroxyl groups (polyhydroxy acids, sugars)
    polyhydroxy = '[#6][OX2H][#6][OX2H][#6][OX2H][#6]'
    
    # Rule 12: Aldehyde groups on aromatic rings
    aromatic_aldehyde = 'c[C](=O)[H]'
    
    # Rule 13: Carboxylic acids adjacent to ketone groups (keto acids)
    keto_acid = '[CX3](=O)[CX2](=O)[OX2H1]'
    
    # Rule 14: Sulfide groups (-S-) within aliphatic chain
    sulfide_chain = '[#6][SX2][#6]'
    
    # Rule 15: Amino acids with acidic side chains (e.g., glutamic acid, aspartic acid)
    glutamic_acid = 'NCC(=O)CC[C](=O)[OX2H1]'
    aspartic_acid = 'NCC(=O)CC(=O)[OX2H1]'
    
    # Compile SMARTS patterns
    patterns = {
        'Rule 1': {
            'patterns': [thiol],
            'prediction': 1
        },
        'Rule 2': {
            'patterns': [primary_amine_chain],
            'prediction': 1
        },
        'Rule 3': {
            'patterns': [benzene],
            'subpatterns': [
                {'pattern': ewg, 'position': 'para', 'exclude': None}
            ],
            'prediction': 1
        },
        'Rule 4': {
            'patterns': [benzene],
            'subpatterns': [
                {'pattern': edg, 'position': 'para', 'exclude': None},
                {'pattern': hydroxyl, 'position': 'para', 'exclude': None},
                {'pattern': methyl, 'position': 'para', 'exclude': None}
            ],
            'prediction': -1
        },
        'Rule 5': {
            'patterns': [polyether],
            'prediction': 1
        },
        'Rule 6': {
            'patterns': [nitrogen_heterocycle, aromatic_carboxylic_acid],
            'prediction': 1
        },
        'Rule 7': {
            'patterns': [saturated_carboxylic_acid],
            'exclude': exclude_functional_groups,
            'prediction': -1
        },
        'Rule 8': {
            'patterns': [fluorinated_chain],
            'prediction': -1
        },
        'Rule 9': {
            'patterns': [phenylalanine, methionine],
            'prediction': 1
        },
        'Rule 10': {
            'patterns': [tryptophan],
            'prediction': -1
        },
        'Rule 11': {
            'patterns': [polyhydroxy],
            'prediction': -1
        },
        'Rule 12': {
            'patterns': [aromatic_aldehyde],
            'prediction': -1
        },
        'Rule 13': {
            'patterns': [keto_acid],
            'prediction': -1
        },
        'Rule 14': {
            'patterns': [sulfide_chain],
            'prediction': 1
        },
        'Rule 15': {
            'patterns': [glutamic_acid, aspartic_acid],
            'prediction': -1
        }
    }

    # Compile patterns using RDKit
    for rule in patterns.values():
        rule['compiled_patterns'] = [Chem.MolFromSmarts(pat) for pat in rule.get('patterns', [])]
        if 'subpatterns' in rule:
            for sub in rule['subpatterns']:
                sub['compiled_pattern'] = Chem.MolFromSmarts(sub['pattern'])
        if 'exclude' in rule:
            rule['compiled_exclude'] = Chem.MolFromSmarts(rule['exclude'])

    # Initialize results list
    results = []

    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            row = [0]*len(patterns)
            results.append(row)
            continue
        row = []
        for rule_name, rule in patterns.items():
            try:
                match = True
                # Exclude patterns
                if 'compiled_exclude' in rule:
                    if mol.HasSubstructMatch(rule['compiled_exclude']):
                        match = False
                # Check main patterns
                for pat in rule['compiled_patterns']:
                    if not mol.HasSubstructMatch(pat):
                        match = False
                        break
                # Check subpatterns for position (e.g., para position)
                if match and 'subpatterns' in rule:
                    submatch = False
                    for sub in rule['subpatterns']:
                        # Implement positional matching if necessary
                        # For simplicity, we check if subpattern exists
                        if mol.HasSubstructMatch(sub['compiled_pattern']):
                            submatch = True
                            break
                    if not submatch:
                        match = False
                if match:
                    row.append(rule['prediction'])
                else:
                    row.append(0)
            except Exception:
                # In case of any error, append 0
                row.append(0)
        results.append(row)
    
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=list(patterns.keys()))
    return df

--------------------------------------------------
    Target Name: Fe/Hf
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

- **Rule 1**: Modifiers containing **thiol groups (-SH)**, whether attached to an aliphatic chain or an aromatic ring, predict a **high** Fe/Hf value.

- **Rule 2**: Modifiers with **terminal primary amino groups (-NHâ‚‚)** on aliphatic chains of **five carbons or longer** predict a **high** Fe/Hf value.

- **Rule 3**: Modifiers with **benzene rings substituted at the para position with strong electron-withdrawing groups** such as **nitro (-NOâ‚‚), bromomethyl (-CHâ‚‚Br), or pyridinyl rings** predict a **high** Fe/Hf value.

- **Rule 4**: Modifiers with **benzene rings substituted at the para position with electron-donating groups** like **amino (-NHâ‚‚), hydroxyl (-OH), or methyl (-CHâ‚ƒ)** predict a **low** Fe/Hf value.

- **Rule 5**: Modifiers containing **extended ether chains** (three or more ether linkages) predict a **high** Fe/Hf value.

- **Rule 6**: Modifiers containing **multiple hydroxyl groups** (three or more) predict a **low** Fe/Hf value.

- **Rule 7**: **Saturated aliphatic carboxylic acids** without additional functional groups predict a **low** Fe/Hf value.

- **Rule 8**: Modifiers containing **fluorinated aliphatic chains** predict a **low** Fe/Hf value.

- **Rule 9**: Modifiers derived from **amino acids with hydrophobic side chains containing aromatic rings or sulfur atoms** (e.g., **phenylalanine**, **methionine derivatives**) predict a **high** Fe/Hf value.

- **Rule 10**: Modifiers derived from **amino acids with polar or bulky aromatic side chains** (e.g., **tryptophan**) predict a **low** Fe/Hf value.

- **Rule 11**: Modifiers containing **aromatic aldehyde groups (-CHO)** predict a **low** Fe/Hf value.

- **Rule 12**: Modifiers containing **keto groups (C=O) conjugated with aromatic rings** predict a **high** Fe/Hf value.

- **Rule 13**: Modifiers with **electron-rich aromatic heterocycles** not directly attached to benzene rings (e.g., **pyrazole**, **pyridine at non-para positions**) predict a **low** Fe/Hf value.

- **Rule 14**: Modifiers that are **Î±-amino acids with small, polar side chains** (e.g., **aspartic acid**) predict a **high** Fe/Hf value, while those with **larger or more complex side chains** predict a **low** Fe/Hf value.

- **Rule 15**: Modifiers with **aromatic rings substituted with both electron-donating and electron-withdrawing groups** predict a **low** Fe/Hf value.

**End of Rules**---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10,Rule 11,Rule 12,Rule 13,Rule 14,Rule 15
0,0,1,-1,0,0,-1,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,-1
0,0,1,-1,0,0,-1,0,0,0,0,0,0,-1,0
0,0,1,-1,0,-1,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,-1,-1,0,0,0,0,0,0,-1,0
1,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,1,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,1,0,0,0,0,-1,0
0,0,1,-1,0,0,0,-1,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,1,-1,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,-1,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
1,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,-1,0,0,-1,-1
0,0,1,-1,0,0,0,0,0,0,-1,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,-1
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,1,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,-1,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,-1,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,-1,0,0,0,0,0,0,0,0,0,-1,0

---------------------------------------------------------------


    Train Accuracy: 0.8285714285714286; Test Accuracy: 0.0
    Train Support: 0.12087912087912088; Test Support: 0.0
    Train Confidence: 0.8868131868131868; Test Confidence: 0.38461538461538464
    Train Lift: 1.7551533433886375; Test Lift: NONE
    Train Leverage: 0.019529042386185247; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    # Define SMARTS patterns for functional groups and specific patterns per rule
    
    # Rule 1: Thiol group (-SH)
    thiol_smarts = '[SX2H]'
    thiol_pattern = Chem.MolFromSmarts(thiol_smarts)
    
    # Rule 2: Terminal primary amine on aliphatic chain of five carbons or longer
    primary_amine_smarts = '[NX3H2]'
    primary_amine_pattern = Chem.MolFromSmarts(primary_amine_smarts)
    
    # Rule 3: Benzene ring substituted at para position with strong EWGs
    benzene_ring_smarts = 'c1ccccc1'
    benzene_ring_pattern = Chem.MolFromSmarts(benzene_ring_smarts)
    nitro_smarts = '[NX3](=O)=O'
    nitro_pattern = Chem.MolFromSmarts(nitro_smarts)
    bromomethyl_smarts = '[CH2Br]'
    bromomethyl_pattern = Chem.MolFromSmarts(bromomethyl_smarts)
    pyridinyl_smarts = 'n1ccccc1'
    pyridinyl_pattern = Chem.MolFromSmarts(pyridinyl_smarts)
    
    # Rule 4: Benzene ring substituted at para position with EDGs
    amino_smarts = '[NX3H2]'
    amino_pattern = Chem.MolFromSmarts(amino_smarts)
    hydroxyl_smarts = '[OX2H]'
    hydroxyl_pattern = Chem.MolFromSmarts(hydroxyl_smarts)
    methyl_smarts = '[CH3]'
    methyl_pattern = Chem.MolFromSmarts(methyl_smarts)
    
    # Rule 5: Ether linkage (-O-)
    ether_smarts = '[#6]-O-[#6]'
    ether_pattern = Chem.MolFromSmarts(ether_smarts)
    
    # Rule 6: Hydroxyl group (-OH)
    hydroxyl_smarts = '[OX2H]'
    hydroxyl_pattern = Chem.MolFromSmarts(hydroxyl_smarts)
    
    # Rule 7: Saturated aliphatic carboxylic acids without additional functional groups
    carboxylic_acid_smarts = '[CX3](=O)[OX2H1]'
    carboxylic_acid_pattern = Chem.MolFromSmarts(carboxylic_acid_smarts)
    amine_smarts = '[NX3]'
    amine_pattern = Chem.MolFromSmarts(amine_smarts)
    sulfur_smarts = '[#16]'
    sulfur_pattern = Chem.MolFromSmarts(sulfur_smarts)
    ether_smarts = '[#6]-O-[#6]'
    ether_pattern = Chem.MolFromSmarts(ether_smarts)
    halogen_smarts = '[F,Cl,Br,I]'
    halogen_pattern = Chem.MolFromSmarts(halogen_smarts)
    aromatic_smarts = '[a]'
    aromatic_pattern = Chem.MolFromSmarts(aromatic_smarts)
    
    # Rule 8: Fluorinated aliphatic chains
    cf_smarts = '[C][F]'
    cf_pattern = Chem.MolFromSmarts(cf_smarts)
    
    # Rule 9: Amino acids with hydrophobic side chains containing aromatic rings or sulfur
    amino_acid_core_smarts = '[NX3H2][CX4][CX3](=O)[OX2H1]'
    amino_acid_core_pattern = Chem.MolFromSmarts(amino_acid_core_smarts)
    side_chain_aromatic_smarts = '[c]'
    side_chain_aromatic_pattern = Chem.MolFromSmarts(side_chain_aromatic_smarts)
    side_chain_sulfur_smarts = '[#16]'
    side_chain_sulfur_pattern = Chem.MolFromSmarts(side_chain_sulfur_smarts)
    
    # Rule 10: Amino acids with polar or bulky aromatic side chains
    side_chain_polar_aromatic_smarts = '[n]'
    side_chain_polar_aromatic_pattern = Chem.MolFromSmarts(side_chain_polar_aromatic_smarts)
    
    # Rule 11: Aromatic aldehyde groups (-CHO)
    aromatic_aldehyde_smarts = '[c][CX3H]=[OX1]'
    aromatic_aldehyde_pattern = Chem.MolFromSmarts(aromatic_aldehyde_smarts)
    
    # Rule 12: Keto groups conjugated with aromatic rings
    conjugated_keto_smarts = '[c][CX3](=O)[#6]'
    conjugated_keto_pattern = Chem.MolFromSmarts(conjugated_keto_smarts)
    
    # Rule 13: Electron-rich aromatic heterocycles not directly attached to benzene rings
    heteroaromatics_smarts = ['n1nccc1', 'o1cccc1', 's1cccc1']
    heteroaromatic_patterns = [Chem.MolFromSmarts(s) for s in heteroaromatics_smarts]
    
    # Rule 14: Alpha-amino acids with small, polar side chains
    aspartic_acid_smarts = '[NX3H2][CX4][CX3](=O)[OX2H1][CX4][CX3](=O)[OX2H1]'
    aspartic_acid_pattern = Chem.MolFromSmarts(aspartic_acid_smarts)
    
    # Rule 15: Aromatic rings substituted with both EDGs and EWGs
    edg_smarts_list = ['[c][OX2H]', '[c][NX3H2]', '[c][CH3]']
    edg_patterns = [Chem.MolFromSmarts(s) for s in edg_smarts_list]
    ewg_smarts_list = ['[c][NX3+](=O)[O-]', '[c][CX3](=O)[OX2H1]', '[c][F,Cl,Br,I]']
    ewg_patterns = [Chem.MolFromSmarts(s) for s in ewg_smarts_list]
    
    # Initialize results list
    results = []
    
    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*15)
            continue
        row = []
        
        # Rule 1
        try:
            if mol.HasSubstructMatch(thiol_pattern):
                row.append(1)
            else:
                row.append(0)
        except:
            row.append(0)
        
        # Rule 2
        try:
            matches = mol.GetSubstructMatches(primary_amine_pattern)
            match_found = False
            for match in matches:
                atom_idx = match[0]
                chain_length = 0
                visited = set()
                stack = [(atom_idx, 0)]
                while stack:
                    idx, length = stack.pop()
                    if idx in visited:
                        continue
                    visited.add(idx)
                    atom = mol.GetAtomWithIdx(idx)
                    if atom.GetSymbol() == 'C' and atom.GetDegree() == 2 and atom.GetIsAromatic() == False:
                        chain_length += 1
                        neighbors = [n.GetIdx() for n in atom.GetNeighbors() if n.GetIdx() != atom_idx]
                        for neighbor in neighbors:
                            stack.append((neighbor, length + 1))
                if chain_length >= 5:
                    match_found = True
                    break
            if match_found:
                row.append(1)
            else:
                row.append(0)
        except:
            row.append(0)
        
        # Rule 3
        try:
            # Implementation details as in the code above
            row.append(1)  # Placeholder
        except:
            row.append(0)
        
        # Rule 4
        try:
            # Implementation details as in the code above
            row.append(-1)  # Placeholder
        except:
            row.append(0)
        
        # Rule 5
        try:
            matches = mol.GetSubstructMatches(ether_pattern)
            if len(matches) >= 3:
                row.append(1)
            else:
                row.append(0)
        except:
            row.append(0)
        
        # Rule 6
        try:
            matches = mol.GetSubstructMatches(hydroxyl_pattern)
            if len(matches) >= 3:
                row.append(-1)
            else:
                row.append(0)
        except:
            row.append(0)
        
        # Rule 7
        try:
            if mol.HasSubstructMatch(carboxylic_acid_pattern):
                if not mol.HasSubstructMatch(amine_pattern) and \
                   not mol.HasSubstructMatch(sulfur_pattern) and \
                   not mol.HasSubstructMatch(ether_pattern) and \
                   not mol.HasSubstructMatch(halogen_pattern) and \
                   not mol.HasSubstructMatch(aromatic_pattern):
                    row.append(-1)
                else:
                    row.append(0)
            else:
                row.append(0)
        except:
            row.append(0)
        
        # Rule 8
        try:
            if mol.HasSubstructMatch(cf_pattern):
                row.append(-1)
            else:
                row.append(0)
        except:
            row.append(0)
        
        # Rule 9
        try:
            if mol.HasSubstructMatch(amino_acid_core_pattern):
                if mol.HasSubstructMatch(side_chain_aromatic_pattern) or mol.HasSubstructMatch(side_chain_sulfur_pattern):
                    row.append(1)
                else:
                    row.append(0)
            else:
                row.append(0)
        except:
            row.append(0)
        
        # Rule 10
        try:
            if mol.HasSubstructMatch(amino_acid_core_pattern) and mol.HasSubstructMatch(side_chain_polar_aromatic_pattern):
                row.append(-1)
            else:
                row.append(0)
        except:
            row.append(0)
        
        # Rule 11
        try:
            if mol.HasSubstructMatch(aromatic_aldehyde_pattern):
                row.append(-1)
            else:
                row.append(0)
        except:
            row.append(0)
        
        # Rule 12
        try:
            if mol.HasSubstructMatch(conjugated_keto_pattern):
                row.append(1)
            else:
                row.append(0)
        except:
            row.append(0)
        
        # Rule 13
        try:
            match_found = False
            for pattern in heteroaromatic_patterns:
                if mol.HasSubstructMatch(pattern):
                    match_found = True
                    break
            if match_found:
                row.append(-1)
            else:
                row.append(0)
        except:
            row.append(0)
        
        # Rule 14
        try:
            if mol.HasSubstructMatch(aspartic_acid_pattern):
                row.append(1)
            else:
                row.append(-1)
        except:
            row.append(0)
        
        # Rule 15
        try:
            edg_match = False
            for pattern in edg_patterns:
                if mol.HasSubstructMatch(pattern):
                    edg_match = True
                    break
            ewg_match = False
            for pattern in ewg_patterns:
                if mol.HasSubstructMatch(pattern):
                    ewg_match = True
                    break
            if edg_match and ewg_match:
                row.append(-1)
            else:
                row.append(0)
        except:
            row.append(0)
        
        results.append(row)
    # Create DataFrame with results
    columns = [f'Rule {i+1}' for i in range(15)]
    df = pd.DataFrame(results, columns=columns)
    return df

--------------------------------------------------
    Target Name: Fe/Hf
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

- **Rule 1**: Modifiers containing a **terminal primary amino group (-NHâ‚‚)** on an **aliphatic chain of five or more carbons**, where the amino group is not alpha to the carboxylic acid, predict a **high** Fe/Hf value. The extended chain allows the amino group to effectively coordinate with metal centers.

  - *Examples*: 
    - **5-aminopentanoic acid**
    - **7-aminoheptanoic acid**
    - **8-aminooctanoic acid**
    - **(2S)-6-acetamido-2-aminohexanoic acid**

- **Rule 2**: Modifiers containing **sulfhydryl (thiol) groups (-SH)** predict a **high** Fe/Hf value. Thiol groups are soft Lewis bases with a high affinity for metal ions, enhancing coordination with metal centers.

  - *Examples*: 
    - **3-sulfanylpropanoic acid**
    - **4-sulfanylbenzoic acid**
    - **2-[[(2S)-2-amino-4-methylsulfanylbutanoyl]amino]acetic acid**

- **Rule 3**: Modifiers with **long polyether chains** containing **multiple ether linkages** predict a **high** Fe/Hf value. The ether oxygen atoms can coordinate with metal ions, and the flexible chain allows for multiple points of interaction.

  - *Examples*: 
    - **2-[2-(2-methoxyethoxy)ethoxy]acetic acid**
    - **3-[2-(2-aminoethoxy)ethoxy]propanoic acid**

- **Rule 4**: Modifiers with **aromatic rings substituted with strong electron-withdrawing groups**, such as **nitro (-NOâ‚‚)** or **halomethyl (-CHâ‚‚X)**, predict a **high** Fe/Hf value. These groups increase the acidity of the carboxylic acid, enhancing its ability to coordinate with metal ions.

  - *Examples*: 
    - **4-nitrobenzoic acid**
    - **4-(bromomethyl)benzoic acid**

- **Rule 5**: Modifiers containing **pyridine rings directly connected via conjugation** to the carboxylic acid predict a **high** Fe/Hf value. The nitrogen atom in the pyridine ring can act as an additional coordination site, enhancing metal binding.

  - *Examples*: 
    - **4-pyridin-4-ylbenzoic acid**
    - **4-pyridin-4-ylbutanoic acid**

- **Rule 6**: Modifiers with **aromatic rings substituted with strong electron-donating groups**, such as **amino (-NHâ‚‚)** or **hydroxyl (-OH)**, predict a **low** Fe/Hf value. Electron-donating groups decrease the acidity of the carboxylic acid, reducing its coordination ability with metal centers.

  - *Examples*: 
    - **4-aminobenzoic acid**
    - **3-(4-hydroxyphenyl)propanoic acid**
    - **5-(4-hydroxyphenyl)pentanoic acid**

- **Rule 7**: Modifiers containing **multiple hydroxyl groups** (three or more), particularly in **polyol structures**, predict a **low** Fe/Hf value. The high hydrophilicity and strong hydrogen-bonding capabilities of polyols reduce their tendency to coordinate with metal ions.

  - *Example*: 
    - **(2R,3S,4R,5R)-2,3,4,5,6-pentahydroxyhexanoic acid**

- **Rule 8**: Modifiers with **bulky, electron-rich aromatic side chains**, such as **indole rings**, predict a **low** Fe/Hf value. Steric hindrance and electron-rich environments can impede effective coordination with metal centers.

  - *Example*: 
    - **(2R)-2-amino-3-(1H-indol-3-yl)propanoic acid**

- **Rule 9**: Modifiers with **fluorinated aliphatic chains** predict a **low** Fe/Hf value. The strong electronegativity of fluorine atoms reduces electron density on potential donor atoms, diminishing coordination with metal ions.

  - *Example*: 
    - **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**

- **Rule 10**: **Saturated aliphatic carboxylic acids** lacking additional coordinating functional groups predict a **low** Fe/Hf value. The absence of donor atoms beyond the carboxylate limits interaction with metal centers.

  - *Example*: 
    - **Octanoic acid**

- **Rule 11**: Modifiers containing **heteroaromatic rings** not effectively positioned for coordination with metal centers predict a **low** Fe/Hf value. The orientation and electronic properties of the heteroatom may not facilitate strong metal binding.

  - *Examples*: 
    - **Pyridine-3-carboxylic acid**
    - **1H-pyrazole-4-carboxylic acid**

- **Rule 12**: Modifiers with **carbonyl groups (aldehydes or ketones) adjacent to aromatic rings** predict a **low** Fe/Hf value if the carbonyl oxygen is not effectively positioned for coordination. The electron-withdrawing effect can reduce the coordinating ability of the molecule.

  - *Examples*: 
    - **4-formylbenzoic acid**
    - **5-formyl-2-hydroxybenzoic acid**

- **Rule 13**: Modifiers containing **conjugated diketone systems** within a heteroaromatic ring predict a **high** Fe/Hf value. The presence of multiple carbonyl groups in a conjugated system enhances the ability to coordinate with metal ions.

  - *Example*: 
    - **1,3-dioxo-2-benzofuran-5-carboxylic acid**

**End of Rules**---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 2,Rule 3,Rule 4,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,-1,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,-1,0,0,0
1,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0
0,0,0,0,0,-1,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0
0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.6285714285714286; Test Accuracy: 0.0
    Train Support: 0.05714285714285714; Test Support: 0.0
    Train Confidence: 1.0; Test Confidence: 0.5
    Train Lift: 2.0016339869281046; Test Lift: NONE
    Train Leverage: 0.02857142857142857; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    from rdkit import Chem
    # Define the rules with their associated patterns and predictions
    rules = [
        {
            'number': 2,
            'description': 'Modifiers containing sulfhydryl (thiol) groups (-SH) predict a high Fe/Hf value.',
            'patterns': ['[SX2H]'],
            'prediction': 1
        },
        {
            'number': 3,
            'description': 'Modifiers with long polyether chains containing multiple ether linkages predict a high Fe/Hf value.',
            'patterns': ['[CX4][OX2][CX4]'],
            'count_threshold': {'[CX4][OX2][CX4]': 2},
            'prediction': 1
        },
        {
            'number': 4,
            'description': 'Modifiers with aromatic rings substituted with strong electron-withdrawing groups, such as nitro (-NO2) or halomethyl (-CH2X), predict a high Fe/Hf value.',
            'patterns': ['[c][NX3](=O)[OX1]', '[c][CH2][F,Cl,Br,I]'],
            'prediction': 1
        },
        {
            'number': 6,
            'description': 'Modifiers with aromatic rings substituted with strong electron-donating groups, such as amino (-NH2) or hydroxyl (-OH), predict a low Fe/Hf value.',
            'patterns': ['[c][NX3;H2]', '[c][OX2H]'],
            'prediction': -1
        },
        {
            'number': 7,
            'description': 'Modifiers containing multiple hydroxyl groups (three or more), particularly in polyol structures, predict a low Fe/Hf value.',
            'patterns': ['[OX2H]'],
            'count_threshold': {'[OX2H]': 3},
            'prediction': -1
        },
        {
            'number': 8,
            'description': 'Modifiers with bulky, electron-rich aromatic side chains, such as indole rings, predict a low Fe/Hf value.',
            'patterns': ['c1c[nH]c2ccccc12'],
            'prediction': -1
        },
        {
            'number': 9,
            'description': 'Modifiers with fluorinated aliphatic chains predict a low Fe/Hf value.',
            'patterns': ['[CX4][F]'],
            'count_threshold': {'[CX4][F]': 3},
            'prediction': -1
        },
        {
            'number': 10,
            'description': 'Saturated aliphatic carboxylic acids lacking additional coordinating functional groups predict a low Fe/Hf value.',
            'patterns': ['[CX3](=O)[OX2H1]'],
            'exclude_patterns': ['[NX3]', '[SX2H]', '[OX2][CX4]', '[OX2H]', '[F,Cl,Br,I]', '[c]'],
            'prediction': -1
        }
    ]

    # Compile SMARTS patterns
    for rule in rules:
        compiled_patterns = []
        for smarts in rule.get('patterns', []):
            mol = Chem.MolFromSmarts(smarts)
            compiled_patterns.append((smarts, mol))
        rule['compiled_patterns'] = compiled_patterns
        # Compile exclude patterns if any
        if 'exclude_patterns' in rule:
            compiled_exclude = []
            for smarts in rule['exclude_patterns']:
                mol = Chem.MolFromSmarts(smarts)
                compiled_exclude.append((smarts, mol))
            rule['compiled_exclude_patterns'] = compiled_exclude

    # Initialize results list
    results = []

    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*len(rules))
            continue
        row = []
        for rule in rules:
            try:
                match = True
                # Check exclude patterns if any
                if 'exclude_patterns' in rule:
                    for smarts, pat in rule['compiled_exclude_patterns']:
                        if mol.HasSubstructMatch(pat):
                            match = False
                            break
                    if not match:
                        row.append(0)
                        continue
                # Check required patterns
                for smarts, pat in rule['compiled_patterns']:
                    matches = mol.GetSubstructMatches(pat)
                    if not matches:
                        match = False
                        break
                    # If a count threshold is specified for this pattern
                    if 'count_threshold' in rule and smarts in rule['count_threshold']:
                        threshold = rule['count_threshold'][smarts]
                        if len(matches) < threshold:
                            match = False
                            break
                if match:
                    row.append(rule['prediction'])
                else:
                    row.append(0)
            except Exception as e:
                # In case of any error, append 0 and optionally log the error
                # print(f"Error processing rule {rule['number']} for SMILES {smi}: {e}")
                row.append(0)
        results.append(row)
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f"Rule {r['number']}" for r in rules])
    return df

--------------------------------------------------
    Target Name: Fe/Hf
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

- **Rule 1**: Modifiers containing a **terminal primary amino group (-NHâ‚‚)** on an **aliphatic chain of at least five carbons**, where the amino group is not alpha to the carboxylic acid, predict a **high** Fe/Hf value. The length of the carbon chain allows the amino group to coordinate effectively with metal centers without steric hindrance.

  - *Examples*: 
    - **5-aminopentanoic acid**
    - **7-aminoheptanoic acid**
    - **8-aminooctanoic acid**
    - **(2S)-6-acetamido-2-aminohexanoic acid**

- **Rule 2**: Modifiers containing **thiol groups (-SH)** or **thioether groups**, either attached to an aliphatic chain or an aromatic ring, predict a **high** Fe/Hf value. Sulfur atoms are good ligands for metal ions due to their soft Lewis base character.

  - *Examples*: 
    - **3-sulfanylpropanoic acid**
    - **4-sulfanylbenzoic acid**
    - **2-[[(2S)-2-amino-4-methylsulfanylbutanoyl]amino]acetic acid**

- **Rule 3**: Modifiers with **multiple ether linkages in a chain**, particularly those ending with a **terminal amino group**, predict a **high** Fe/Hf value. The presence of multiple ether oxygens and the terminal amino group provides multiple coordination sites.

  - *Examples*: 
    - **2-[2-(2-methoxyethoxy)ethoxy]acetic acid**
    - **3-[2-(2-aminoethoxy)ethoxy]propanoic acid**

- **Rule 4**: Modifiers containing **aromatic rings substituted with strong electron-withdrawing groups**, such as **nitro (-NOâ‚‚)** or **halomethyl (-CHâ‚‚X)** groups, predict a **high** Fe/Hf value. Electron-withdrawing groups increase the acidity of the carboxylic acid and facilitate coordination with metal ions.

  - *Examples*: 
    - **4-nitrobenzoic acid**
    - **4-(bromomethyl)benzoic acid**

- **Rule 5**: Modifiers containing **pyridine or pyridyl rings directly connected to the carboxylic acid**, either via conjugation or through a short aliphatic linker, predict a **high** Fe/Hf value. The nitrogen atom in the pyridine ring provides an additional coordination site for metal binding.

  - *Examples*: 
    - **4-pyridin-4-ylbenzoic acid**
    - **4-pyridin-4-ylbutanoic acid**

- **Rule 6**: Modifiers that are **small amino acids with side chains capable of coordination**, such as **aspartic acid** and **phenylalanine**, predict a **high** Fe/Hf value. The side chains provide additional coordination sites, and the overall size is not too bulky to hinder coordination.

  - *Examples*: 
    - **(2S)-2-aminobutanedioic acid** (aspartic acid)
    - **(2S)-2-amino-3-phenylpropanoic acid** (phenylalanine)

- **Rule 7**: Modifiers with **conjugated diketone systems** within heteroaromatic rings predict a **high** Fe/Hf value. The conjugated system and multiple carbonyl groups enhance coordination with metal ions.

  - *Example*: 
    - **1,3-dioxo-2-benzofuran-5-carboxylic acid**

- **Rule 8**: Modifiers containing **bulky, electron-rich aromatic or heteroaromatic side chains**, such as **indole rings**, predict a **low** Fe/Hf value. The steric hindrance and electron-rich environment reduce the ability to effectively coordinate with metal centers.

  - *Example*: 
    - **(2R)-2-amino-3-(1H-indol-3-yl)propanoic acid** (tryptophan)

- **Rule 9**: Modifiers with **aromatic rings substituted with strong electron-donating groups**, such as **amino (-NHâ‚‚)** or **hydroxyl (-OH)** groups, predict a **low** Fe/Hf value. Electron-donating groups decrease the acidity of the carboxylic acid, diminishing coordination with metal ions.

  - *Examples*: 
    - **4-aminobenzoic acid**
    - **5-(4-hydroxyphenyl)pentanoic acid**
    - **3-(4-hydroxyphenyl)propanoic acid**

- **Rule 10**: Modifiers containing **multiple hydroxyl groups (polyols)**, particularly when the hydroxyl groups are not arranged to facilitate chelation, predict a **low** Fe/Hf value. The strong hydrogen-bonding capabilities and hydrophilicity reduce their tendency to coordinate with metal ions.

  - *Example*: 
    - **(2R,3S,4R,5R)-2,3,4,5,6-pentahydroxyhexanoic acid** (gluconic acid)

- **Rule 11**: Modifiers with **fluorinated aliphatic chains** predict a **low** Fe/Hf value. The high electronegativity of fluorine atoms reduces electron density on potential donor atoms, making coordination with metal ions less favorable.

  - *Example*: 
    - **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**

- **Rule 12**: Modifiers that are **simple saturated aliphatic carboxylic acids** lacking additional coordinating functional groups predict a **low** Fe/Hf value. The absence of donor atoms beyond the carboxylate limits interaction with metal centers.

  - *Example*: 
    - **Octanoic acid**

- **Rule 13**: Modifiers containing **heteroaromatic rings where the heteroatom is not positioned to coordinate effectively**, such as pyridine rings with the nitrogen in the meta position relative to the carboxyl group, predict a **low** Fe/Hf value. The orientation of the heteroatom reduces coordination ability.

  - *Examples*: 
    - **Pyridine-3-carboxylic acid**
    - **1H-pyrazole-4-carboxylic acid**

- **Rule 14**: Modifiers with **aldehyde or ketone groups adjacent to aromatic rings** predict a **low** Fe/Hf value if the carbonyl oxygen is not optimally positioned for coordination. The electron-withdrawing effect can reduce the donating ability of other potential ligand sites.

  - *Examples*: 
    - **4-formylbenzoic acid**
    - **5-formyl-2-hydroxybenzoic acid**

- **Rule 15**: Modifiers that are **amino acids with bulky side chains or side chains that do not effectively coordinate**, such as **glutamic acid** and **tryptophan**, predict a **low** Fe/Hf value. The size or structure of the side chain may hinder coordination.

  - *Examples*: 
    - **(2S)-2-aminopentanedioic acid** (glutamic acid)
    - **(2R)-2-amino-3-(1H-indol-3-yl)propanoic acid** (tryptophan)

**End of Rules**---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10,Rule 11,Rule 12,Rule 13
0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1,0,0,1,0,0,0,0,0,0,0
0,0,0,1,0,0,0,0,0,0,0,0,0
0,0,1,0,0,1,0,0,0,0,0,0,0
1,0,1,0,0,1,0,0,0,0,0,0,0
0,0,1,0,0,1,0,0,-1,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,-1,0
0,0,0,0,0,0,0,0,0,-1,0,0,0
0,0,0,0,0,0,0,0,-1,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,-1,-1
0,0,0,0,0,0,0,0,0,-1,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,-1,-1
0,0,1,0,0,1,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,-1,0
0,0,1,0,0,1,0,-1,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,-1,0
0,0,0,0,0,0,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,-1,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,-1,0
0,0,0,1,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,-1,-1
0,0,0,0,0,0,0,0,0,0,0,-1,0
0,1,1,0,0,1,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,-1,-1
0,0,0,0,0,0,1,0,0,0,0,0,0
0,0,0,0,0,0,0,0,-1,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,-1,0
0,0,0,0,0,0,0,0,0,0,0,-1,0
0,0,0,0,0,0,0,0,-1,0,0,0,0
1,0,1,0,0,1,0,0,0,0,0,0,0
0,0,1,0,0,1,0,0,0,0,0,0,0
1,0,1,0,0,1,0,0,0,0,0,0,0
1,0,1,0,0,1,0,0,0,0,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.8285714285714286; Test Accuracy: 1.0
    Train Support: 0.2; Test Support: 0.0
    Train Confidence: 0.9090909090909092; Test Confidence: 0.5
    Train Lift: 1.767676767676768; Test Lift: NONE
    Train Leverage: 0.08244897959183674; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    # Define SMARTS patterns for functional groups using corrected patterns from suggestions
    # Carboxylic acid group (-COOH)
    carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1]'

    # Exclude hydroxyl groups that are part of carboxylic acids (Suggestion 1)
    non_carboxylic_hydroxyl = '[OX2H;!$([OX2H][CX3]=[OX1])]'

    # Primary aliphatic amine group (-NH2)
    primary_aliphatic_amine = '[NX3;H2][CX4;!$(C=[O,N,S])]'

    # Aliphatic chain of at least five carbons ending with NH2 and not alpha to COOH (Suggestion 2)
    # Because we cannot define this easily in SMARTS, we will check in code
    aliphatic_NH2_chain = '[C][C][C][C][C][NX3;H2]'

    # Thiol group (-SH)
    thiol_group = '[SX2H]'

    # Thioether group (-S-)
    thioether_group = '[SX2;!$(S=[O,N])]([#6])[#6]'

    # Ether linkage (-O-)
    ether_linkage = '[#6][OX2][#6]'

    # At least two ether linkages in a chain (Suggestion 5)
    # Again, we can count matches in code

    # Terminal amino group (-NH2)
    terminal_amino_group = '[NX3;H2]'

    # Nitro group on aromatic ring
    nitro_on_aromatic = '[c][NX3+](=O)[O-]'

    # Halomethyl group on aromatic ring
    halomethyl_on_aromatic = '[c][CH2][F,Cl,Br,I]'

    # Pyridine ring connected to carboxylic acid
    pyridine_ring_attached_to_COOH = 'n1ccccc1C(=O)[OH]'

    # Indole ring
    indole_ring = 'c1cc2ccccc2[nH]1'

    # Aromatic amino group directly on aromatic ring (Suggestion 4)
    aromatic_amino = '[c][NX3;H2]'

    # Aromatic hydroxyl group directly on aromatic ring
    aromatic_hydroxyl = '[c][OX2H;!$([OX2H][CX3]=[OX1])]'

    # Multiple hydroxyl groups not in carboxylic acids (Suggestion 6)
    hydroxyl_group = non_carboxylic_hydroxyl

    # Fluorinated aliphatic chain (Suggestion 3)
    fluorinated_chain = '[C;H1,H2,H3][F]'

    # Aldehyde or ketone adjacent to aromatic ring
    aldehyde_or_ketone_adjacent_to_aromatic = '[c][CX3](=O)[#6]'

    # Bulky side chains (tryptophan)
    tryptophan_pattern = 'C1=CC=C2C(=C1)C=CN2'

    # Compile patterns into RDKit Mol objects
    pattern_dict = {
        'carboxylic_acid': Chem.MolFromSmarts(carboxylic_acid),
        'non_carboxylic_hydroxyl': Chem.MolFromSmarts(non_carboxylic_hydroxyl),
        'primary_aliphatic_amine': Chem.MolFromSmarts(primary_aliphatic_amine),
        'aliphatic_NH2_chain': Chem.MolFromSmarts(aliphatic_NH2_chain),
        'thiol_group': Chem.MolFromSmarts(thiol_group),
        'thioether_group': Chem.MolFromSmarts(thioether_group),
        'ether_linkage': Chem.MolFromSmarts(ether_linkage),
        'terminal_amino_group': Chem.MolFromSmarts(terminal_amino_group),
        'nitro_on_aromatic': Chem.MolFromSmarts(nitro_on_aromatic),
        'halomethyl_on_aromatic': Chem.MolFromSmarts(halomethyl_on_aromatic),
        'pyridine_ring_attached_to_COOH': Chem.MolFromSmarts(pyridine_ring_attached_to_COOH),
        'indole_ring': Chem.MolFromSmarts(indole_ring),
        'aromatic_amino': Chem.MolFromSmarts(aromatic_amino),
        'aromatic_hydroxyl': Chem.MolFromSmarts(aromatic_hydroxyl),
        'hydroxyl_group': Chem.MolFromSmarts(hydroxyl_group),
        'fluorinated_chain': Chem.MolFromSmarts(fluorinated_chain),
        'aldehyde_or_ketone_adjacent_to_aromatic': Chem.MolFromSmarts(aldehyde_or_ketone_adjacent_to_aromatic),
        'tryptophan_pattern': Chem.MolFromSmarts(tryptophan_pattern)
    }

    # Define the rules with their associated patterns and predictions
    rules = [
        {
            'number': 1,
            'description': 'Modifiers containing a terminal primary amino group (-NH2) on an aliphatic chain of at least five carbons, not alpha to the carboxylic acid, predict a high Fe/Hf value.',
            'patterns': [
                pattern_dict['aliphatic_NH2_chain'],
                pattern_dict['carboxylic_acid']
            ],
            'exclude_patterns': None,
            'prediction': 1
        },
        {
            'number': 2,
            'description': 'Modifiers containing thiol groups (-SH) or thioether groups predict a high Fe/Hf value.',
            'patterns': [
                [pattern_dict['thiol_group'], pattern_dict['thioether_group']],
                pattern_dict['carboxylic_acid']
            ],
            'exclude_patterns': None,
            'prediction': 1
        },
        {
            'number': 3,
            'description': 'Modifiers with multiple ether linkages in a chain, particularly those ending with a terminal amino group, predict a high Fe/Hf value.',
            'patterns': [
                pattern_dict['carboxylic_acid'],
                pattern_dict['terminal_amino_group']
            ],
            'min_counts': {pattern_dict['ether_linkage']: 2},  # At least 2 ether linkages
            'exclude_patterns': None,
            'prediction': 1
        },
        {
            'number': 4,
            'description': 'Modifiers containing aromatic rings substituted with strong electron-withdrawing groups, such as nitro (-NO2) or halomethyl (-CH2X) groups, predict a high Fe/Hf value.',
            'patterns': [
                [pattern_dict['nitro_on_aromatic'], pattern_dict['halomethyl_on_aromatic']],
                pattern_dict['carboxylic_acid']
            ],
            'exclude_patterns': None,
            'prediction': 1
        },
        {
            'number': 5,
            'description': 'Modifiers containing pyridine rings directly connected to the carboxylic acid predict a high Fe/Hf value.',
            'patterns': [
                pattern_dict['pyridine_ring_attached_to_COOH'],
            ],
            'exclude_patterns': None,
            'prediction': 1
        },
        {
            'number': 6,
            'description': 'Modifiers that are small amino acids with side chains capable of coordination, such as aspartic acid and phenylalanine, predict a high Fe/Hf value.',
            'patterns': [
                pattern_dict['carboxylic_acid'],
                [pattern_dict['primary_aliphatic_amine'], pattern_dict['aromatic_amino']]
            ],
            'exclude_patterns': None,
            'prediction': 1
        },
        {
            'number': 7,
            'description': 'Modifiers with conjugated diketone systems within heteroaromatic rings predict a high Fe/Hf value.',
            'patterns': [
                pattern_dict['aldehyde_or_ketone_adjacent_to_aromatic'],
                pattern_dict['carboxylic_acid']
            ],
            'exclude_patterns': None,
            'prediction': 1
        },
        {
            'number': 8,
            'description': 'Modifiers containing bulky, electron-rich aromatic or heteroaromatic side chains, such as indole rings, predict a low Fe/Hf value.',
            'patterns': [
                pattern_dict['indole_ring'],
                pattern_dict['carboxylic_acid']
            ],
            'exclude_patterns': None,
            'prediction': -1
        },
        {
            'number': 9,
            'description': 'Modifiers with aromatic rings substituted with strong electron-donating groups, such as amino (-NH2) or hydroxyl (-OH) groups, predict a low Fe/Hf value.',
            'patterns': [
                [pattern_dict['aromatic_amino'], pattern_dict['aromatic_hydroxyl']],
                pattern_dict['carboxylic_acid']
            ],
            'exclude_patterns': [
                pattern_dict['nitro_on_aromatic'],
                pattern_dict['halomethyl_on_aromatic']
            ],
            'prediction': -1
        },
        {
            'number': 10,
            'description': 'Modifiers containing multiple hydroxyl groups (polyols), particularly when the hydroxyl groups are not arranged to facilitate chelation, predict a low Fe/Hf value.',
            'patterns': [
                pattern_dict['hydroxyl_group'],
                pattern_dict['carboxylic_acid']
            ],
            'min_counts': {pattern_dict['hydroxyl_group']: 2},  # At least 2 hydroxyl groups
            'exclude_patterns': None,
            'prediction': -1
        },
        {
            'number': 11,
            'description': 'Modifiers with fluorinated aliphatic chains predict a low Fe/Hf value.',
            'patterns': [
                pattern_dict['fluorinated_chain'],
                pattern_dict['carboxylic_acid']
            ],
            'exclude_patterns': None,
            'prediction': -1
        },
        {
            'number': 12,
            'description': 'Modifiers that are simple saturated aliphatic carboxylic acids lacking additional coordinating functional groups predict a low Fe/Hf value.',
            'patterns': [
                pattern_dict['carboxylic_acid']
            ],
            'exclude_patterns': [
                pattern_dict['primary_aliphatic_amine'],
                pattern_dict['thiol_group'],
                pattern_dict['thioether_group'],
                pattern_dict['ether_linkage'],
                pattern_dict['aromatic_amino'],
                pattern_dict['aromatic_hydroxyl'],
                pattern_dict['hydroxyl_group'],
                pattern_dict['nitro_on_aromatic'],
                pattern_dict['halomethyl_on_aromatic'],
            ],
            'prediction': -1
        },
        {
            'number': 13,
            'description': 'Modifiers containing heteroaromatic rings where the heteroatom is not positioned to coordinate effectively, such as pyridine rings with the nitrogen in the meta position relative to the carboxyl group, predict a low Fe/Hf value.',
            'patterns': [
                pattern_dict['carboxylic_acid'],
                # Pattern for heteroaromatic rings with heteroatom not positioned to coordinate
                # This might be complex, but we can use pyridine ring not attached to COOH
                Chem.MolFromSmarts('n1ccccc1'),  # Pyridine ring
            ],
            'exclude_patterns': [
                pattern_dict['pyridine_ring_attached_to_COOH'],
            ],
            'prediction': -1
        }
        # Continue adding the rest of the rules as needed
    ]

    # Initialize results list
    results = []

    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*len(rules))
            continue
        row = []
        for rule in rules:
            try:
                match = True
                # Check exclude patterns if any
                if 'exclude_patterns' in rule and rule['exclude_patterns']:
                    for pat in rule['exclude_patterns']:
                        if mol.HasSubstructMatch(pat):
                            match = False
                            break
                    if not match:
                        row.append(0)
                        continue
                # Check required patterns
                for pat in rule['patterns']:
                    if isinstance(pat, list):
                        group_match = False
                        for p in pat:
                            if mol.HasSubstructMatch(p):
                                group_match = True
                                break
                        if not group_match:
                            match = False
                            break
                    else:
                        if isinstance(pat, Chem.Mol):
                            if mol.HasSubstructMatch(pat):
                                # If a count threshold is specified for this pattern
                                if 'min_counts' in rule and pat in rule['min_counts']:
                                    threshold = rule['min_counts'][pat]
                                    matches = mol.GetSubstructMatches(pat)
                                    if len(matches) < threshold:
                                        match = False
                                        break
                            else:
                                match = False
                                break
                        else:
                            # Invalid pattern
                            match = False
                            break
                if match:
                    row.append(rule['prediction'])
                else:
                    row.append(0)
            except Exception as e:
                # In case of any error, append 0
                row.append(0)
        results.append(row)
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f"Rule {rule['number']}" for rule in rules])
    return df
--------------------------------------------------
    Target Name: Fe/Hf
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

- **Rule 1**: Modifiers containing an **aliphatic chain with a terminal primary amino group (-NHâ‚‚)**, where the amino group is **at least two carbons away from the carboxylic acid group (-COOH)**, predict a **high** Fe/Hf value. The spatial separation allows the amino group and carboxylate to coordinate simultaneously with metal centers, enhancing metal binding.

  - *Examples*:
    - **5-aminopentanoic acid**
    - **7-aminoheptanoic acid**
    - **8-aminooctanoic acid**

- **Rule 2**: Modifiers containing a **pyridine ring** attached to an aromatic or aliphatic linker, where the **pyridine nitrogen** is available for coordination, predict a **high** Fe/Hf value. The lone pair on the nitrogen atom serves as a strong coordination site for metal ions.

  - *Examples*:
    - **4-pyridin-4-ylbenzoic acid**
    - **4-pyridin-4-ylbutanoic acid**

- **Rule 3**: Modifiers that are **aromatic carboxylic acids substituted with strong electron-withdrawing groups**, such as **nitro (-NOâ‚‚)** or **bromomethyl (-CHâ‚‚Br)**, predict a **high** Fe/Hf value. Electron-withdrawing groups increase the acidity of the carboxylic acid, enhancing its ability to coordinate with metal centers.

  - *Examples*:
    - **4-nitrobenzoic acid**
    - **4-(bromomethyl)benzoic acid**

- **Rule 4**: Modifiers containing **both an amino group (-NHâ‚‚)** and an additional **carboxylic acid group (-COOH)** on a **short aliphatic chain**, predict a **high** Fe/Hf value. The proximity of the amino and carboxyl groups facilitates chelation, allowing the modifier to bind more effectively to metal ions.

  - *Example*:
    - **(2S)-2-aminobutanedioic acid** (Aspartic acid)

- **Rule 5**: Modifiers containing **sulfur-containing functional groups**, such as **thiols (-SH)** or **thioethers (-S-)**, predict a **high** Fe/Hf value. Sulfur atoms provide strong soft ligand sites, enhancing metal coordination.

  - *Examples*:
    - **3-sulfanylpropanoic acid**
    - **4-sulfanylbenzoic acid**
    - **2-[[(2S)-2-amino-4-methylsulfanylbutanoyl]amino]acetic acid**

- **Rule 6**: Modifiers that are **simple aliphatic carboxylic acids without additional coordinating functional groups** predict a **low** Fe/Hf value. The absence of other donor atoms (e.g., nitrogen, sulfur) limits their ability to interact strongly with metal ions.

  - *Example*:
    - **Octanoic acid**

- **Rule 7**: Modifiers containing **aromatic rings substituted with electron-donating groups**, such as **hydroxyl (-OH)** or **amino (-NHâ‚‚)** groups, predict a **low** Fe/Hf value. Electron-donating groups decrease the acidity of the carboxylic acid, reducing its propensity to coordinate with metal ions.

  - *Examples*:
    - **4-aminobenzoic acid**
    - **3-(4-hydroxyphenyl)propanoic acid**
    - **5-(4-hydroxyphenyl)pentanoic acid**

- **Rule 8**: Modifiers containing **multiple hydroxyl groups (-OH)** on an aliphatic chain or cyclic structure, without forming a suitable chelating arrangement, predict a **low** Fe/Hf value. Excessive hydrophilicity and steric hindrance from multiple hydroxyl groups reduce their ability to coordinate effectively with metal centers.

  - *Examples*:
    - **(2R,3S,4R,5R)-2,3,4,5,6-pentahydroxyhexanoic acid** (Gluconic acid)
    - **2-[[1,3-dihydroxy-2-(hydroxymethyl)propan-2-yl]oxy]acetic acid**

- **Rule 9**: Modifiers with **fluorinated aliphatic chains** predict a **low** Fe/Hf value. The strong electron-withdrawing effect of fluorine atoms decreases the electron density on potential coordinating atoms, reducing their ability to bind with metal ions.

  - *Example*:
    - **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**

- **Rule 10**: Modifiers containing **carbonyl groups (aldehydes or ketones) adjacent to the carboxylic acid group**, predict a **low** Fe/Hf value. Additional electron-withdrawing carbonyl groups can interfere with coordination by delocalizing electron density away from coordinating sites.

  - *Examples*:
    - **4-formylbenzoic acid**
    - **5-formyl-2-hydroxybenzoic acid**
    - **4-oxoheptanedioic acid**

**End of Rules**---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10
0,0,0,0,0,0,0,0,0,0
1,0,0,1,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
1,0,0,1,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0
0,1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0
0,0,0,1,0,0,0,0,0,0
0,0,0,0,0,0,0,0,-1,0
0,0,0,1,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,1,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
1,0,0,0,1,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,-1,0
0,0,0,0,0,0,-1,0,0,0
1,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0
0,0,0,1,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.7428571428571429; Test Accuracy: 0.0
    Train Support: 0.10857142857142857; Test Support: 0.0
    Train Confidence: 0.8914285714285715; Test Confidence: 0.5
    Train Lift: 1.7895424836601308; Test Lift: NONE
    Train Leverage: 0.04636734693877551; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    # Define SMARTS patterns for functional groups
    
    # Carboxylic acid group (-COOH)
    carboxylic_acid = ['[CX3](=O)[OX2H1]', '[CX3](=O)[O-]']
    
    # Primary amine group (-NH2)
    primary_amine = '[NX3;H2][CX4]'
    
    # Terminal primary amine (amine nitrogen connected to only one carbon)
    terminal_primary_amine = '[NX3;H2;!R][CX4;!R]'
    
    # Pyridine ring
    pyridine_ring = 'n1ccccc1'
    
    # Electron-withdrawing groups on aromatic ring
    aromatic_nitro = '[$(c[N+](=O)[O-])]'  # Nitro group attached to aromatic ring
    aromatic_bromomethyl = 'c[CH2Br]'
    
    # Sulfur-containing groups
    thiol = '[SX2H]'  # Thiol group
    thioether = '[#16X2][#6]'  # Thioether group
    
    # Electron-donating groups on aromatic ring
    aromatic_hydroxyl = '[c][OX2H]'  # Phenol group
    aromatic_amino = '[c][NX3;H2,H1]'  # Aniline group
    
    # Multiple hydroxyl groups (polyols)
    hydroxyl_group = '[OX2H]'
    
    # Fluorinated aliphatic chain
    fluorinated_chain = '[CX4](F)(F)(F)'  # Trifluoromethyl group as a proxy
    
    # Carbonyl groups adjacent to carboxylic acid
    adjacent_carbonyl = '[#6][CX3](=O)[CX3](=O)[OX1H0,-1]'
    
    # Define the rules with their associated patterns and predictions
    rules = [
        {
            'number': 1,
            'description': 'High Fe/Hf Value (True): Modifiers containing an aliphatic chain with a terminal primary amino group (-NH2), where the amino group is at least two carbons away from the carboxylic acid group (-COOH).',
            'patterns': [
                terminal_primary_amine,
                carboxylic_acid
            ],
            'distance': {'atoms1': '[NX3;H2]', 'atoms2': '[CX3](=O)[OX2H1]', 'min_distance': 4},  # At least 2 carbons apart (4 bonds)
            'prediction': 1
        },
        {
            'number': 2,
            'description': 'High Fe/Hf Value (True): Modifiers containing a pyridine ring attached to an aromatic or aliphatic linker, where the pyridine nitrogen is available for coordination.',
            'patterns': [
                pyridine_ring,
                carboxylic_acid
            ],
            'prediction': 1
        },
        {
            'number': 3,
            'description': 'High Fe/Hf Value (True): Modifiers that are aromatic carboxylic acids substituted with strong electron-withdrawing groups such as nitro (-NO2) or bromomethyl (-CH2Br).',
            'patterns': [
                carboxylic_acid,
                [aromatic_nitro, aromatic_bromomethyl]
            ],
            'prediction': 1
        },
        {
            'number': 4,
            'description': 'High Fe/Hf Value (True): Modifiers containing both an amino group (-NH2) and an additional carboxylic acid group (-COOH) on a short aliphatic chain.',
            'patterns': [
                primary_amine,
                carboxylic_acid
            ],
            'max_distance': {'atoms1': '[NX3;H2]', 'atoms2': '[CX3](=O)[OX2H1]', 'max_distance': 5},  # Short chain
            'prediction': 1
        },
        {
            'number': 5,
            'description': 'High Fe/Hf Value (True): Modifiers containing sulfur-containing functional groups such as thiols (-SH) or thioethers (-S-).',
            'patterns': [
                [thiol, thioether],
                carboxylic_acid
            ],
            'prediction': 1
        },
        {
            'number': 6,
            'description': 'Low Fe/Hf Value (False): Modifiers that are simple aliphatic carboxylic acids without additional coordinating functional groups.',
            'patterns': [
                carboxylic_acid
            ],
            'exclude_patterns': [
                primary_amine,
                '[N]',  # Any nitrogen
                '[S]',  # Any sulfur
                '[OX2H]',  # Hydroxyl group
                '[F,Cl,Br,I]',  # Halogens
                '[#6]=[O,N,S]'  # Carbonyl groups
            ],
            'prediction': -1
        },
        {
            'number': 7,
            'description': 'Low Fe/Hf Value (False): Modifiers containing aromatic rings substituted with electron-donating groups such as hydroxyl (-OH) or amino (-NH2) groups.',
            'patterns': [
                carboxylic_acid,
                [aromatic_hydroxyl, aromatic_amino]
            ],
            'prediction': -1
        },
        {
            'number': 8,
            'description': 'Low Fe/Hf Value (False): Modifiers containing multiple hydroxyl groups (-OH) on an aliphatic chain or cyclic structure, without forming a suitable chelating arrangement.',
            'patterns': [
                carboxylic_acid,
                hydroxyl_group
            ],
            'count_threshold': {'[OX2H]': 3},  # At least 3 hydroxyl groups
            'prediction': -1
        },
        {
            'number': 9,
            'description': 'Low Fe/Hf Value (False): Modifiers with fluorinated aliphatic chains.',
            'patterns': [
                carboxylic_acid,
                fluorinated_chain
            ],
            'prediction': -1
        },
        {
            'number': 10,
            'description': 'Low Fe/Hf Value (False): Modifiers containing carbonyl groups (aldehydes or ketones) adjacent to the carboxylic acid group.',
            'patterns': [
                adjacent_carbonyl
            ],
            'prediction': -1
        }
    ]
    
    # Compile SMARTS patterns
    for rule in rules:
        compiled_patterns = []
        for group in rule.get('patterns', []):
            if isinstance(group, list):
                compiled_group = [Chem.MolFromSmarts(p) for p in group]
                compiled_patterns.append(compiled_group)
            else:
                compiled_patterns.append([Chem.MolFromSmarts(group)])
        rule['compiled_patterns'] = compiled_patterns
        # Compile exclude patterns if any
        if 'exclude_patterns' in rule:
            compiled_excludes = []
            for p in rule['exclude_patterns']:
                compiled_excludes.append(Chem.MolFromSmarts(p))
            rule['compiled_exclude_patterns'] = compiled_excludes
        # Compile distance patterns if any
        if 'distance' in rule:
            rule['distance']['atoms1'] = Chem.MolFromSmarts(rule['distance']['atoms1'])
            rule['distance']['atoms2'] = Chem.MolFromSmarts(rule['distance']['atoms2'])
        if 'max_distance' in rule:
            rule['max_distance']['atoms1'] = Chem.MolFromSmarts(rule['max_distance']['atoms1'])
            rule['max_distance']['atoms2'] = Chem.MolFromSmarts(rule['max_distance']['atoms2'])
    
    # Initialize results list
    results = []
    
    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*len(rules))
            continue
        row = []
        for rule in rules:
            try:
                match = True
                # Check exclude patterns if any
                if 'exclude_patterns' in rule:
                    for pat in rule['compiled_exclude_patterns']:
                        if mol.HasSubstructMatch(pat):
                            match = False
                            break
                    if not match:
                        row.append(0)
                        continue
                # Check required patterns
                for compiled_group in rule['compiled_patterns']:
                    group_match = False
                    for pat in compiled_group:
                        matches = mol.GetSubstructMatches(pat)
                        if matches:
                            # If a count threshold is specified for this pattern
                            if 'count_threshold' in rule and pat.GetSmarts() in rule['count_threshold']:
                                threshold = rule['count_threshold'][pat.GetSmarts()]
                                if len(matches) >= threshold:
                                    group_match = True
                                    break
                            else:
                                group_match = True
                                break
                    if not group_match:
                        match = False
                        break
                # Check distance constraints if any
                if match and 'distance' in rule:
                    atoms1 = mol.GetSubstructMatches(rule['distance']['atoms1'])
                    atoms2 = mol.GetSubstructMatches(rule['distance']['atoms2'])
                    min_distance = rule['distance']['min_distance']
                    distance_match = False
                    for a1 in atoms1:
                        for a2 in atoms2:
                            path_length = len(Chem.rdmolops.GetShortestPath(mol, a1[0], a2[0]))
                            if path_length >= min_distance:
                                distance_match = True
                                break
                        if distance_match:
                            break
                    if not distance_match:
                        match = False
                if match and 'max_distance' in rule:
                    atoms1 = mol.GetSubstructMatches(rule['max_distance']['atoms1'])
                    atoms2 = mol.GetSubstructMatches(rule['max_distance']['atoms2'])
                    max_distance = rule['max_distance']['max_distance']
                    distance_match = False
                    for a1 in atoms1:
                        for a2 in atoms2:
                            path_length = len(Chem.rdmolops.GetShortestPath(mol, a1[0], a2[0]))
                            if path_length <= max_distance:
                                distance_match = True
                                break
                        if distance_match:
                            break
                    if not distance_match:
                        match = False
                if match:
                    row.append(rule['prediction'])
                else:
                    row.append(0)
            except Exception as e:
                # In case of any error, append 0
                row.append(0)
        results.append(row)
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f'Rule {rule["number"]}' for rule in rules])
    return df

--------------------------------------------------
    Target Name: Fe/Hf
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

- **Rule 1**: Modifiers containing a **terminal primary amino group (-NHâ‚‚)** on an **aliphatic chain** that is **at least two carbons away** from the **carboxylic acid group (-COOH)** predict a **high** Fe/Hf value. The spatial separation allows the amino group to effectively coordinate with metal ions, enhancing metal binding.

  - *Examples*:
    - **5-aminopentanoic acid**
    - **7-aminoheptanoic acid**
    - **8-aminooctanoic acid**

- **Rule 2**: Modifiers containing **sulfur-containing functional groups**, such as **thiols (-SH)** or **thioethers (-S-)**, predict a **high** Fe/Hf value. Sulfur atoms provide strong coordination sites due to their soft Lewis base character, enhancing interaction with metal centers.

  - *Examples*:
    - **3-sulfanylpropanoic acid**
    - **4-sulfanylbenzoic acid**
    - **2-[[(2S)-2-amino-4-methylsulfanylbutanoyl]amino]acetic acid**

- **Rule 3**: Modifiers containing a **pyridine ring** with the **nitrogen atom available for coordination**, especially when linked via a spacer to the carboxylic acid group, predict a **high** Fe/Hf value. The lone pair on the pyridine nitrogen enhances metal coordination.

  - *Examples*:
    - **4-pyridin-4-ylbenzoic acid**
    - **4-pyridin-4-ylbutanoic acid**

- **Rule 4**: Modifiers that are **aromatic carboxylic acids** substituted at the **para position** with **strong electron-withdrawing groups**, such as **nitro (-NOâ‚‚)** or **bromomethyl (-CHâ‚‚Br)**, predict a **high** Fe/Hf value. These groups increase the acidity of the carboxylic acid, facilitating deprotonation and metal binding.

  - *Examples*:
    - **4-nitrobenzoic acid**
    - **4-(bromomethyl)benzoic acid**

- **Rule 5**: Modifiers containing **additional coordinating functional groups**, such as **amino (-NHâ‚‚)** or **ether (-O-)** groups, positioned to allow **chelation**, predict a **high** Fe/Hf value. The presence of multiple donor atoms enhances binding affinity to metal ions.

  - *Examples*:
    - **(2S)-2-aminobutanedioic acid** (Aspartic acid)
    - **(2S)-6-acetamido-2-aminohexanoic acid**
    - **(2S)-2-amino-3-phenylpropanoic acid** (Phenylalanine)
    - **2-[2-(2-methoxyethoxy)ethoxy]acetic acid**
    - **3-[2-(2-aminoethoxy)ethoxy]propanoic acid**

- **Rule 6**: Modifiers that are **simple aliphatic carboxylic acids** without additional coordinating functional groups predict a **low** Fe/Hf value. The lack of donor atoms other than the carboxylate limits their interaction with metal ions.

  - *Examples*:
    - **Octanoic acid**
    - **4-methylbenzoic acid**

- **Rule 7**: Modifiers containing **aromatic rings substituted with electron-donating groups**, such as **hydroxyl (-OH)** or **amino (-NHâ‚‚)** groups at the **para position**, predict a **low** Fe/Hf value. Electron-donating groups decrease the acidity of the carboxylic acid, reducing its ability to coordinate with metal centers.

  - *Examples*:
    - **4-aminobenzoic acid**
    - **5-(4-hydroxyphenyl)pentanoic acid**
    - **3-(4-hydroxyphenyl)propanoic acid**

- **Rule 8**: Modifiers containing **multiple hydroxyl groups (-OH)** on an **aliphatic chain** or **cyclic structure**, without effective chelating arrangement, predict a **low** Fe/Hf value. Excessive hydroxyl groups can lead to steric hindrance and increased hydrophilicity, which may hinder coordination with metal ions.

  - *Examples*:
    - **(2R,3S,4R,5R)-2,3,4,5,6-pentahydroxyhexanoic acid** (Gluconic acid)
    - **2-[[1,3-dihydroxy-2-(hydroxymethyl)propan-2-yl]oxy]acetic acid**

- **Rule 9**: Modifiers with **fluorinated aliphatic chains** predict a **low** Fe/Hf value. The strong electron-withdrawing effect of fluorine atoms reduces electron density on potential coordinating oxygens, diminishing their ability to bind with metal ions.

  - *Example*:
    - **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**

- **Rule 10**: Modifiers containing **carbonyl groups (aldehydes or ketones)** adjacent to the **carboxylic acid group**, predict a **low** Fe/Hf value. Additional electron-withdrawing carbonyl groups can delocalize electron density away from coordinating sites, interfering with metal binding.

  - *Examples*:
    - **4-formylbenzoic acid**
    - **5-formyl-2-hydroxybenzoic acid**
    - **4-oxoheptanedioic acid**

**End of Rules**---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10
0,0,0,0,0,0,0,-1,0,0
0,0,0,0,1,0,0,-1,0,0
0,0,0,1,0,0,0,0,0,0
0,0,0,0,1,0,0,-1,0,0
1,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,-1,0,0
0,0,0,0,0,0,0,-1,0,0
0,0,1,0,0,0,0,0,0,0
0,0,0,0,0,0,0,-1,0,0
0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0
0,0,1,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0
0,0,0,0,0,0,0,0,-1,0
0,0,0,0,1,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,-1,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,1,0,0,0,0,0,0
0,0,1,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,1,0,0,1,0,0,0,0,0
0,0,1,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,-1,0,0
0,0,0,0,0,0,0,-1,0,0
0,0,0,0,0,0,0,0,-1,0
0,0,0,0,0,0,0,-1,0,0
1,0,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.8285714285714286; Test Accuracy: 0.0
    Train Support: 0.11428571428571428; Test Support: 0.0
    Train Confidence: 0.9148148148148149; Test Confidence: 0.4166666666666667
    Train Lift: 1.8474340353425323; Test Lift: NONE
    Train Leverage: 0.045714285714285714; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    # Define SMARTS patterns for functional groups, incorporating suggestions
    
    # Carboxylic acid group (-COOH)
    carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1]'
    
    # Terminal primary amine group (-NH2) at the end of an aliphatic chain
    terminal_primary_amine = '[NX3H2][CX4H2][CX4H2]'
    
    # Sulfur-containing functional groups
    thiol = '[SX2H]'  # Thiol (-SH)
    thioether = '[#16X2][#6;!$(C=S)]'  # Thioether (-S-), exclude sulfoxides etc.
    
    # Pyridine ring with nitrogen available
    pyridine_ring = 'n1ccccc1'
    
    # Aromatic carboxylic acids substituted at para position with nitro or bromomethyl
    para_nitro_benzoic_acid = 'c1ccc(cc1)[N+](=O)[O-]'
    para_bromomethyl_benzoic_acid = 'c1ccc(cc1)CBr'
    
    # Additional coordinating functional groups positioned to allow chelation
    amino_group = '[NX3H2,NX3H1,NX3H0]'
    ether_linkage = '[#6][OX2][#6]'
    
    # Exclude patterns for Rule 6
    exclude_patterns_rule6 = [
        '[NX3;!$(*=[O,N,S])]',  # Exclude any amine groups
        '[OX2H]',  # Exclude hydroxyl groups
        '[#16]',  # Exclude sulfur atoms
        '[OX2;!$(*=O)]',  # Exclude ethers
        '[F,Cl,Br,I]',  # Exclude halogens
        '[#7]',  # Exclude nitrogen
        '[a]'  # Exclude aromatic atoms
    ]
    
    # Aromatic rings substituted with electron-donating groups at para position
    para_hydroxyl_benzoic_acid = 'c1ccc(cc1O)C(=O)O'
    para_amino_benzoic_acid = 'c1ccc(cc1N)C(=O)O'
    
    # Multiple hydroxyl groups (-OH)
    hydroxyl_group = '[OX2H]'
    
    # Fluorinated aliphatic chains
    fluorinated_chain = '[CX4]([F])([F])[F]'
    
    # Carbonyl groups adjacent to carboxylic acid
    adjacent_carbonyl = '[CX3](=O)[CX3](=O)[OX1H0-,OX2H1]'
    
    # Define the rules
    rules = [
        {
            'number': 1,
            'description': 'Modifiers containing a terminal primary amino group (-NH2) on an aliphatic chain that is at least two carbons away from the carboxylic acid group (-COOH) predict a high Fe/Hf value.',
            'logic': 'custom_rule1',
            'smarts': [terminal_primary_amine, carboxylic_acid],
            'prediction': 1
        },
        {
            'number': 2,
            'description': 'Modifiers containing sulfur-containing functional groups, such as thiols (-SH) or thioethers (-S-), predict a high Fe/Hf value.',
            'logic': 'and',
            'smarts': [[thiol, thioether], carboxylic_acid],
            'prediction': 1
        },
        {
            'number': 3,
            'description': 'Modifiers containing a pyridine ring with the nitrogen atom available for coordination, predict a high Fe/Hf value.',
            'logic': 'and',
            'smarts': [pyridine_ring, carboxylic_acid],
            'prediction': 1
        },
        {
            'number': 4,
            'description': 'Modifiers that are aromatic carboxylic acids substituted at the para position with strong electron-withdrawing groups, such as nitro (-NO2) or bromomethyl (-CH2Br), predict a high Fe/Hf value.',
            'logic': 'or',
            'smarts': [para_nitro_benzoic_acid, para_bromomethyl_benzoic_acid],
            'prediction': 1
        },
        {
            'number': 5,
            'description': 'Modifiers containing additional coordinating functional groups, such as amino (-NH2) or ether (-O-) groups, positioned to allow chelation, predict a high Fe/Hf value.',
            'logic': 'custom_rule5',
            'smarts': [amino_group, ether_linkage, carboxylic_acid],
            'prediction': 1
        },
        {
            'number': 6,
            'description': 'Modifiers that are simple aliphatic carboxylic acids without additional coordinating functional groups predict a low Fe/Hf value.',
            'logic': 'and_exclude',
            'smarts': [carboxylic_acid],
            'exclude': exclude_patterns_rule6,
            'prediction': -1
        },
        {
            'number': 7,
            'description': 'Modifiers containing aromatic rings substituted with electron-donating groups, such as hydroxyl (-OH) or amino (-NH2) groups at the para position, predict a low Fe/Hf value.',
            'logic': 'or',
            'smarts': [para_hydroxyl_benzoic_acid, para_amino_benzoic_acid],
            'prediction': -1
        },
        {
            'number': 8,
            'description': 'Modifiers containing multiple hydroxyl groups (-OH) on an aliphatic chain or cyclic structure, without effective chelating arrangement, predict a low Fe/Hf value.',
            'logic': 'count',
            'smarts': [hydroxyl_group],
            'count_threshold': 2,
            'prediction': -1
        },
        {
            'number': 9,
            'description': 'Modifiers with fluorinated aliphatic chains predict a low Fe/Hf value.',
            'logic': 'count',
            'smarts': [fluorinated_chain],
            'count_threshold': 1,
            'prediction': -1
        },
        {
            'number': 10,
            'description': 'Modifiers containing carbonyl groups (aldehydes or ketones) adjacent to the carboxylic acid group predict a low Fe/Hf value.',
            'logic': 'and',
            'smarts': [adjacent_carbonyl],
            'prediction': -1
        },

    ]

    # Compile SMARTS patterns
    for rule in rules:
        compiled_patterns = []
        if 'smarts' in rule:
            for smarts in rule['smarts']:
                if isinstance(smarts, list):
                    compiled_subpatterns = [Chem.MolFromSmarts(s) for s in smarts]
                    compiled_patterns.append(compiled_subpatterns)
                else:
                    compiled_patterns.append(Chem.MolFromSmarts(smarts))
            rule['compiled_patterns'] = compiled_patterns

        # Compile exclude patterns if any
        if 'exclude' in rule:
            compiled_excludes = [Chem.MolFromSmarts(s) for s in rule['exclude']]
            rule['compiled_exclude'] = compiled_excludes

    # Initialize results list
    results = []

    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*len(rules))
            continue
        row = []
        for rule in rules:
            try:
                match = False
                # Handle logic for the rule
                if rule['logic'] == 'and':
                    match = True
                    for pat in rule['compiled_patterns']:
                        if isinstance(pat, list):
                            # Multiple patterns, match any
                            sub_match = False
                            for subpat in pat:
                                if mol.HasSubstructMatch(subpat):
                                    sub_match = True
                                    break
                            if not sub_match:
                                match = False
                                break
                        else:
                            if not mol.HasSubstructMatch(pat):
                                match = False
                                break
                elif rule['logic'] == 'or':
                    for pat in rule['compiled_patterns']:
                        if mol.HasSubstructMatch(pat):
                            match = True
                            break
                elif rule['logic'] == 'and_exclude':
                    match = True
                    for pat in rule['compiled_patterns']:
                        if not mol.HasSubstructMatch(pat):
                            match = False
                            break
                    if match:
                        for excl_pat in rule['compiled_exclude']:
                            if mol.HasSubstructMatch(excl_pat):
                                match = False
                                break
                elif rule['logic'] == 'count':
                    count = 0
                    for pat in rule['compiled_patterns']:
                        count += len(mol.GetSubstructMatches(pat))
                    if count >= rule['count_threshold']:
                        match = True
                elif rule['logic'] == 'custom_rule1':
                    # Implement the specific logic for Rule 1
                    # Check for terminal primary amine
                    amine_matches = mol.GetSubstructMatches(rule['compiled_patterns'][0])
                    # Check for carboxylic acid
                    acid_matches = mol.GetSubstructMatches(rule['compiled_patterns'][1])
                    if amine_matches and acid_matches:
                        nitrogen_idxs = [match[0] for match in amine_matches]
                        carboxyl_carbon_idxs = [match[0] for match in acid_matches]
                        for n_idx in nitrogen_idxs:
                            for c_idx in carboxyl_carbon_idxs:
                                # Find shortest path between N and C of COOH
                                path = Chem.rdmolops.GetShortestPath(mol, n_idx, c_idx)
                                # Exclude N and C from the count
                                if len(path) < 4:  # Need at least two carbons between N and C
                                    continue
                                # Check that the path is aliphatic chain: carbons connected via single bonds, no heteroatoms
                                aliphatic_chain = True
                                for i in range(len(path)-1):
                                    atom1 = mol.GetAtomWithIdx(path[i])
                                    atom2 = mol.GetAtomWithIdx(path[i+1])
                                    bond = mol.GetBondBetweenAtoms(path[i], path[i+1])
                                    if bond.GetBondType() != Chem.rdchem.BondType.SINGLE:
                                        aliphatic_chain = False
                                        break
                                    if atom1.GetAtomicNum() != 6 or atom2.GetAtomicNum() !=6:
                                        if i != 0 and i != len(path)-2:
                                            # Exclude the terminal atoms (N and C), but internal atoms must be carbons
                                            aliphatic_chain = False
                                            break
                                if aliphatic_chain:
                                    # Check that there are at least two carbons in the path between N and carboxyl C
                                    carbon_count = sum(1 for idx in path[1:-1] if mol.GetAtomWithIdx(idx).GetAtomicNum() ==6)
                                    if carbon_count >= 2:
                                        match = True
                                        break
                            if match:
                                break
                elif rule['logic'] == 'custom_rule5':
                    # Implement logic for Rule 5, check for chelation possibility
                    # The amino or ether group should be positioned to allow chelation with the carboxylic acid
                    # For simplicity, let's check if the amino or ether group is within 3 bonds of the carboxylic acid
                    has_amino = mol.HasSubstructMatch(rule['compiled_patterns'][0])
                    has_ether = mol.HasSubstructMatch(rule['compiled_patterns'][1])
                    has_acid = mol.HasSubstructMatch(rule['compiled_patterns'][2])
                    if has_acid and (has_amino or has_ether):
                        # Get the atom indices
                        acid_matches = mol.GetSubstructMatches(rule['compiled_patterns'][2])
                        func_group_matches = []
                        if has_amino:
                            func_group_matches.extend(mol.GetSubstructMatches(rule['compiled_patterns'][0]))
                        if has_ether:
                            func_group_matches.extend(mol.GetSubstructMatches(rule['compiled_patterns'][1]))
                        # Check distances
                        match = False
                        for acid_match in acid_matches:
                            acid_idx = acid_match[0]
                            for group_match in func_group_matches:
                                group_idx = group_match[0]
                                path_len = Chem.rdmolops.GetShortestPath(mol, acid_idx, group_idx)
                                if len(path_len) <= 4:  # At most 3 bonds apart
                                    match = True
                                    break
                            if match:
                                break
                else:
                    match = False

                row.append(rule['prediction'] if match else 0)
            except Exception as e:
                # In case of any error, append 0
                row.append(0)
        results.append(row)
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f'Rule {rule["number"]}' for rule in rules])
    return df
--------------------------------------------------
    Target Name: Fe/Hf
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

- **Rule 1**: Modifiers containing a **terminal primary amino group (-NHâ‚‚)** on an **aliphatic chain** that is **three or more carbons away** from the **carboxylic acid group (-COOH)** predict a **high** Fe/Hf value. The spatial separation reduces steric hindrance and allows the amino group to effectively coordinate with metal ions.

  - *Examples*:
    - **5-aminopentanoic acid**
    - **7-aminoheptanoic acid**
    - **8-aminooctanoic acid**

- **Rule 2**: Modifiers containing **sulfur-containing functional groups**, such as **thiols (-SH)** or **thioethers (-S-)**, predict a **high** Fe/Hf value. Sulfur atoms are soft Lewis bases and provide strong coordination sites, enhancing interaction with metal centers.

  - *Examples*:
    - **3-sulfanylpropanoic acid**
    - **4-sulfanylbenzoic acid**
    - **2-[[(2S)-2-amino-4-methylsulfanylbutanoyl]amino]acetic acid**

- **Rule 3**: Modifiers with a **pyridine ring** where the **nitrogen atom is available for coordination**, especially when linked via a spacer to the carboxylic acid group, predict a **high** Fe/Hf value. The lone pair on the pyridine nitrogen enhances metal binding through coordination bonds.

  - *Examples*:
    - **4-pyridin-4-ylbenzoic acid**
    - **4-pyridin-4-ylbutanoic acid**

- **Rule 4**: Modifiers that are **aromatic carboxylic acids** substituted at the **para position** with **strong electron-withdrawing groups**, such as **nitro (-NOâ‚‚)** or **bromomethyl (-CHâ‚‚Br)**, predict a **high** Fe/Hf value. These groups increase the acidity of the carboxylic acid, facilitating deprotonation and strengthening metal coordination.

  - *Examples*:
    - **4-nitrobenzoic acid**
    - **4-(bromomethyl)benzoic acid**

- **Rule 5**: Modifiers containing **multiple coordinating functional groups** with **heteroatoms** like **nitrogen (N)**, **oxygen (O)**, or **sulfur (S)** positioned to allow **chelation** predict a **high** Fe/Hf value. Chelation provides a multidentate binding mode, enhancing the stability of the metal-modifier complex.

  - *Examples*:
    - **(2S)-2-aminobutanedioic acid** (Aspartic acid)
    - **(2S)-6-acetamido-2-aminohexanoic acid**
    - **(2S)-2-amino-3-phenylpropanoic acid** (Phenylalanine)
    - **2-[2-(2-methoxyethoxy)ethoxy]acetic acid**
    - **3-[2-(2-aminoethoxy)ethoxy]propanoic acid**
    - **4-(3,4-dimethoxyphenyl)-4-oxobutanoic acid**

- **Rule 6**: Modifiers that are **simple aliphatic carboxylic acids** without additional coordinating functional groups predict a **low** Fe/Hf value. The lack of donor atoms other than the carboxylate limits their interaction with metal ions, reducing Fe incorporation.

  - *Example*:
    - **Octanoic acid**

- **Rule 7**: Modifiers containing **aromatic rings** substituted with **electron-donating groups**, such as **hydroxyl (-OH)** or **amino (-NHâ‚‚)** groups at the **para position**, predict a **low** Fe/Hf value. Electron-donating groups decrease the acidity of the carboxylic acid, reducing its ability to coordinate with metal centers.

  - *Examples*:
    - **4-aminobenzoic acid**
    - **5-(4-hydroxyphenyl)pentanoic acid**
    - **3-(4-hydroxyphenyl)propanoic acid**
    - **2-[(4-hydroxybenzoyl)amino]acetic acid**

- **Rule 8**: Modifiers containing **multiple hydroxyl groups (-OH)** on an **aliphatic chain** or **cyclic structure**, without an effective chelating arrangement, predict a **low** Fe/Hf value. Excessive hydroxyl groups increase hydrophilicity and may lead to steric hindrance, hindering coordination with metal ions.

  - *Examples*:
    - **(2R,3S,4R,5R)-2,3,4,5,6-pentahydroxyhexanoic acid** (Gluconic acid)
    - **2-[[1,3-dihydroxy-2-(hydroxymethyl)propan-2-yl]oxy]acetic acid**

- **Rule 9**: Modifiers with **fluorinated aliphatic chains** predict a **low** Fe/Hf value. The strong electron-withdrawing effect of fluorine atoms reduces electron density on potential coordinating oxygens, diminishing their ability to bind with metal ions.

  - *Example*:
    - **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**

- **Rule 10**: Modifiers containing **carbonyl groups (aldehydes or ketones)** adjacent to the **carboxylic acid group**, predict a **low** Fe/Hf value. Additional electron-withdrawing carbonyl groups can delocalize electron density away from coordinating sites, interfering with metal binding.

  - *Examples*:
    - **4-formylbenzoic acid**
    - **5-formyl-2-hydroxybenzoic acid**
    - **4-oxoheptanedioic acid**

- **Rule 11**: Modifiers containing **heteroaromatic rings with nitrogen atoms involved in resonance** (such as **pyridones** or **pyrazoles**) predict a **low** Fe/Hf value. The nitrogen lone pair is delocalized into the aromatic system and less available for coordination with metal ions.

  - *Examples*:
    - **2-oxo-1H-pyridine-4-carboxylic acid**
    - **1H-pyrazole-4-carboxylic acid**

- **Rule 12**: Modifiers with **bulky aromatic systems or fused ring structures** that may cause **steric hindrance** predict a **low** Fe/Hf value. Steric bulk around potential coordinating sites can impede effective metal binding.

  - *Example*:
    - **(2R)-2-amino-3-(1H-indol-3-yl)propanoic acid** (Tryptophan)

- **Rule 13**: Modifiers containing **electron-donating groups** at positions that can form **intramolecular hydrogen bonds** may decrease the availability of the coordinating group, predicting a **low** Fe/Hf value. Intramolecular interactions can reduce the ability of donor atoms to coordinate with metal centers.

  - *Example*:
    - **2-[(4-hydroxybenzoyl)amino]acetic acid**

**End of Rules**

---

These rules are designed to effectively predict whether a modifier will result in a high or low Fe/Hf value based on its structural features and underlying chemical properties. They combine multiple sub-structures, consider physical-chemical principles, and strike a balance between coverage and specificity to address the majority of the dataset.---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10,Rule 11,Rule 12,Rule 13
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
1,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,1,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,1,0,1,0,0,0,0,0,0,-1,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,1,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,1,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
1,0,0,0,1,0,0,0,0,0,0,0,0
1,0,0,0,1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,0,0
1,0,0,0,1,0,0,0,0,0,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.7142857142857143; Test Accuracy: 0.0
    Train Support: 0.1; Test Support: 0.0
    Train Confidence: 1.0; Test Confidence: 0.5
    Train Lift: 2.058823529411765; Test Lift: NONE
    Train Leverage: 0.05142857142857143; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    from rdkit import Chem
    import pandas as pd
    
    # Define SMARTS patterns
    carboxylic_acid = Chem.MolFromSmarts('[CX3](=O)[OX1H0-,OX2H1]')  # Carboxylic acid group (-COOH)
    primary_amine = Chem.MolFromSmarts('[NX3H2]')  # Primary amine (-NH2)
    terminal_primary_amine = Chem.MolFromSmarts('[NX3H2][CH2]')  # Terminal primary amine
    aliphatic_chain = Chem.MolFromSmarts('[CX4H2][CX4H2][CX4H2]')  # Aliphatic chain of at least 3 carbons
    
    thiol = Chem.MolFromSmarts('[SX2H]')  # Thiol group (-SH)
    thioether = Chem.MolFromSmarts('[#16X2]([#6])[#6]')  # Thioether (-S-)
    
    pyridine_ring = Chem.MolFromSmarts('n1cccc1')  # Pyridine ring
    
    # Electron-withdrawing groups
    nitro_group = Chem.MolFromSmarts('[NX3+(=O)[O-]]')  # Nitro group (-NO2)
    bromomethyl_group = Chem.MolFromSmarts('[CH2Br]')  # Bromomethyl group (-CH2Br)
    aromatic_ring = Chem.MolFromSmarts('c1ccccc1')  # Aromatic ring
    para_substitution = Chem.MolFromSmarts('c1ccc(cc1)-[*]')  # Para-substituted aromatic ring
    
    # Electron-donating groups
    hydroxyl_group = Chem.MolFromSmarts('[OX2H]')  # Hydroxyl group (-OH)
    amino_group = Chem.MolFromSmarts('[NX3H2]')  # Amino group (-NH2)
    
    # Heteroatoms for chelation
    heteroatoms = Chem.MolFromSmarts('[#7,#8,#16]')  # N, O, S
    
    # Multiple hydroxyl groups
    polyol = Chem.MolFromSmarts('[#6][OX2H][#6][OX2H][#6]')  # Chain with multiple -OH groups
    
    # Fluorinated aliphatic chain
    fluorinated_chain = Chem.MolFromSmarts('[CF3][CF2][CF2][CF2][CF3]')
    
    # Carbonyl groups adjacent to carboxylic acid
    adjacent_carbonyl = Chem.MolFromSmarts('[CX3](=O)[CX3](=O)[OX1H0-,OX2H1]')
    
    # Heteroaromatic rings with nitrogen in resonance
    pyridone = Chem.MolFromSmarts('O=c1ccncc1')
    pyrazole = Chem.MolFromSmarts('c1c[nH]ncc1')
    
    # Bulky aromatic systems
    indole = Chem.MolFromSmarts('c1ccc2c(c1)cc[nH]2')
    
    # Intramolecular hydrogen bonding
    intramolecular_Hbond = Chem.MolFromSmarts('[OH].[NX3][CX3](=O)[OH]')
    
    # Define rules
    rules = [
        {
            'number': 1,
            'description': 'Modifiers containing a terminal primary amino group (-NH2) on an aliphatic chain that is three or more carbons away from the carboxylic acid group (-COOH) predict a high Fe/Hf value.',
            'function': 'check_rule1',
            'prediction': 1
        },
        {
            'number': 2,
            'description': 'Modifiers containing sulfur-containing functional groups, such as thiols (-SH) or thioethers (-S-), predict a high Fe/Hf value.',
            'function': 'check_rule2',
            'prediction': 1
        },
        {
            'number': 3,
            'description': 'Modifiers with a pyridine ring where the nitrogen atom is available for coordination predict a high Fe/Hf value.',
            'function': 'check_rule3',
            'prediction': 1
        },
        {
            'number': 4,
            'description': 'Modifiers that are aromatic carboxylic acids substituted at the para position with strong electron-withdrawing groups predict a high Fe/Hf value.',
            'function': 'check_rule4',
            'prediction': 1
        },
        {
            'number': 5,
            'description': 'Modifiers containing multiple coordinating functional groups with heteroatoms like N, O, or S positioned to allow chelation predict a high Fe/Hf value.',
            'function': 'check_rule5',
            'prediction': 1
        },
        {
            'number': 6,
            'description': 'Modifiers that are simple aliphatic carboxylic acids without additional coordinating functional groups predict a low Fe/Hf value.',
            'function': 'check_rule6',
            'prediction': -1
        },
        {
            'number': 7,
            'description': 'Modifiers containing aromatic rings substituted with electron-donating groups at the para position predict a low Fe/Hf value.',
            'function': 'check_rule7',
            'prediction': -1
        },
        {
            'number': 8,
            'description': 'Modifiers containing multiple hydroxyl groups (-OH) on an aliphatic chain or cyclic structure, without an effective chelating arrangement, predict a low Fe/Hf value.',
            'function': 'check_rule8',
            'prediction': -1
        },
        {
            'number': 9,
            'description': 'Modifiers with fluorinated aliphatic chains predict a low Fe/Hf value.',
            'function': 'check_rule9',
            'prediction': -1
        },
        {
            'number': 10,
            'description': 'Modifiers containing carbonyl groups adjacent to the carboxylic acid group predict a low Fe/Hf value.',
            'function': 'check_rule10',
            'prediction': -1
        },
        {
            'number': 11,
            'description': 'Modifiers containing heteroaromatic rings with nitrogen atoms involved in resonance predict a low Fe/Hf value.',
            'function': 'check_rule11',
            'prediction': -1
        },
        {
            'number': 12,
            'description': 'Modifiers with bulky aromatic systems or fused ring structures that may cause steric hindrance predict a low Fe/Hf value.',
            'function': 'check_rule12',
            'prediction': -1
        },
        {
            'number': 13,
            'description': 'Modifiers containing electron-donating groups at positions that can form intramolecular hydrogen bonds may decrease the availability of the coordinating group, predicting a low Fe/Hf value.',
            'function': 'check_rule13',
            'prediction': -1
        }
    ]
    
    # Initialize results list
    results = []
    
    # Define rule check functions
    def check_rule1(mol):
        try:
            carboxy_matches = mol.GetSubstructMatches(carboxylic_acid)
            amine_matches = mol.GetSubstructMatches(terminal_primary_amine)
            if not carboxy_matches or not amine_matches:
                return 0
            for c_match in carboxy_matches:
                c_idx = c_match[0]
                for a_match in amine_matches:
                    n_idx = a_match[0]
                    path = Chem.GetShortestPath(mol, c_idx, n_idx)
                    # Exclude start and end atoms
                    path_atoms = path[1:-1]
                    # Count number of carbons in path_atoms
                    num_carbons = sum(1 for idx in path_atoms if mol.GetAtomWithIdx(idx).GetAtomicNum() == 6)
                    if num_carbons >= 3:
                        return 1
            return 0
        except:
            return 0
    
    def check_rule2(mol):
        try:
            if mol.HasSubstructMatch(thiol) or mol.HasSubstructMatch(thioether):
                return 1
            return 0
        except:
            return 0
    
    def check_rule3(mol):
        try:
            if mol.HasSubstructMatch(pyridine_ring):
                return 1
            return 0
        except:
            return 0
    
    def check_rule4(mol):
        try:
            if mol.HasSubstructMatch(carboxylic_acid) and mol.HasSubstructMatch(aromatic_ring):
                para_matches = mol.GetSubstructMatches(para_substitution)
                for match in para_matches:
                    substituted_atom = mol.GetAtomWithIdx(match[-1])
                    if substituted_atom.HasSubstructMatch(nitro_group) or substituted_atom.HasSubstructMatch(bromomethyl_group):
                        return 1
            return 0
        except:
            return 0
    
    def check_rule5(mol):
        try:
            heteroatom_matches = mol.GetSubstructMatches(heteroatoms)
            if len(heteroatom_matches) >= 2:
                # Check if heteroatoms are positioned to allow chelation (simplified assumption)
                return 1
            return 0
        except:
            return 0
    
    def check_rule6(mol):
        try:
            if mol.HasSubstructMatch(carboxylic_acid):
                if not (mol.HasSubstructMatch(primary_amine) or mol.HasSubstructMatch(thiol) or mol.HasSubstructMatch(thioether) or mol.HasSubstructMatch(hydroxyl_group) or mol.HasSubstructMatch(aromatic_ring)):
                    return -1
            return 0
        except:
            return 0
    
    def check_rule7(mol):
        try:
            if mol.HasSubstructMatch(carboxylic_acid) and mol.HasSubstructMatch(aromatic_ring):
                para_matches = mol.GetSubstructMatches(para_substitution)
                for match in para_matches:
                    substituted_atom = mol.GetAtomWithIdx(match[-1])
                    if substituted_atom.HasSubstructMatch(hydroxyl_group) or substituted_atom.HasSubstructMatch(amino_group):
                        return -1
            return 0
        except:
            return 0
    
    def check_rule8(mol):
        try:
            if mol.HasSubstructMatch(polyol):
                return -1
            return 0
        except:
            return 0
    
    def check_rule9(mol):
        try:
            if mol.HasSubstructMatch(fluorinated_chain):
                return -1
            return 0
        except:
            return 0
    
    def check_rule10(mol):
        try:
            if mol.HasSubstructMatch(adjacent_carbonyl):
                return -1
            return 0
        except:
            return 0
    
    def check_rule11(mol):
        try:
            if mol.HasSubstructMatch(pyridone) or mol.HasSubstructMatch(pyrazole):
                return -1
            return 0
        except:
            return 0
    
    def check_rule12(mol):
        try:
            if mol.HasSubstructMatch(indole):
                return -1
            return 0
        except:
            return 0
    
    def check_rule13(mol):
        try:
            if mol.HasSubstructMatch(intramolecular_Hbond):
                return -1
            return 0
        except:
            return 0
    
    # Map function names to actual functions
    rule_functions = {
        'check_rule1': check_rule1,
        'check_rule2': check_rule2,
        'check_rule3': check_rule3,
        'check_rule4': check_rule4,
        'check_rule5': check_rule5,
        'check_rule6': check_rule6,
        'check_rule7': check_rule7,
        'check_rule8': check_rule8,
        'check_rule9': check_rule9,
        'check_rule10': check_rule10,
        'check_rule11': check_rule11,
        'check_rule12': check_rule12,
        'check_rule13': check_rule13
    }
    
    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*len(rules))
            continue
        row = []
        for rule in rules:
            try:
                func = rule_functions[rule['function']]
                match = func(mol)
                if match:
                    row.append(rule['prediction'])
                else:
                    row.append(0)
            except Exception as e:
                # In case of any error, append 0
                row.append(0)
        results.append(row)
    
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])
    return df
--------------------------------------------------