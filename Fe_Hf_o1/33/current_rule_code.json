{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit, following the specified rules. Each rule corresponds to structural features specified by SMARTS patterns, and the function 'rule2matrix' identifies these features in the molecules.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Import necessary RDKit modules\n    from rdkit import Chem\n    from rdkit.Chem import AllChem\n    \n    # Define SMARTS patterns for functional groups and structural features\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Primary aliphatic amine group (-NH2)\n    primary_aliphatic_amine = '[NX3;H2][C]'\n    \n    # Thiol group (-SH)\n    thiol = '[SX2H]'\n    \n    # Ether linkage (-O-)\n    ether_linkage = '[CX4][OX2][CX4]'\n    \n    # Aromatic ring\n    aromatic_ring = 'a'\n    \n    # Electron-withdrawing groups (EWGs) at para position\n    nitro_group_para = '[$([c][c]([NX3+](=O)[O-])c)]'\n    halogen_para = '[$([c][c]([F,Cl,Br,I])c)]'\n    pyridyl_para = '[$([c][c](n)c)]'\n    \n    # Electron-donating groups (EDGs) at para position\n    amino_group_para = '[$([c][c]([NX3;H2,H1][#6])c)]'\n    methyl_group_para = '[$([c][c]([CH3])c)]'\n    hydroxyl_group_para = '[$([c][c]([OX2H])c)]'\n    \n    # Aldehyde group adjacent to aromatic ring\n    aldehyde_adjacent = '[#6][CX3H1](=O)'\n    \n    # Bulky aromatic side chains (e.g., indole ring)\n    indole_side_chain = '[#6][CH2][c]1[cH][nH][cH][cH][cH]1'\n    \n    # Conjugated carbonyl systems\n    conjugated_carbonyl = '[CX3](=O)[:$([#6]=[#6])]'  # Carbonyl conjugated with double bond\n    \n    # Fluorinated aliphatic chains\n    fluorinated_chain = '[CX4]([F,Cl,Br,I])[CX4]([F,Cl,Br,I])'  # Heavily halogenated chain\n    \n    # Sulfur-containing amino acids\n    sulfur_amino_acid = '[NX3;H2][CX4][CX4][SX2][CX4][CX3](=O)[OX1H0-,OX2H1]'  # Pattern for methionine-like structures\n    \n    # Multiple hydroxyl groups near carboxyl group\n    multiple_hydroxyls = '[OX2H][CX4][CX4][CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Dicarboxylic acids with short chains\n    dicarboxylic_acid_short = '[OX1H0-,OX2H1][CX3](=O)[CX4][CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Nitrogen heterocycles adjacent to carboxyl group\n    pyridine_carboxylic_acid = '[n][c][c][c][c][CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Initialize rules with patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are aliphatic amino acids with carbon chains ranging from 4 to 8 carbons, containing both amino (-NH2) and carboxyl (-COOH) groups.',\n            'patterns': [carboxylic_acid, primary_aliphatic_amine],\n            'exclude_patterns': [aromatic_ring],\n            'chain_length': (4, 8),  # Carbon chain length between amino and carboxyl groups\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Aromatic carboxylic acids with strong electron-withdrawing groups at the para position.',\n            'patterns': [carboxylic_acid, aromatic_ring],\n            'para_substituents': [nitro_group_para, halogen_para, pyridyl_para],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers containing both carboxyl and thiol groups.',\n            'patterns': [carboxylic_acid, thiol],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers with multiple hydroxyl groups near the carboxyl group.',\n            'patterns': [carboxylic_acid],\n            'hydroxyl_count': 2,\n            'prediction': -1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers with ether linkages and terminal carboxyl groups.',\n            'patterns': [carboxylic_acid, ether_linkage],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Simple aliphatic carboxylic acids without additional functional groups.',\n            'patterns': [carboxylic_acid],\n            'exclude_patterns': [primary_aliphatic_amine, thiol, ether_linkage, aromatic_ring],\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Aromatic carboxylic acids with electron-donating groups at the para position.',\n            'patterns': [carboxylic_acid, aromatic_ring],\n            'para_substituents': [amino_group_para, methyl_group_para, hydroxyl_group_para],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers with aldehyde groups adjacent to carboxyl groups.',\n            'patterns': [carboxylic_acid, aldehyde_adjacent],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Amino acids with bulky aromatic side chains.',\n            'patterns': [carboxylic_acid, primary_aliphatic_amine, indole_side_chain],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers with conjugated carbonyl systems adjacent to carboxyl groups.',\n            'patterns': [carboxylic_acid, conjugated_carbonyl],\n            'prediction': 1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers with heavily fluorinated aliphatic chains near the carboxyl group.',\n            'patterns': [carboxylic_acid, fluorinated_chain],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Sulfur-containing amino acids.',\n            'patterns': [carboxylic_acid, primary_aliphatic_amine, '[SX2][CX4]'],\n            'prediction': 1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers with terminal hydroxyl and carboxyl groups on medium-length aliphatic chains.',\n            'patterns': [carboxylic_acid, hydroxyl_group_para],\n            'chain_length': (5, 7),\n            'prediction': 1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers with multiple carboxyl groups on short chains.',\n            'patterns': [dicarboxylic_acid_short],\n            'prediction': -1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers with nitrogen heterocycles adjacent to the carboxyl group.',\n            'patterns': [pyridine_carboxylic_acid],\n            'prediction': -1\n        }\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for smarts in rule.get('patterns', []):\n            try:\n                compiled_patterns.append(Chem.MolFromSmarts(smarts))\n            except:\n                compiled_patterns.append(None)\n        rule['compiled_patterns'] = compiled_patterns\n        \n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for smarts in rule['exclude_patterns']:\n                try:\n                    compiled_excludes.append(Chem.MolFromSmarts(smarts))\n                except:\n                    compiled_excludes.append(None)\n            rule['compiled_exclude_patterns'] = compiled_excludes\n        \n        # Compile para substituents if any\n        if 'para_substituents' in rule:\n            compiled_para = []\n            for smarts in rule['para_substituents']:\n                try:\n                    compiled_para.append(Chem.MolFromSmarts(smarts))\n                except:\n                    compiled_para.append(None)\n            rule['compiled_para_substituents'] = compiled_para\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'compiled_exclude_patterns' in rule:\n                    for pat in rule['compiled_exclude_patterns']:\n                        if pat is not None and mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for pat in rule['compiled_patterns']:\n                    if pat is not None and not mol.HasSubstructMatch(pat):\n                        match = False\n                        break\n                if not match:\n                    row.append(0)\n                    continue\n                # Additional checks for specific rules\n                # Rule 1: Check chain length between amino and carboxyl groups\n                if rule['number'] == 1:\n                    # Find amino and carboxyl groups\n                    amine_atoms = mol.GetSubstructMatches(rule['compiled_patterns'][1])\n                    carboxyl_atoms = mol.GetSubstructMatches(rule['compiled_patterns'][0])\n                    chain_match = False\n                    for amine in amine_atoms:\n                        for carboxyl in carboxyl_atoms:\n                            path_length = Chem.GetShortestPath(mol, amine[0], carboxyl[0])\n                            num_carbons = sum(1 for idx in path_length if mol.GetAtomWithIdx(idx).GetAtomicNum() == 6)\n                            if rule['chain_length'][0] <= num_carbons <= rule['chain_length'][1]:\n                                chain_match = True\n                                break\n                        if chain_match:\n                            break\n                    if not chain_match:\n                        match = False\n                # Rule 2 and 7: Check for para substituents\n                if 'compiled_para_substituents' in rule:\n                    para_match = False\n                    for para_pat in rule['compiled_para_substituents']:\n                        if para_pat is not None and mol.HasSubstructMatch(para_pat):\n                            para_match = True\n                            break\n                    if not para_match:\n                        match = False\n                # Rule 4: Check for multiple hydroxyl groups\n                if rule['number'] == 4:\n                    hydroxyl_count = len(mol.GetSubstructMatches(Chem.MolFromSmarts('[OX2H]')))\n                    if hydroxyl_count < rule['hydroxyl_count']:\n                        match = False\n                # Rule 13: Check chain length\n                if rule['number'] == 13:\n                    # Find hydroxyl and carboxyl groups\n                    hydroxyl_atoms = mol.GetSubstructMatches(Chem.MolFromSmarts('[OX2H]'))\n                    carboxyl_atoms = mol.GetSubstructMatches(rule['compiled_patterns'][0])\n                    chain_match = False\n                    for hydroxyl in hydroxyl_atoms:\n                        for carboxyl in carboxyl_atoms:\n                            path = Chem.GetShortestPath(mol, hydroxyl[0], carboxyl[0])\n                            num_carbons = sum(1 for idx in path if mol.GetAtomWithIdx(idx).GetAtomicNum() == 6)\n                            if rule['chain_length'][0] <= num_carbons <= rule['chain_length'][1]:\n                                chain_match = True\n                                break\n                        if chain_match:\n                            break\n                    if not chain_match:\n                        match = False\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df\n"
}