{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. Each rule corresponds to a specific substructure or pattern in the molecules, defined using SMARTS patterns based on the provided natural language rules. For each SMILES string, the code checks whether it matches each rule and assigns a value of 1, -1, or 0:\n- 1 if the rule matches and predicts a high Fe/Hf value.\n- -1 if the rule matches and predicts a low Fe/Hf value.\n- 0 if the rule does not match.\nThe function 'rule2matrix' processes the SMILES list and returns a DataFrame where each column corresponds to a rule and each row corresponds to a SMILES string.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    \n    # Primary amino group (-NH2)\n    primary_amine = '[NX3;H2]'\n    \n    # Terminal primary amino group with chain length of four or more carbons\n    rule1_pattern = '[NX3;H2][CH2]{3,}[CX3](=O)[OX2H1]'\n    \n    # Aromatic carboxylic acid\n    aromatic_carboxylic_acid = '[c][CX3](=O)[OX2H1]'\n    \n    # Electron-withdrawing groups (EWGs) at para position\n    nitro_group = '[NX3](=O)=O'\n    bromoethyl_group = '[CH2][Br]'\n    pyridyl_ring = 'n1cccc1'\n    \n    # Patterns for Rule 2 (aromatic carboxylic acid with EWG at para position)\n    rule2_patterns = [\n        ('[#6;c]1:[#6;c]:[#6;c]:[#6;c]:[#6;c]:[#6;c]1[CX3](=O)[OX2H1]', '[#6;c]1:[#6;c]:[#6;c]:[#6;c]([N+](=O)[O-]):[#6;c]:[#6;c]1'),  # Nitro group at para position\n        ('[#6;c]1:[#6;c]:[#6;c]:[#6;c]:[#6;c]:[#6;c]1[CX3](=O)[OX2H1]', '[#6;c]1:[#6;c]:[#6;c]:[#6;c]([CH2Br]):[#6;c]:[#6;c]1'),          # Bromomethyl group at para position\n        ('[#6;c]1:[#6;c]:[#6;c]:[#6;c]:[#6;c]:[#6;c]1[CX3](=O)[OX2H1]', 'c1ccncc1')                                                         # Pyridyl ring\n    ]\n    \n    # Thiol group (-SH)\n    thiol = '[SX2H]'\n    \n    # Ether linkage (-O-)\n    ether_linkage = '[#6][OX2][#6]'\n    \n    # Hydroxyl group (-OH)\n    hydroxyl_group = '[OX2H]'\n    \n    # Multiple adjacent hydroxyl groups (sugar-like structures)\n    polyol = '[#6][OX2H][#6][OX2H][#6]'\n    \n    # Electron-donating groups (EDGs) on aromatic rings\n    aromatic_hydroxyl = '[c][OX2H]'\n    aromatic_amino = '[c][NX3;H2,H1]'\n    aromatic_methyl = '[c][CH3]'\n    \n    # Carbonyl groups adjacent to the carboxyl group\n    adjacent_carbonyl = '[CX3](=O)[#6][CX3](=O)'  # General pattern for adjacent carbonyl groups\n    \n    # Fluorinated alkyl chains or trifluoromethyl groups\n    fluorinated_chain = '[#6][CX4]([F])([F])[F]'\n    \n    # Rigid heteroaromatic rings attached to carboxyl group without additional coordinating groups\n    heteroaromatic_carboxylic_acid = '[n,o,s][c][CX3](=O)[OX2H1]'\n    \n    # Bulky or heterocyclic side chains in amino acids\n    bulky_amino_acid = '[NX3;H2][CX4][CX3](=[OX1])[C,N][c]'  # Simplified pattern for amino acids with side chains containing rings\n    \n    # Define the rules with their associated patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'Aliphatic carboxylic acids with a terminal primary amino group (-NH2) and a carbon chain length of four or more carbons.',\n            'patterns': [rule1_pattern],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Aromatic carboxylic acids with strong electron-withdrawing groups (EWGs) at the para position.',\n            'complex_patterns': rule2_patterns,\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers containing both thiol groups (-SH) and carboxylic acid groups.',\n            'patterns': [thiol, carboxylic_acid],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers with ether linkages in the backbone and terminal amino groups.',\n            'patterns': [ether_linkage, primary_amine],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Aliphatic carboxylic acids with terminal hydroxyl groups (-OH) on a carbon chain of six or more carbons.',\n            'patterns': ['[OX2H][CH2]{5,}[CX3](=O)[OX2H1]'],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Amino acids with small to medium-sized side chains that can participate in coordination.',\n            'patterns': ['[NX3;H2][CX4][CX3](=[OX1])[OX2H]'],\n            'exclude_patterns': [bulky_amino_acid],\n            'prediction': 1\n        },\n        {\n            'number': 7,\n            'description': 'Aromatic carboxylic acids with electron-donating groups (EDGs) at the para position.',\n            'patterns': [aromatic_carboxylic_acid],\n            'edg_patterns': [aromatic_hydroxyl, aromatic_amino, aromatic_methyl],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers with multiple adjacent hydroxyl groups near the carboxyl group.',\n            'patterns': [polyol, carboxylic_acid],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers containing additional carbonyl groups adjacent to the carboxyl group.',\n            'patterns': [adjacent_carbonyl],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers with fluorinated alkyl chains or trifluoromethyl groups.',\n            'patterns': [fluorinated_chain],\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers where the carboxyl group is directly attached to a rigid heteroaromatic ring without additional coordinating groups.',\n            'patterns': [heteroaromatic_carboxylic_acid],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Amino acids with bulky or heterocyclic side chains.',\n            'patterns': [bulky_amino_acid],\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers containing aromatic hydroxyl groups adjacent to the carboxyl group.',\n            'patterns': [aromatic_carboxylic_acid, aromatic_hydroxyl],\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers with saccharide or polyol structures.',\n            'patterns': [polyol],\n            'prediction': -1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers that are aliphatic carboxylic acids containing both ether linkages and bulky substituents.',\n            'patterns': [ether_linkage, '[#6][c]'],  # Ether linkage and aromatic ring\n            'prediction': -1\n        }\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for smarts in rule.get('patterns', []):\n            try:\n                pat = Chem.MolFromSmarts(smarts)\n                if pat is not None:\n                    compiled_patterns.append(pat)\n            except:\n                pass\n        rule['compiled_patterns'] = compiled_patterns\n        \n        # Compile exclude patterns if any\n        compiled_exclude_patterns = []\n        for smarts in rule.get('exclude_patterns', []):\n            try:\n                pat = Chem.MolFromSmarts(smarts)\n                if pat is not None:\n                    compiled_exclude_patterns.append(pat)\n            except:\n                pass\n        rule['compiled_exclude_patterns'] = compiled_exclude_patterns\n\n        # Compile patterns for electron-donating groups (EDGs) for Rule 7\n        compiled_edg_patterns = []\n        for smarts in rule.get('edg_patterns', []):\n            try:\n                pat = Chem.MolFromSmarts(smarts)\n                if pat is not None:\n                    compiled_edg_patterns.append(pat)\n            except:\n                pass\n        rule['compiled_edg_patterns'] = compiled_edg_patterns\n        \n        # Compile complex patterns for Rule 2\n        compiled_complex_patterns = []\n        for base_smarts, ewg_smarts in rule.get('complex_patterns', []):\n            try:\n                base_pat = Chem.MolFromSmarts(base_smarts)\n                ewg_pat = Chem.MolFromSmarts(ewg_smarts)\n                if base_pat is not None and ewg_pat is not None:\n                    compiled_complex_patterns.append((base_pat, ewg_pat))\n            except:\n                pass\n        rule['compiled_complex_patterns'] = compiled_complex_patterns\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = False\n                # Handle complex patterns (e.g., Rule 2)\n                if 'compiled_complex_patterns' in rule and rule['compiled_complex_patterns']:\n                    for base_pat, ewg_pat in rule['compiled_complex_patterns']:\n                        if mol.HasSubstructMatch(base_pat) and mol.HasSubstructMatch(ewg_pat):\n                            match = True\n                            break\n                else:\n                    # Check exclude patterns if any\n                    exclude = False\n                    for pat in rule.get('compiled_exclude_patterns', []):\n                        if mol.HasSubstructMatch(pat):\n                            exclude = True\n                            break\n                    if exclude:\n                        row.append(0)\n                        continue\n                    # Check required patterns\n                    pattern_matches = [mol.HasSubstructMatch(pat) for pat in rule['compiled_patterns']]\n                    if all(pattern_matches):\n                        match = True\n                    # Additional check for EDGs in Rule 7\n                    if rule.get('number') == 7 and match:\n                        edg_match = False\n                        for pat in rule.get('compiled_edg_patterns', []):\n                            if mol.HasSubstructMatch(pat):\n                                edg_match = True\n                                break\n                        match = edg_match\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}