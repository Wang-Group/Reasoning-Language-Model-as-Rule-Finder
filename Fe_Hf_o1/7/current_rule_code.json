{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. Each rule corresponds to certain structural patterns in the molecules, and the code checks these patterns using SMARTS. The output is a DataFrame where each column corresponds to a rule, and each row corresponds to an input SMILES string. The values in the DataFrame are 1, -1, or 0, depending on whether the rule matches and whether it predicts a high or low target value.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    \n    # Thiol group (-SH)\n    thiol = '[SX2H]'\n    \n    # Thioether group (-S-) excluding sulfoxides and sulfones\n    thioether = '[#16X2][#6]'  # Sulfur single-bonded to carbon\n    exclude_sulfoxide_sulfone = '[#16X3](=O)(=O)'  # Sulfoxide and sulfone\n    \n    # Pyridine nitrogen atom\n    pyridine_nitrogen = '[n]'\n    \n    # Amino group (-NH2 or -NH-)\n    amino_group = '[NX3;H2,H1;!$(N=*);!$(N#*)]'\n    \n    # Omega-amino acid pattern with chain length of 5 or more carbons\n    omega_amino_acid = '[NX3;H2][CH2]{4,}[CX3](=O)[OX2H1]'\n    \n    # Fused ring system with adjacent carbonyl groups\n    fused_ring_adjacent_carbonyl = '[R2][R1](=O)'\n    \n    # Electron-withdrawing groups (EWGs) on aromatic ring\n    ewg_on_aromatic = ['[c][NX3](=O)=O', '[c][CH2][Br,Cl,I]']  # Nitro and halomethyl groups\n    \n    # Electron-donating groups (EDGs) on aromatic ring\n    edg_on_aromatic = ['[c][OX2H]', '[c][OX2][CH3]', '[c][NX3;H2,H1][!$(N=*);!$(N#*)]', '[c][CH3]']\n    \n    # Ether linkages in aliphatic chains (-O-)\n    ether_linkage = '[#6][OX2][#6]'\n    \n    # Polyether chains with terminal amino or methoxy group\n    polyether_with_terminal_group = '[#6][OX2][#6][OX2][#6][OX2][NX3;H2,H1]'  # Simplified pattern\n    \n    # Multiple hydroxyl groups (polyhydroxy acids)\n    multiple_hydroxyl_groups = '[OX2H][#6][OX2H]'\n    \n    # Aromatic amino acids with aromatic side chains\n    aromatic_amino_acid = '[NX3;H2][CX4][CX3](=O)[OX2H1]'  # Simplified pattern for amino acids\n    \n    # Carbonyl-containing substituents at non-coordinating positions\n    non_coordinating_carbonyl = '[#6][CX3](=O)[#6]'  # Ketones and aldehydes\n    \n    # Compile SMARTS patterns\n    smarts_patterns = {\n        'carboxylic_acid': Chem.MolFromSmarts(carboxylic_acid),\n        'thiol': Chem.MolFromSmarts(thiol),\n        'thioether': Chem.MolFromSmarts(thioether),\n        'exclude_sulfoxide_sulfone': Chem.MolFromSmarts(exclude_sulfoxide_sulfone),\n        'pyridine_nitrogen': Chem.MolFromSmarts(pyridine_nitrogen),\n        'amino_group': Chem.MolFromSmarts(amino_group),\n        'omega_amino_acid': Chem.MolFromSmarts(omega_amino_acid),\n        'fused_ring_adjacent_carbonyl': Chem.MolFromSmarts(fused_ring_adjacent_carbonyl),\n        'ewg_on_aromatic': [Chem.MolFromSmarts(pat) for pat in ewg_on_aromatic],\n        'edg_on_aromatic': [Chem.MolFromSmarts(pat) for pat in edg_on_aromatic],\n        'ether_linkage': Chem.MolFromSmarts(ether_linkage),\n        'polyether_with_terminal_group': Chem.MolFromSmarts(polyether_with_terminal_group),\n        'multiple_hydroxyl_groups': Chem.MolFromSmarts(multiple_hydroxyl_groups),\n        'aromatic_amino_acid': Chem.MolFromSmarts(aromatic_amino_acid),\n        'non_coordinating_carbonyl': Chem.MolFromSmarts(non_coordinating_carbonyl)\n    }\n    \n    # Define the rules with their associated patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'High Fe/Hf Value (True): Modifiers containing functional groups capable of strong coordination with Fe ions, such as thiol (-SH), thioether (-S-), multiple amino groups, pyridine nitrogen atoms, and fused ring systems with adjacent carbonyl groups.',\n            'patterns': [\n                ('carboxylic_acid',),  # Must have carboxylic acid group\n                ('thiol', 'thioether', 'pyridine_nitrogen', 'omega_amino_acid', 'fused_ring_adjacent_carbonyl')  # Any of these\n            ],\n            'predictions': 1,\n            'count_thresholds': {'amino_group': 2}  # At least 2 amino groups\n        },\n        {\n            'number': 2,\n            'description': 'High Fe/Hf Value (True): Modifiers that are aromatic carboxylic acids with electron-withdrawing substituents at positions that enhance Fe coordination (e.g., nitro, bromomethyl groups).',\n            'patterns': [\n                ('carboxylic_acid',),  # Aromatic carboxylic acid\n                ('ewg_on_aromatic',)  # At least one EWG on aromatic ring\n            ],\n            'predictions': 1\n        },\n        {\n            'number': 3,\n            'description': 'Low Fe/Hf Value (False): Modifiers that are aromatic carboxylic acids with electron-donating substituents at the para position, or those with electron-rich aromatic rings.',\n            'patterns': [\n                ('carboxylic_acid',),  # Aromatic carboxylic acid\n                ('edg_on_aromatic',)  # At least one EDG on aromatic ring\n            ],\n            'predictions': -1\n        },\n        {\n            'number': 4,\n            'description': 'High Fe/Hf Value (True): Modifiers containing polyether chains with multiple ether linkages and a terminal coordinating group (e.g., amino or methoxy).',\n            'patterns': [\n                ('polyether_with_terminal_group',),\n                ('carboxylic_acid',)\n            ],\n            'predictions': 1\n        },\n        {\n            'number': 5,\n            'description': 'Low Fe/Hf Value (False): Simple aliphatic carboxylic acids without additional coordinating functional groups, or those with electron-withdrawing groups that do not enhance coordination.',\n            'patterns': [\n                ('carboxylic_acid',),\n            ],\n            'exclude_patterns': [\n                ('amino_group', 'thiol', 'thioether', 'pyridine_nitrogen', 'ether_linkage', 'ewg_on_aromatic', 'edg_on_aromatic')\n            ],\n            'predictions': -1\n        },\n        {\n            'number': 6,\n            'description': 'Low Fe/Hf Value (False): Modifiers containing multiple hydroxyl groups (polyhydroxy acids) or hydroxy-functionalized aliphatic chains.',\n            'patterns': [\n                ('multiple_hydroxyl_groups',),\n                ('carboxylic_acid',)\n            ],\n            'predictions': -1\n        },\n        {\n            'number': 7,\n            'description': 'High Fe/Hf Value (True): Modifiers that are amino acids with aromatic side chains capable of \u03c0-\u03c0 interactions or coordination.',\n            'patterns': [\n                ('aromatic_amino_acid',)\n            ],\n            'predictions': 1\n        },\n        {\n            'number': 8,\n            'description': 'Low Fe/Hf Value (False): Modifiers with carbonyl-containing substituents at positions that do not enhance coordination ability.',\n            'patterns': [\n                ('non_coordinating_carbonyl',),\n                ('carboxylic_acid',)\n            ],\n            'predictions': -1\n        }\n    ]\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for pattern_names in rule['exclude_patterns']:\n                        for name in pattern_names:\n                            pat = smarts_patterns.get(name)\n                            if pat is None:\n                                continue\n                            if isinstance(pat, list):\n                                # For lists of patterns (like ewg_on_aromatic)\n                                for p in pat:\n                                    if mol.HasSubstructMatch(p):\n                                        match = False\n                                        break\n                            else:\n                                if mol.HasSubstructMatch(pat):\n                                    match = False\n                                    break\n                        if not match:\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for pattern_names in rule.get('patterns', []):\n                    group_match = False\n                    for name in pattern_names:\n                        pat = smarts_patterns.get(name)\n                        if pat is None:\n                            continue\n                        if isinstance(pat, list):\n                            # For lists of patterns (like ewg_on_aromatic)\n                            for p in pat:\n                                if mol.HasSubstructMatch(p):\n                                    group_match = True\n                                    break\n                        else:\n                            if mol.HasSubstructMatch(pat):\n                                group_match = True\n                                break\n                    if not group_match:\n                        match = False\n                        break\n                # Check count thresholds if any\n                if match and 'count_thresholds' in rule:\n                    for name, threshold in rule['count_thresholds'].items():\n                        pat = smarts_patterns.get(name)\n                        if pat is None:\n                            continue\n                        matches = mol.GetSubstructMatches(pat)\n                        if len(matches) < threshold:\n                            match = False\n                            break\n                if match:\n                    row.append(rule['predictions'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}