{
    "prefix": "This code defines a function `rule2matrix` that converts a list of SMILES strings into a feature matrix using RDKit. The function applies a set of structural rules, defined using SMARTS patterns, to each SMILES string to determine whether each rule matches the molecule. The output is a DataFrame where each row corresponds to a SMILES string from the input list, and each column corresponds to a rule, with values of 1, -1, or 0 indicating whether the rule matches and predicts a high target value (1), matches and predicts a low target value (-1), or does not match (0), respectively.\n\nThe code incorporates suggestions to improve the accuracy of SMARTS patterns, handles possible errors by returning 0 when an error occurs for a rule applied to a SMILES, and considers appropriate logic (AND, OR, NOT/EXCLUDE) of SMARTS patterns to describe each rule.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for each rule, incorporating the suggestions\n\n    # Rule 1: Modifiers that are straight-chain aliphatic carboxylic acids with terminal primary amino groups at the omega (\u03c9) position.\n    # Patterns adjusted according to Suggestion 1\n    rule1_patterns = [\n        '[NX3;H2][CH2]{2,}[CX3](=O)[OX2H1]',  # Amino group at one end\n        '[CX3](=O)[OX2H1][CH2]{2,}[NX3;H2]'   # Amino group at the other end\n    ]\n\n    # Rule 2: Modifiers containing thiol groups (-SH)\n    rule2_pattern = '[SX2H]'\n\n    # Rule 3: Aromatic carboxylic acids with electron-withdrawing groups at the para position\n    # Patterns adjusted according to Suggestion 2\n    rule3_patterns = [\n        'c1cc([N+](=O)[O-])ccc1C(=O)[OX2H1]',  # Nitro group at para position\n        'c1cc(F)ccc1C(=O)[OX2H1]',             # Fluoro at para\n        'c1cc(Cl)ccc1C(=O)[OX2H1]',            # Chloro at para\n        'c1cc(Br)ccc1C(=O)[OX2H1]',            # Bromo at para\n        'c1cc(I)ccc1C(=O)[OX2H1]',             # Iodo at para\n        'c1cc(CF3)ccc1C(=O)[OX2H1]',           # Trifluoromethyl at para\n        'c1cc(CCl)ccc1C(=O)[OX2H1]',           # Chloromethyl at para\n        'c1cc(CBr)ccc1C(=O)[OX2H1]',           # Bromomethyl at para\n        'c1cc(CI)ccc1C(=O)[OX2H1]'             # Iodomethyl at para\n    ]\n\n    # Rule 4: Modifiers with pyridine rings available for coordination\n    rule4_pattern = 'n1ccccc1C(=O)[OX2H1]'\n\n    # Rule 5: Modifiers with multiple ether linkages ending with polar groups\n    # Pattern adjusted according to Suggestion 3\n    rule5_pattern = '[#6][O][#6]([O][#6]){1,}[CX3](=O)[OX2H1,NH2]'\n\n    # Rule 6: Modifiers with multiple hydroxyl groups (-OH) besides the carboxyl group\n    rule6_pattern = '[OX2H][CX4;!$(C=O)]'\n\n    # Rule 7: Aromatic carboxylic acids with electron-donating groups\n    # Patterns adjusted according to Suggestion 4\n    rule7_patterns = [\n        'c1cc([NX3;H2,H1])ccc1C(=O)[OX2H1]',  # Amino group on aromatic ring with carboxyl group\n        'c1cc([OX2H])ccc1C(=O)[OX2H1]'        # Hydroxy group on aromatic ring with carboxyl group\n    ]\n\n    # Rule 8: Modifiers with bulky or sterically hindered groups near coordination sites\n    rule8_pattern = 'c1ccc2ccccc2c1'  # Fused aromatic rings (e.g., naphthalene)\n\n    # Rule 9: Modifiers with fluorinated alkyl chains\n    # Pattern adjusted according to Suggestion 5\n    rule9_pattern = '[CX4][CX4](F)(F)(F)[CX4][CX3](=O)[OX2H1]'\n\n    # Rule 10: Modifiers with lactone rings or cyclic ester functionalities\n    # Patterns adjusted according to Suggestion 6\n    rule10_patterns = [\n        'O=C1OC[C@@H](O)[C@@H](O)C1',  # 5-membered lactone ring\n        'O=C1OCC[C@@H](O)C1'           # 6-membered lactone ring\n    ]\n\n    # Rule 11: Modifiers with side-chain amide groups\n    rule11_pattern = '[CX3](=O)[NX3][#6][CX3](=O)[OX2H1]'\n\n    # Rule 12: Simple aliphatic carboxylic acids without additional functional groups\n    # Exclude patterns adjusted according to Suggestion 7\n    rule12_pattern = '[CX3](=O)[OX2H1]'\n    rule12_exclude_patterns = [\n        '[#7;!$([NX3][CX3](=O)[OX2H1])]',  # Exclude nitrogen atoms not part of amide linkage\n        '[#8;!$([OX2H1][CX3](=O)[OX1H0-])]',  # Exclude oxygen atoms beyond the carboxyl group\n        '[#16]',  # Exclude sulfur atoms\n        '[OX2H;!$([OX2H][CX3](=O)[OX1H0-])]',  # Exclude hydroxyl groups beyond carboxyl hydroxyl\n        '[NX3;!$([NX3][CX3](=O)[OX1H0-])]',  # Exclude amino groups not part of amide linkage\n        '[SX2H]',  # Exclude thiol groups\n        '[#6][OX2][#6;!$(C=O)]',  # Exclude ether linkages not part of ester or carboxylate\n        '[a]',  # Exclude aromatic atoms\n        '[#6]=[#6]',  # Exclude double bonds\n        '[#6]#[#6]'   # Exclude triple bonds\n    ]\n\n    # Compile the patterns\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers with terminal primary amino groups on straight-chain aliphatic carboxylic acids.',\n            'patterns': rule1_patterns,\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers containing thiol groups (-SH).',\n            'patterns': [rule2_pattern],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Aromatic carboxylic acids with EWGs at the para position.',\n            'patterns': rule3_patterns,\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers with pyridine rings available for coordination.',\n            'patterns': [rule4_pattern],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers with multiple ether linkages ending with polar groups.',\n            'patterns': [rule5_pattern],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers with multiple hydroxyl groups (-OH) besides the carboxyl group.',\n            'patterns': [rule6_pattern],\n            'count_threshold': 2,\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Aromatic carboxylic acids with electron-donating groups.',\n            'patterns': rule7_patterns,\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers with bulky or sterically hindered groups near coordination sites.',\n            'patterns': [rule8_pattern],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers with fluorinated alkyl chains.',\n            'patterns': [rule9_pattern],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers with lactone rings or cyclic ester functionalities.',\n            'patterns': rule10_patterns,\n            'prediction': 1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers with side-chain amide groups.',\n            'patterns': [rule11_pattern],\n            'prediction': 1\n        },\n        {\n            'number': 12,\n            'description': 'Simple aliphatic carboxylic acids without additional functional groups.',\n            'patterns': [rule12_pattern],\n            'exclude_patterns': rule12_exclude_patterns,\n            'prediction': -1\n        }\n    ]\n\n    # Compile the patterns\n    for rule in rules:\n        compiled_patterns = [Chem.MolFromSmarts(p) for p in rule.get('patterns', [])]\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = [Chem.MolFromSmarts(p) for p in rule['exclude_patterns']]\n            rule['compiled_exclude_patterns'] = compiled_excludes\n        else:\n            rule['compiled_exclude_patterns'] = []\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                for pat in rule['compiled_exclude_patterns']:\n                    if mol.HasSubstructMatch(pat):\n                        match = False\n                        break\n                if not match:\n                    row.append(0)\n                    continue\n                # Check required patterns\n                if 'count_threshold' in rule:\n                    total_matches = 0\n                    for pat in rule['compiled_patterns']:\n                        matches = mol.GetSubstructMatches(pat)\n                        total_matches += len(matches)\n                    if total_matches >= rule['count_threshold']:\n                        row.append(rule['prediction'])\n                    else:\n                        row.append(0)\n                else:\n                    pattern_match = any(mol.HasSubstructMatch(pat) for pat in rule['compiled_patterns'])\n                    if pattern_match:\n                        row.append(rule['prediction'])\n                    else:\n                        row.append(0)\n            except Exception:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df"
}