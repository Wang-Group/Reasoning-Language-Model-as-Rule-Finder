{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit, based on the provided chemical rules. Each rule is translated into SMARTS patterns to allow for substructure searching in molecules. The function 'rule2matrix' processes each SMILES string and assigns a value according to whether the molecule matches the structural conditions of each rule and predicts a high (1) or low (-1) Fe/Hf ratio.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and structural features\n    \n    # Aliphatic carboxylic acid (-COOH) chain of 4 to 8 carbons\n    aliphatic_carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1]'\n    chain_4_8_carbons = '[CH2]CCCC[CH2]'\n    chain_4_carbons = '[CH2]CCC[CH2]'\n    chain_8_carbons = '[CH2]CCCCCCC[CH2]'\n    \n    # Terminal primary amino group (-NH2)\n    terminal_primary_amino = '[NX3H2][CH2]'\n    \n    # Alpha-amino dicarboxylic acid with short chain (4 carbons)\n    alpha_amino_dicarboxylic_acid = '[NX3H2][CH](C(=O)[OX1H0-,OX2H1])C(=O)[OX1H0-,OX2H1]'\n    \n    # Aromatic carboxylic acid with para-substituted electron-withdrawing group\n    aromatic_carboxylic_acid = 'c1ccc(cc1)C(=O)[OX1H0-,OX2H1]'\n    para_nitro = 'c1ccc([NX3+](=O)[O-])cc1'\n    para_bromomethyl = 'c1ccc(cc1)CBr'\n    para_pyridyl = 'c1ccc(cc1)c2ccncc2'\n    \n    # Thiol group adjacent to aromatic ring\n    thiol_adjacent_aromatic = 'c1ccc(SH)cc1'\n    \n    # Simple aliphatic carboxylic acids without additional coordinating groups\n    simple_aliphatic_carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Exclude patterns for additional coordinating groups\n    exclude_amino = '[NX3]'\n    exclude_thiol = '[SX2H]'\n    exclude_ether = '[#6][OX2][#6]'\n    exclude_aromatic = '[a]'\n    \n    # Multiple adjacent hydroxyl groups (polyols)\n    polyol = '[OX2H][CX4][OX2H]'\n    \n    # Phenolic hydroxyl groups\n    phenolic_hydroxyl = 'c[OX2H]'\n    \n    # Nitrogen heterocycles directly attached to carboxyl group\n    nitrogen_heterocycle_carboxylic_acid = '[nH]1cccc1C(=O)[OX1H0-,OX2H1]'\n    \n    # Amino acids with aromatic side chains lacking additional heteroatoms\n    amino_acid_aromatic_side_chain = '[NX3H2][CH](CCc1ccccc1)C(=O)[OX1H0-,OX2H1]'\n    \n    # Perfluorinated alkyl chains\n    perfluoro_alkyl_chain = '[CX4]([F])([F])[F]'\n    \n    # Ether linkages with terminal oxygen or nitrogen atoms\n    ether_linkage_terminal_ON = '[#6][OX2][#6][OX2H1,NX3H2]'\n    \n    # Compile SMARTS patterns\n    patterns = {\n        'Rule 1': {\n            'patterns': [\n                Chem.MolFromSmarts('C' * 4 + '[C](=O)[O,H]'),  # Aliphatic chain of 4 carbons with carboxylic acid\n                Chem.MolFromSmarts('[NX3H2][CH2]'),  # Terminal primary amino group\n            ],\n            'prediction': 1\n        },\n        'Rule 2': {\n            'patterns': [\n                Chem.MolFromSmarts('[NX3H2][CH](C(=O)[OX1H0-,OX2H1])C(=O)[OX1H0-,OX2H1]'),  # Alpha-amino dicarboxylic acid\n            ],\n            'exclude_patterns': [\n                Chem.MolFromSmarts('C' * 5 + '[C](=O)[O,H]'),  # Exclude chains longer than 4 carbons\n            ],\n            'prediction': 1\n        },\n        'Rule 3': {\n            'patterns': [\n                Chem.MolFromSmarts('c1ccc(cc1)[C](=O)[O,H]'),  # Aromatic carboxylic acid\n                Chem.MolFromSmarts('c1ccc([NX3+](=O)[O-])cc1'),  # Para-nitro group\n                Chem.MolFromSmarts('c1ccc(cc1)CBr'),  # Para-bromomethyl group\n                Chem.MolFromSmarts('c1ccc(cc1)c2ccncc2'),  # Para-pyridyl group\n            ],\n            'prediction': 1\n        },\n        'Rule 4': {\n            'patterns': [\n                Chem.MolFromSmarts('c1ccc(SH)cc1'),  # Thiol adjacent to aromatic ring\n            ],\n            'prediction': 1\n        },\n        'Rule 5': {\n            'patterns': [\n                Chem.MolFromSmarts('[CX3](=O)[OX1H0-,OX2H1]'),  # Aliphatic carboxylic acid\n            ],\n            'exclude_patterns': [\n                Chem.MolFromSmarts('[NX3]'),  # Exclude amino groups\n                Chem.MolFromSmarts('[SX2H]'),  # Exclude thiol groups\n                Chem.MolFromSmarts('[#6][OX2][#6]'),  # Exclude ether linkages\n                Chem.MolFromSmarts('[a]'),  # Exclude aromatic rings\n            ],\n            'prediction': -1\n        },\n        'Rule 6': {\n            'patterns': [\n                Chem.MolFromSmarts(polyol),  # Multiple adjacent hydroxyl groups\n                Chem.MolFromSmarts('[CX3](=O)[OX1H0-,OX2H1]'),  # Carboxylic acid group\n            ],\n            'count_threshold': {polyol: 2},  # At least two polyol groups\n            'prediction': -1\n        },\n        'Rule 7': {\n            'patterns': [\n                Chem.MolFromSmarts('c[OX2H]'),  # Phenolic hydroxyl group\n                Chem.MolFromSmarts('[CX3](=O)[OX1H0-,OX2H1]'),  # Carboxylic acid group\n            ],\n            'prediction': -1\n        },\n        'Rule 8': {\n            'patterns': [\n                Chem.MolFromSmarts('[nH]1cccc1C(=O)[OX1H0-,OX2H1]'),  # Nitrogen heterocycle attached to carboxyl group\n            ],\n            'prediction': -1\n        },\n        'Rule 9': {\n            'patterns':[ \n                Chem.MolFromSmarts('[NX3H2][CH](CCc1ccccc1)C(=O)[OX1H0-,OX2H1]'),  # Amino acid with aromatic side chain\n            ],\n            'exclude_patterns': [\n                Chem.MolFromSmarts('[NX3][c]'),  # Exclude additional heteroatoms in aromatic ring\n            ],\n            'prediction': 1\n        },\n        'Rule 10': {\n            'patterns': [\n                Chem.MolFromSmarts('[CX4]([F])([F])[F]'),  # Perfluorinated alkyl chain\n            ],\n            'prediction': -1\n        },\n        'Rule 11': {\n            'patterns': [\n                Chem.MolFromSmarts('[#6][OX2][#6][OX2H1,NX3H2]'),  # Ether linkage with terminal O or N\n            ],\n            'prediction': 1\n        },\n    }\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(patterns))\n            continue\n        row = []\n        for rule_name, rule in patterns.items():\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for pat in rule['exclude_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for pat in rule['patterns']:\n                    matches = mol.GetSubstructMatches(pat)\n                    if not matches:\n                        match = False\n                        break\n                    else:\n                        # If a count threshold is specified for this pattern\n                        if 'count_threshold' in rule:\n                            threshold = rule['count_threshold'].get(pat, 1)\n                            if len(matches) < threshold:\n                                match = False\n                                break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=list(patterns.keys()))\n    return df\n"
}