Rule Generator Message:
- **Rule 2**: **Para-Substituted Benzoic Acids with Electron-Withdrawing Groups Yield High**  
  Modifiers that are benzoic acid derivatives with electron-withdrawing substituents at the para position (e.g., nitro, bromo) result in high yield. Conversely, those with electron-donating groups or aldehyde groups at the para position yield low.
  *Examples:*  
  - High Yield:  
    - 4-(bromomethyl)benzoic acid – High Yield  
    - 4-nitrobenzoic acid – High Yield  
  - Low Yield:  
    - 4-methylbenzoic acid – Low Yield  
    - 4-formylbenzoic acid – Low Yield


----------------------------------------
Rule Commenter Message:
- **Comment 2**: Rule 2 is clear and well-supported by data points (modifiers 1, 20, 21, 23). It offers good property insight by associating electron-withdrawing para substituents with high yield and electron-donating or aldehyde groups with low yield. The rule effectively balances complexity and coverage.


----------------------------------------
Rule Advisor Message:
- **Advice 3**: **Increase Coverage by Generalizing or Merging Similar Rules**


----------------------------------------
Rule Generator Message:
- **Rule 2**: **Para-Substituted Benzoic Acids with Electron-Withdrawing Groups Yield High; Electron-Donating or Bulky Groups Yield Low**  
  Modifiers that are benzoic acid derivatives with electron-withdrawing substituents at the para position (e.g., nitro, bromo, amino) result in high yield. Those with electron-donating substituents (e.g., methyl, methoxy) or bulky aromatic substituents yield low.  
  *Examples:*  
    - High Yield:  
      - 4-nitrobenzoic acid – High Yield  
      - 4-(bromomethyl)benzoic acid – High Yield  
      - 4-aminobenzoic acid – High Yield  
    - Low Yield:  
      - 4-methylbenzoic acid – Low Yield  
      - 4-formylbenzoic acid – Low Yield  
      - 4-pyridin-4-ylbenzoic acid – Low Yield

----------------------------------------
Rule Commenter Message:
  - **Comment 2**: Rule 2 attempts to correlate para-substituent electronic effects with yield, stating that electron-withdrawing groups result in high yield, while electron-donating or bulky groups result in low yield. However, there are inconsistencies with this rule. For example, 4-aminobenzoic acid is listed as high yield, but the amino group is generally electron-donating. Similarly, 4-formylbenzoic acid, which contains an electron-withdrawing formyl group, is listed as low yield. This suggests a lack of clarity and property insight in the rule. The rule may need to be refined to accurately reflect the observed data. The complexity of the rule is acceptable, but the coverage is undermined by these inconsistencies.

----------------------------------------
Rule Advisor Message:
- **Advice 1**: **Refine Rule 2 to Align with Observed Data**  
  The current Rule 2 suggests that electron-withdrawing groups at the para position lead to high yield, while electron-donating groups result in low yield. However, the data shows inconsistencies—for example, 4-aminobenzoic acid (an electron-donating amino group) yields high, and 4-formylbenzoic acid (an electron-withdrawing formyl group) yields low. Refine the rule to focus on the ability of the substituents to coordinate with the metal center or participate in specific interactions rather than solely on their electronic nature. Consider grouping substituents based on their coordination potential or steric effects.
- **Advice 10**: **Consider Steric and Electronic Effects Together**  
  In rules where electronic effects don't fully explain the observed yields (e.g., Rule 2), incorporate steric considerations. For example, bulky substituents may hinder catalyst interaction regardless of their electronic nature. Adjust the rules to reflect the combined influence of steric and electronic factors.

----------------------------------------
Rule Generator Message:
- **Rule 2**: **Para-Substituted Benzoic Acids with Metal-Coordinating Groups Yield High; Non-Coordinating Groups Yield Low**.

  Modifiers that are benzoic acid derivatives with substituents at the para position capable of coordinating with metal centers (e.g., amino, nitro, bromomethyl) result in high yield. Substituents that are non-coordinating or solely electron-donating (e.g., methyl) yield low. Coordination enhances interaction with the catalyst.

  *Examples:*

    - **High Yield:**
      - 4-aminobenzoic acid – High Yield
      - 4-nitrobenzoic acid – High Yield
      - 4-(bromomethyl)benzoic acid – High Yield
    - **Low Yield:**
      - 4-methylbenzoic acid – Low Yield
      - 4-formylbenzoic acid – Low Yield

----------------------------------------
Rule Commenter Message:
- **Comment 2**:

  **Rule 2**: Para-Substituted Benzoic Acids with Metal-Coordinating Groups Yield High; Non-Coordinating Groups Yield Low
  
  - **Clarity**: Clearly specifies the position (para) and the nature of substituents (metal-coordinating vs. non-coordinating), allowing for straightforward application.
  - **Property Insight**: Highlights the importance of metal coordination in enhancing catalyst interaction, aligning with chemical principles.
  - **Complexity**: Incorporates both positional and functional group considerations, adding necessary complexity.
  - **Coverage**: Well-supported by examples of high yield (e.g., 4-aminobenzoic acid, 4-nitrobenzoic acid) and low yield (e.g., 4-methylbenzoic acid, 4-formylbenzoic acid).
  - **Balance**: Balanced in complexity and breadth, making it an effective predictive rule.


---------------------------------------
Matrix Generator Message:
Code for rules:
def rule2matrix(smiles_list):
    # Define the rules with their associated patterns and predictions
    rules = [
        {
            'number': 2,
            'description': 'Rule 2: Para-Substituted Benzoic Acids with Metal-Coordinating Groups Yield High; Non-Coordinating Groups Yield Low',
            'high_patterns': [
                {'para_substituted_benzoic_acid': Chem.MolFromSmarts('c1ccc(cc1)C(=O)[OH]')},
                {'coordinating_group': [
                    Chem.MolFromSmarts('c1ccc(cc1[NH2])C(=O)[OH]'),  # Amino group
                    Chem.MolFromSmarts('c1ccc(cc1[N+](=O)[O-])C(=O)[OH]'),  # Nitro group
                    Chem.MolFromSmarts('c1ccc(cc1CBr)C(=O)[OH]'),  # Bromomethyl group
                ]},
            ],
            'low_patterns': [
                {'para_substituted_benzoic_acid': Chem.MolFromSmarts('c1ccc(cc1)C(=O)[OH]')},
                {'non_coordinating_group': [
                    Chem.MolFromSmarts('c1ccc(cc1C)C(=O)[OH]'),  # Methyl group
                ]},
            ],
            'prediction': None  # Determined by substituent type
        },
        ]
      # Initialize results list
    results = []
    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*len(rules))
            continue
        row = []
        for rule in rules:
            try:
                match = False
                # Rule-specific logic
                if rule['number'] == 1:
                    # Rule 1 implementation
                    amine = rule['high_patterns'][0]['amine']
                    carboxylic_acid = rule['high_patterns'][1]['carboxylic_acid']
                    amine_matches = mol.GetSubstructMatches(amine)
                    carboxylic_matches = mol.GetSubstructMatches(carboxylic_acid)
                    chain_lengths = []
                    for a in amine_matches:
                        for c in carboxylic_matches:
                            path = Chem.GetShortestPath(mol, a[0], c[0])
                            carbons_in_path = [atom_idx for atom_idx in path if mol.GetAtomWithIdx(atom_idx).GetAtomicNum() == 6]
                            chain_length = len(carbons_in_path)
                            chain_lengths.append(chain_length)
                    if chain_lengths:
                        min_chain_length = min(chain_lengths)
                        if 2 <= min_chain_length <= 3:
                            row.append(1)
                        elif min_chain_length >= 4:
                            row.append(-1)
                        else:
                            row.append(0)
                    else:
                        row.append(0)
                elif rule['number'] == 2:
                    # Rule 2 implementation
                    benzoic_acid = rule['high_patterns'][0]['para_substituted_benzoic_acid']
                    benzoic_matches = mol.GetSubstructMatches(benzoic_acid)
                    if benzoic_matches:
                        high = False
                        low = False
                        # Check for coordinating groups
                        for patt in rule['high_patterns'][1]['coordinating_group']:
                            if mol.HasSubstructMatch(patt):
                                high = True
                                break
                        # Check for non-coordinating groups
                        for patt in rule['low_patterns'][1]['non_coordinating_group']:
                            if mol.HasSubstructMatch(patt):
                                low = True
                                break
                        if high:
                            row.append(1)
                        elif low:
                            row.append(-1)
                        else:
                            row.append(0)
                    else:
                        row.append(0)
                elif rule['number'] == 3:
                    # Rule 3 implementation
                    for patt_dict in rule['patterns']:
                        for patt in patt_dict.values():
                            if mol.HasSubstructMatch(patt):
                                match = True
                                break
                    row.append(rule['prediction'] if match else 0)
                elif rule['number'] == 4:
                    # Rule 4 implementation
                    long_chain_acid = rule['high_patterns'][0]['long_chain_carboxylic_acid']
                    amino_substituted = rule['low_patterns'][0]['amino_substituted']
                    if mol.HasSubstructMatch(long_chain_acid):
                        if mol.HasSubstructMatch(amino_substituted):
                            row.append(-1)
                        else:
                            row.append(1)
                    else:
                        row.append(0)
                # ... Implement other rules similarly ...
                else:
                    # Default case
                    row.append(0)
            except Exception as e:
                # In case of any error, append 0
                row.append(0)
        results.append(row)
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f'Rule {rule["number"]}' for rule in rules])
    return df


---------------------------------------------------------------
Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4
0,0,0,0
1,0,0,0
0,0,1,0
1,0,0,0
-1,0,0,0
-1,0,1,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,1,0
0,0,0,0
0,0,1,0
0,0,0,0
0,0,1,0
1,0,0,0
0,0,0,0
1,0,0,0
0,0,1,0
0,-1,1,0
0,0,0,0
0,-1,1,0
0,0,1,0
0,0,1,0
0,0,1,0
0,0,1,0
-1,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
-1,0,0,0
-1,0,0,0
1,0,0,0
-1,0,0,0


---------------------------------------------------------------
Matrix Checker Message:
- ** Suggestion 3 **: For Rule 2, revise the SMARTS patterns to accurately detect para-substituted benzoic acids with coordinating groups. The current patterns may not correctly identify molecules like 4-aminobenzoic acid. Use explicit substitution patterns to ensure that the substituents are at the para position relative to the carboxylic acid group.
- ** Suggestion 4 **: Modify the `benzoic_acid` pattern in Rule 2 to specify the carboxylic acid at the para position relative to the substituent. For example, use a SMARTS like `c1cc(ccc1[X])C(=O)[OH]`, where `[X]` represents the para-substituent. This will help in distinguishing between para, meta, and ortho substitutions.

---------------------------------------
Matrix Generator Message:
Code for rules:
def rule2matrix(smiles_list):
    # Define the rules with their associated patterns and predictions
    rules = [
        {
            'number': 2,
            'description': 'Rule 2: Para-Substituted Benzoic Acids with Metal-Coordinating Groups Yield High; Non-Coordinating Groups Yield Low',
            'predictions': {'high': 1, 'low': -1},
            'benzoic_acid_pattern': Chem.MolFromSmarts('c1ccc(cc1)C(=O)[OH]'),
            'para_coordinating_patterns': [
                Chem.MolFromSmarts('c1ccc(cc1[NH2])C(=O)[OH]'),  # Para-amino
                Chem.MolFromSmarts('c1ccc(cc1[N+](=O)[O-])C(=O)[OH]'),  # Para-nitro
                Chem.MolFromSmarts('c1ccc(cc1CBr)C(=O)[OH]'),  # Para-bromomethyl
            ],
            'para_non_coordinating_patterns': [
                Chem.MolFromSmarts('c1ccc(cc1C)C(=O)[OH]'),  # Para-methyl
                Chem.MolFromSmarts('c1ccc(cc1C=O)C(=O)[OH]'),  # Para-formyl
            ],
        },
    ]
    # Initialize results list
    results = []

    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*len(rules))
            continue
        row = []
        for rule in rules:
            try:
                if rule['number'] == 1:
                    # Rule 1 implementation
                    amine_matches = mol.GetSubstructMatches(rule['amine_pattern'])
                    acid_matches = mol.GetSubstructMatches(rule['carboxylic_acid_pattern'])
                    chain_lengths = []
                    for amine_match in amine_matches:
                        for acid_match in acid_matches:
                            path = Chem.GetShortestPath(mol, amine_match[0], acid_match[0])
                            # Check if all atoms in path are aliphatic carbons (non-aromatic carbons)
                            aliphatic = True
                            carbon_count = 0
                            for atom_idx in path:
                                atom = mol.GetAtomWithIdx(atom_idx)
                                if atom.GetAtomicNum() == 6:  # Carbon
                                    if atom.GetIsAromatic():
                                        aliphatic = False
                                        break
                                    else:
                                        carbon_count += 1
                                elif atom.GetAtomicNum() in [7, 8, 1]:  # N, O, or H
                                    continue
                                else:
                                    aliphatic = False
                                    break
                            if aliphatic:
                                # Exclude the N and C atoms from the chain length count
                                chain_length = carbon_count - 1  # Subtract one if we want bonds between carbons
                                chain_lengths.append(chain_length)
                    if chain_lengths:
                        min_chain_length = min(chain_lengths)
                        if rule['chain_length_bounds']['high'][0] <= min_chain_length <= rule['chain_length_bounds']['high'][1]:
                            row.append(rule['predictions']['high'])
                        elif rule['chain_length_bounds']['low'][0] <= min_chain_length:
                            row.append(rule['predictions']['low'])
                        else:
                            row.append(0)
                    else:
                        row.append(0)
                elif rule['number'] == 2:
                    # Rule 2 implementation
                    benzoic_matches = mol.GetSubstructMatches(rule['benzoic_acid_pattern'])
                    if benzoic_matches:
                        high = False
                        low = False
                        # Check for coordinating groups
                        for patt in rule['para_coordinating_patterns']:
                            if mol.HasSubstructMatch(patt):
                                high = True
                                break
                        # Check for non-coordinating groups
                        if not high:
                            for patt in rule['para_non_coordinating_patterns']:
                                if mol.HasSubstructMatch(patt):
                                    low = True
                                    break
                        if high:
                            row.append(rule['predictions']['high'])
                        elif low:
                            row.append(rule['predictions']['low'])
                        else:
                            row.append(0)
                    else:
                        row.append(0)
                elif rule['number'] == 3:
                    # Rule 3 implementation
                    if mol.HasSubstructMatch(rule['pattern']):
                        # Check for heterocyclic ring
                        if mol.HasSubstructMatch(rule['heterocycle_pattern']):
                            row.append(rule['prediction'])
                        else:
                            row.append(0)
                    else:
                        row.append(0)
                elif rule['number'] == 4:
                    # Rule 4 implementation
                    if mol.HasSubstructMatch(rule['long_chain_acid_pattern']):
                        if mol.HasSubstructMatch(rule['amino_substituted_pattern']):
                            row.append(rule['predictions']['low'])
                        else:
                            row.append(rule['predictions']['high'])
                    else:
                        row.append(0)
                else:
                    # Default case for other rules not implemented
                    row.append(0)
            except Exception:
                # In case of any error, append 0
                row.append(0)
        results.append(row)

    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])
    return df

---------------------------------------------------------------
Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
1,0,0,0
0,0,0,0
0,0,0,1
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,1,0
0,0,0,0
0,-1,0,0
0,0,0,0
0,-1,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,0
0,0,0,1
0,0,0,1
0,0,0,0
-1,0,0,-1
-1,0,0,0
0,0,0,0
-1,0,0,-1


---------------------------------------------------------------
Matrix Checker Message:
- **Suggestion 3**: **Generalize the SMARTS Patterns in Rule 2**

  The SMARTS patterns for para-substituted benzoic acids with coordinating and non-coordinating groups are too specific. Generalize the patterns to match any para-substituted benzoic acid with metal-coordinating groups (e.g., `[NX3;H2,H1,H0]`, `[OX1-,OX2]`, `[SX2]`) and non-coordinating groups (e.g., alkyl, aldehyde). Use wildcard patterns or specify properties (like donor atoms) to capture a broader range of substituents.


---------------------------------------------------------------
Rule Generator Message:
- **Rule 2**: **Para-Substituted Benzoic Acids with Electron-Withdrawing, Metal-Coordinating Groups Yield High; Electron-Donating or Non-Coordinating Groups Yield Low**

  Modifiers that are benzoic acid derivatives with electron-withdrawing substituents at the para position capable of coordinating with metal centers (e.g., amino, nitro, bromomethyl) result in high yield. Those with electron-donating groups (e.g., methyl, methoxy) or non-coordinating substituents yield low. Coordination enhances interaction with the catalyst.

  *Examples:*

    - **High Yield:**
      - 4-aminobenzoic acid
      - 4-nitrobenzoic acid
      - 4-(bromomethyl)benzoic acid
    - **Low Yield:**
      - 4-methylbenzoic acid
      - 4-formylbenzoic acid
      - 4-sulfanylbenzoic acid

---------------------------------------------------------------
Rule Commenter Message:
- **Comment 2**: Rule 2 is well-defined, focusing on para-substituted benzoic acids with electron-withdrawing, metal-coordinating groups yielding high, and those with electron-donating or non-coordinating groups yielding low. It offers solid physical-chemical insight into how electron-withdrawing substituents enhance metal coordination. The rule effectively balances complexity and coverage, supported by multiple data points that validate its applicability.
- **Comment 13**: Rule 13 overlaps with Rule 2, focusing on aromatic rings with amino groups adjacent to carboxylic acids yielding high. While it provides adequate physical-chemical insight into enhanced metal coordination, the rule's coverage is limited to a single data point. The redundancy and minimal support reduce its added value beyond what is already covered in Rule 2.


---------------------------------------------------------------
Rule Advisor Message:

- **Advice 1**: **Clarify and Correct Rule 2 Regarding Metal Coordination**

  **Issue**: Rule 2 currently states that para-substituted benzoic acids with electron-withdrawing, metal-coordinating groups yield high, while electron-donating or non-coordinating groups yield low. However, there is inconsistency because 4-aminobenzoic acid (an electron-donating group) yields high.

  **Suggestion**:

  - **Focus on Metal-Coordinating Ability**: Redefine the rule to emphasize that substituents capable of coordinating with metal centers (regardless of their electron-donating or -withdrawing nature) lead to high yield.
  - **Remove Conflicting Information**: Eliminate references to electron-donating or -withdrawing properties that do not align with the observed data.
  - **Practical Implementation**: Adjust the rule to state:

    > **Rule 2 (Revised)**: **Para-Substituted Benzoic Acids with Metal-Coordinating Groups Yield High; Non-Coordinating Groups Yield Low**

    This focuses on the presence of functional groups (e.g., amino, nitro, bromomethyl) that can coordinate with the metal catalyst, leading to high yield.

- **Advice 5**: **Enhance Physical-Chemical Insights in Rules**

  **Issue**: Some rules lack detailed explanations, which can limit understanding and application.

  **Suggestion**:

  - **Include Mechanistic Rationale**: Add explanations on how specific groups influence the reaction, such as electronic effects, steric hindrance, or solubility factors.
  - **Link to Catalyst Interaction**: Describe how modifiers affect the coordination environment of the metal center.

  **Practical Implementation**:

  - For each rule, include a brief discussion of the underlying chemistry.
  - For example, in the revised Rule 2, explain that metal-coordinating groups can form coordination bonds with the Fe center, enhancing catalytic activity.


- **Advice 7**: **Include Structural Features in SMILES-Based Rules**

  **Issue**: To practically apply the rules, specific structural identifiers need to be translated into SMILES patterns.

  **Suggestion**:

  - **Define SMILES Substructures**: For each rule, specify the SMILES patterns corresponding to the functional groups or motifs described.
  - **Use SMARTS Notation for Substructures**: Incorporate SMARTS patterns to identify functional groups within SMILES strings.

  **Practical Implementation**:

  - For example, in the revised Rule 2:

    - Metal-coordinating groups can be identified by SMARTS patterns for amino (`[NH2]`), nitro (`[N+](=O)[O-]`), or bromomethyl (`[CH2]Br`) substituents at the para position.
  
  - Provide these patterns alongside the rules to facilitate computational screening.



---------------------------------------------------------------\
Matrix Generator Message:
Code for rules:
def rule2matrix(smiles_list):
    # Number of rules
    num_rules = 15  # There are 15 rules as provided
    # Initialize results list
    results = []
    # Define SMARTS patterns and logic for each rule
    # Rule 2 patterns for high yield substituents
    amino_group = Chem.MolFromSmarts('[NX3;H2,H1]')  # Primary or secondary amine
    nitro_group = Chem.MolFromSmarts('[NX3](=O)=O')  # Nitro group
    bromomethyl_group = Chem.MolFromSmarts('CBr')     # Bromomethyl group


    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*num_rules)
            continue
        row = []
        # Rule 2
        try:
            value = check_rule2(mol, amino_group, nitro_group, bromomethyl_group)
            row.append(value)
        except Exception:
            row.append(0)

        # For remaining rules, append 0 or implement similar logic
        # Fill remaining rules with zeros for now
        while len(row) < num_rules:
            row.append(0)

    # Create DataFrame with results
    columns = [f'Rule {i+1}' for i in range(num_rules)]
    df = pd.DataFrame(results, columns=columns)
    return df


# Define the functions for each rule
def check_rule2(mol, amino_group, nitro_group, bromomethyl_group):
    # Rule 2: Para-Substituted Benzoic Acids with EW and Coordinating Groups Yield High
    # Electron-Withdrawing, Metal-Coordinating Groups at para position result in high yield
    # Electron-Donating or Non-Coordinating Groups yield low
    # Identify benzoic acid core
    benzoic_acid = Chem.MolFromSmarts('c1ccc(cc1)C(=O)[O;H1,-]')
    if not mol.HasSubstructMatch(benzoic_acid):
        return 0
    # Identify para-substituted benzoic acids
    para_substituted = Chem.MolFromSmarts('c1cc([#6,#7,#8,#9,#16,#17,#35,#53])ccc1C(=O)[O;H1,-]')
    if not mol.HasSubstructMatch(para_substituted):
        return 0
    # Now check if substituent is EWG capable of coordination (amino, nitro, bromomethyl)
    if mol.HasSubstructMatch(amino_group) or mol.HasSubstructMatch(nitro_group) or mol.HasSubstructMatch(bromomethyl_group):
        return 1  # High yield
    else:
        return -1  # Low yield


---------------------------------------------------------------
Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10,Rule 11,Rule 12,Rule 13,Rule 14,Rule 15
0,0,0,-1,0,0,-1,0,0,0,0,0,0,0,0
1,0,0,-1,1,0,0,0,0,0,0,0,0,0,0
0,1,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,1,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0
0,1,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,1,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,1,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,1,0,0,0,0,0,0,0,0,0,0
0,-1,0,-1,0,1,0,0,0,0,0,0,0,0,0
0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,-1,0,-1,0,0,0,0,0,0,0,0,0,0,0
-1,0,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,-1,0,-1,0,0,0,0,0,0,0,0
-1,0,1,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,-1,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,0,1,0,0,0,0,0,0,0,0,0
0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,-1,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,-1,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,-1,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,1,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,1,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,1,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0
1,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0
0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0
