    {{
        "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit.",
        "imports": "import pandas as pd\\nfrom rdkit import Chem\\nfrom rdkit.Chem import AllChem",
        "code": "def rule2matrix(smiles_list):\\n    rules = [ ['[CX3](=O)[OX2H1]', '[#7]',], # Rule 1 ['[CX3](=O)[OX2H1]', '[C;X4][C;X4][C;X4][C;X4][C;X4][C;X4]',], # Rule 2 ['[c][CX3](=O)[OX2H1]',], # Rule 3 ...]\\n    results = []\\n  
        for smi in smiles_list:  \\n
        mol = Chem.MolFromSmiles(smi) if mol is None: \\n results.append([0] * len(rules)) \\n continue
        row = [] for i, rule in enumerate(rules): try: if all(mol.HasSubstructMatch(Chem.MolFromSmarts(r)) for r in rule): if i in [0, 2, 3, 4, 5, ...]:#Rules with high prediction \\n row.append(1) \\n else: \\n row.append(-1) \\n else: \\n row.append(0) \\n except: \n row.append(0)
        results.append(row)
        df = pd.DataFrame(results, columns=[f'Rule {{i+1}}' for i in range(len(rules))])
        return df"
    }}
    
    
    
    def rule2matrix(smiles_list):
    rules = [
        {
            'name': 'Rule 1',
            'smarts': ['[NX3H2]-[*]-[*]-[*]-[CX3](=O)[OX2H1]'],
            'prediction': 1
        },
        {
            'name': 'Rule 2',
            'smarts': ['c1ccc(cc1)C(=O)O', 'C(=O)O-c1ccc(cc1)[N+](=O)[O-]', 'C(=O)O-c1ccc(cc1)Br'],
            'prediction': 1
        },
        {
            'name': 'Rule 3',
            'smarts': ['C(=O)O-c1ccc(cc1)[OH]', 'C(=O)O-c1ccc(cc1)N', 'C(=O)O-c1ccc(cc1)C'],
            'prediction': -1
        },
        {
            'name': 'Rule 4',
            'smarts': ['[SX2H]-[*]', '[SX2H]-c1ccccc1'],
            'prediction': 1
        },
        {
            'name': 'Rule 5',
            'smarts': ['[CX3](=O)[OX2H1]-[*]-[*]-[*]-[OX2H]'],
            'prediction': 1
        },
        {
            'name': 'Rule 6',
            'smarts': ['[CX3](=O)[OX2H1]-[*]-[*]-[*]-[*]-[*]-[*]-[*]'],
            'exclude': ['[NX3,NX4]', '[OX2H]', '[SX2H]'],
            'prediction': -1
        },
        {
            'name': 'Rule 7',
            'smarts': ['[CX3](=O)[OX2H1]-[*]-[*]-[*]-[OH]', '[CX3](=O)[OX2H1]-[*]-[OH]', '[OH]-[*]-[OH]'],
            'prediction': -1
        },
        {
            'name': 'Rule 8',
            'smarts': ['[CX3](=O)[OX2H1]-c1ncccc1', '[CX3](=O)[OX2H1]-c1ncncc1'],
            'prediction': -1
        },
        {
            'name': 'Rule 9',
            'smarts': ['[CX3](=O)[OX2H1]-[*]-O-[*]-[*]-O-[*]'],
            'prediction': 1
        },
        {
            'name': 'Rule 10',
            'smarts': ['[NX3H2]-[CX2]-[CX3](=O)[OX2H1]', '[NX3H2]-[CX2]-[Ph]'],
            'prediction': 1
        },
        {
            'name': 'Rule 11',
            'smarts': ['[NX3H2]-[CX2]-c1c[nH]c2c1cccc2'],
            'prediction': -1
        },
        {
            'name': 'Rule 12',
            'smarts': ['C(=O)O-CF'],
            'prediction': -1
        },
        {
            'name': 'Rule 13',
            'smarts': ['[CX3](=O)[CX3](=O)[OX2H1]'],
            'prediction': -1
        },
        {
            'name': 'Rule 14',
            'smarts': ['[CX3](=O)-c1ccco1', '[CX3](=O)-c1ccccc1O'],
            'prediction': -1
        },
        {
            'name': 'Rule 15',
            'smarts': ['[CX3](=O)[OX2H1]-[*]-c1ccccc1', '[CX3](=O)[OX2H1]-[*]-[C](=[OX1])[NX3]'],
            'prediction': -1
        }
    ]

    results = []
    rule_names = [rule['name'] for rule in rules]

    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        row = []
        if mol is None:
            row = [0]*len(rules)
        else:
            for rule in rules:
                try:
                    match = False
                    for smarts in rule['smarts']:
                        patt = Chem.MolFromSmarts(smarts)
                        if patt is None:
                            continue
                        if mol.HasSubstructMatch(patt):
                            match = True
                            break
                    if 'exclude' in rule and match:
                        for excl_smarts in rule['exclude']:
                            excl_patt = Chem.MolFromSmarts(excl_smarts)
                            if excl_patt is None:
                                continue
                            if mol.HasSubstructMatch(excl_patt):
                                match = False
                                break
                    if match:
                        row.append(rule['prediction'])
                    else:
                        row.append(0)
                except:
                    row.append(0)
        results.append(row)

    df = pd.DataFrame(results, columns=rule_names)
    return df


--------------------------------------------------------------


def rule2matrix(smiles_list):
    rules = [
        # Rule 1: High (1)
        {
            'name': 'Rule 1',
            'patterns': [
                '[NX3H2,NX4H3+0;!$([N][a])]',  # Primary aliphatic amine not attached to aromatic ring
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
            ],
            'prediction': 1,
        },
        # Rule 2: Low (-1)
        {
            'name': 'Rule 2',
            'patterns': [
                '[NX3H2,NX3H1;$(N[c])]',  # Amine attached to aromatic ring
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
            ],
            'prediction': -1,
        },
        # Rule 3: High (1)
        {
            'name': 'Rule 3',
            'patterns': [
                '[#16X2,#16X2H]',  # Thiols (-SH) or thioethers (-S-)
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
            ],
            'prediction': 1,
        },
        # Rule 4: Low (-1)
        {
            'name': 'Rule 4',
            'patterns': [
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
            ],
            'count': {'[OX2H;!$(O=C[O,H])]': 2},  # At least two hydroxyl groups excluding those attached to carbonyl carbons
            'prediction': -1,
        },
        # Rule 5: High (1)
        {
            'name': 'Rule 5',
            'patterns': [
                '[OD2]([#6])[#6]',  # Ether linkage (-O-)
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
            ],
            'prediction': 1,
        },
        # Rule 6: Low (-1)
        {
            'name': 'Rule 6',
            'patterns': [
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
                '[CX4][CX4][CX4][CX4]',  # Long aliphatic chain
            ],
            'prediction': -1,
        },
        # Rule 7: High (1)
        {
            'name': 'Rule 7',
            'patterns': [
                '[c][F,Cl,Br,I,N+](=O)[O-]',  # Aromatic ring with electron-withdrawing group
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
            ],
            'prediction': 1,
        },
        # Rule 8: Low (-1)
        {
            'name': 'Rule 8',
            'patterns': [
                '[c][CX3](=O)[NX3]',  # Amide group attached to aromatic ring
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
            ],
            'prediction': -1,
        },
        # Rule 9: High (1)
        {
            'name': 'Rule 9',
            'patterns': [
                '[n]',  # Nitrogen heterocycles
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
            ],
            'prediction': 1,
        },
        # Rule 10: Low (-1)
        {
            'name': 'Rule 10',
            'patterns': [
                '[CX4][CX4]([CX4](F)(F)F)(F)F',  # Perfluoroalkyl group
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
            ],
            'prediction': -1,
        },
        # Rule 11: High (1)
        {
            'name': 'Rule 11',
            'patterns': [
                '[#6][OX2H,OX2][#6]',  # Hydroxyl group on aliphatic chain
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
            ],
            'prediction': 1,
        },
        # Rule 12: Low (-1)
        {
            'name': 'Rule 12',
            'patterns': [
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
            ],
            'count': {'[CX3](=O)[OX2H1]': 2},  # At least two carboxylic acid groups
            'prediction': -1,
        },
        # Rule 13: High (1)
        {
            'name': 'Rule 13',
            'patterns': [
                '[c][OX2][CH3]',  # Methoxy group on aromatic ring
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
            ],
            'prediction': 1,
        },
        # Rule 14: Low (-1)
        {
            'name': 'Rule 14',
            'patterns': [
                '[c][CX3](=O)[#6]',  # Ketone group attached to aromatic ring
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
            ],
            'prediction': -1,
        },
        # Rule 15: High (1)
        {
            'name': 'Rule 15',
            'patterns': [
                '[#7,#8,#16]',  # Multiple donor atoms (N, O, S)
                '[CX3](=O)[OX2H1]',  # Carboxylic acid group
            ],
            'count': {'[#7,#8,#16]': 2},  # At least two donor atoms
            'prediction': 1,
        },
    ]

        # Compile SMARTS patterns
    for rule in rules:
        compiled_patterns = []
        for smarts in rule.get('patterns', []):
            try:
                compiled = Chem.MolFromSmarts(smarts)
                compiled_patterns.append(compiled)
            except:
                compiled_patterns.append(None)
        rule['compiled_patterns'] = compiled_patterns
        # Compile count patterns if any
        if 'count' in rule:
            compiled_counts = {}
            for smarts, count in rule['count'].items():
                try:
                    compiled_counts[Chem.MolFromSmarts(smarts)] = count
                except:
                    compiled_counts[None] = count
            rule['compiled_counts'] = compiled_counts

    results = []
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            results.append([0] * len(rules))
            continue
        row = []
        for rule in rules:
            try:
                matches = True
                # Check patterns
                for patt in rule['compiled_patterns']:
                    if patt is None or not mol.HasSubstructMatch(patt):
                        matches = False
                        break
                # Check counts if any
                if 'compiled_counts' in rule and matches:
                    for patt, count in rule['compiled_counts'].items():
                        if patt is None:
                            matches = False
                            break
                        if len(mol.GetSubstructMatches(patt)) < count:
                            matches = False
                            break
                if matches:
                    row.append(rule['prediction'])
                else:
                    row.append(0)
            except:
                row.append(0)
        results.append(row)
    df = pd.DataFrame(results, columns=[rule['name'] for rule in rules])
    return df

------------------------------------------------------

def rule2matrix(smiles_list):
    rules = [
        {
            'name': 'Rule 1',
            'smarts': ['[NX3H2,NX3H1;!$([N][!C])]', '[CX3](=O)[OX2H1]'],
            'predict': 1
        },
        {
            'name': 'Rule 2',
            'smarts': ['[c][CX3](=O)[OX2H1]'],
            'not_smarts': ['[NX3,NX2,NX4]', '[SX2,SX1]'],
            'predict': -1
        },
        {
            'name': 'Rule 3',
            'smarts': ['[S;X2]', '[CX3](=O)[OX2H1]'],
            'predict': 1
        },
        {
            'name': 'Rule 4',
            'smarts': ['[OX2H]', '[CX3](=O)[OX2H1]'],
            'count_smarts': {'[OX2H]': 2},
            'predict': -1
        },
        {
            'name': 'Rule 5',
            'smarts': ['[c][CX3](=O)[OX2H1]'],
            'extra_smarts': ['[c][F,Cl,Br,I]', '[c][NX3+](=O)[O-]'],
            'predict': 1
        },
        {
            'name': 'Rule 6',
            'smarts': ['[n][CX4][CX3](=O)[OX2H1]'],
            'predict': 1
        },
        {
            'name': 'Rule 7',
            'smarts': ['[n][CX3](=O)[OX2H1]'],
            'predict': -1
        },
        {
            'name': 'Rule 8',
            'smarts': ['[CX3](=O)[OX2H1]'],
            'not_smarts': ['[NX3,NX2,NX4]', '[SX2,SX1]'],
            'predict': -1
        },
        {
            'name': 'Rule 9',
            'smarts': ['[CX3](=O)[OX2H1]', '[CX4][OX2][CX4]'],
            'predict': 1
        },
        {
            'name': 'Rule 10',
            'smarts': ['[c][CX3](=O)[OX2H1]', '[NX3][CX3](=O)[OX2H1]'],
            'predict': -1
        },
    ]
    results = []
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            results.append([0] * len(rules))
            continue
        row = []
        for rule in rules:
            try:
                matches = True
                # Check required SMARTS patterns
                for pattern in rule.get('smarts', []):
                    patt = Chem.MolFromSmarts(pattern)
                    if not mol.HasSubstructMatch(patt):
                        matches = False
                        break
                # Check count of SMARTS patterns if applicable
                if matches and 'count_smarts' in rule:
                    for pattern, count_required in rule['count_smarts'].items():
                        patt = Chem.MolFromSmarts(pattern)
                        matches_list = mol.GetSubstructMatches(patt)
                        if len(matches_list) < count_required:
                            matches = False
                            break
                # Check exclusion SMARTS patterns
                if matches:
                    for pattern in rule.get('not_smarts', []):
                        patt = Chem.MolFromSmarts(pattern)
                        if mol.HasSubstructMatch(patt):
                            matches = False
                            break
                # Check extra SMARTS patterns (one of them must match)
                if matches and 'extra_smarts' in rule:
                    extra_matches = False
                    for pattern in rule['extra_smarts']:
                        patt = Chem.MolFromSmarts(pattern)
                        if mol.HasSubstructMatch(patt):
                            extra_matches = True
                            break
                    if not extra_matches:
                        matches = False
                # Append predict value if matches, else 0
                if matches:
                    row.append(rule['predict'])
                else:
                    row.append(0)
            except:
                row.append(0)
        results.append(row)
    df = pd.DataFrame(results, columns=[rule['name'] for rule in rules])
    return df

---------------------------------------------------------------------------