{
    "prefix": "This code defines a function `rule2matrix` that takes a list of SMILES strings and converts them into a feature matrix using RDKit. The function applies a set of SMARTS-based rules derived from the provided natural language descriptions to each SMILES string to determine the presence of specific structural features associated with either high or low Fe/Hf values. Each rule corresponds to a column in the output DataFrame, with values 1, -1, or 0 depending on whether the rule predicts a high value, low value, or does not match, respectively.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and structural features\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    # Primary aliphatic amine group (-NH2)\n    primary_aliph_amine = '[NX3;H2][CX4]'\n    # Aliphatic chain (non-aromatic carbons)\n    aliphatic_chain = '[CX4]'\n    # Thiol group (-SH)\n    thiol_group = '[SX2H]'\n    # Thioether group (-S-)\n    thioether_group = '[#16X2][#6]'\n    # Ether linkage (-O-)\n    ether_linkage = '[#6][OX2][#6]'\n    # Pyridine ring connected via aliphatic linker\n    pyridine_aliphatic_linker = '[#6]-[#6]-n1ccccc1'\n    # Pyridine ring directly attached\n    pyridine_direct = 'n1ccccc1'\n    # Halogen or nitro group on aromatic ring\n    electron_withdrawing_groups = ['[c][F,Cl,Br,I]', '[c][NX3](=O)[O-]']\n    # Electron-donating groups on aromatic ring\n    electron_donating_groups = ['[c][OX2H]', '[c][OX2][CH3]', '[c][NX3;H2,H1][#6]']\n    # Terminal hydroxyl group on aliphatic chain (-OH)\n    terminal_hydroxyl = '[CX4][CX4][OX2H]'\n    # Phenolic hydroxyl group (-OH on aromatic ring)\n    phenolic_oh = '[c][OX2H]'\n    # Aldehyde group (-CHO)\n    aldehyde_group = '[CX3H1](=O)[#6]'\n    # Pyrazole ring directly attached to carboxyl group\n    pyrazole_carboxylic_acid = 'n1nccc1C(=O)O'\n    # Conjugated dicarbonyl systems\n    conjugated_dicarbonyl = '[#6]=O[#6]=O'\n    # Fluorinated aliphatic chain\n    fluorinated_chain = '[CX4;H2,H1]([F,Cl,Br,I])[CX4;H2,H1]([F,Cl,Br,I])[CX4;H2,H1]([F,Cl,Br,I])'\n    # Bulky aromatic side chain (e.g., tryptophan)\n    bulky_aromatic_side_chain = '[NX3;H2][CX4H]([#6])[c]'\n    \n    # Define the rules with their associated patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are omega-amino acids\u2014aliphatic carboxylic acids with a terminal amino group (-NH2) at the opposite end of the chain\u2014result in a high Fe/Hf value.',\n            'patterns': [\n                carboxylic_acid,\n                primary_aliph_amine,\n                aliphatic_chain\n            ],\n            'logic': 'AND',\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers that are amino acids or amino acid derivatives with short aliphatic side chains result in a high Fe/Hf value. Those with bulky or aromatic side chains result in a low Fe/Hf value.',\n            'patterns': [\n                '[NX3;H2][CX4H]([CX4H2])[C](=O)[OX2H1]'  # Amino acid with short side chain\n            ],\n            'exclude_patterns': [\n                bulky_aromatic_side_chain\n            ],\n            'logic': 'AND',\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers containing sulfur-containing groups such as thiol (-SH) or thioether (-S-) groups in proximity to a carboxyl group result in a high Fe/Hf value.',\n            'patterns': [\n                carboxylic_acid,\n                [thiol_group, thioether_group]  # Either thiol or thioether\n            ],\n            'logic': 'AND',\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers that are aromatic carboxylic acids with electron-withdrawing substituents (e.g., nitro (-NO2), halomethyl (-CH2X)) on the aromatic ring result in a high Fe/Hf value. Those with electron-donating substituents result in a low Fe/Hf value.',\n            'patterns': [\n                carboxylic_acid,\n                electron_withdrawing_groups\n            ],\n            'exclude_patterns': electron_donating_groups,\n            'logic': 'AND',\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers with a pyridine ring connected to a carboxyl group via an aliphatic linker result in a high Fe/Hf value. If the pyridine ring is directly attached to the carboxyl group, it results in a low Fe/Hf value.',\n            'patterns': [\n                carboxylic_acid,\n                pyridine_aliphatic_linker\n            ],\n            'exclude_patterns': [\n                pyridine_direct + carboxylic_acid\n            ],\n            'logic': 'AND',\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers featuring flexible ether linkages (-O-) with terminal amino groups (-NH2) result in a high Fe/Hf value.',\n            'patterns': [\n                carboxylic_acid,\n                ether_linkage,\n                primary_aliph_amine\n            ],\n            'logic': 'AND',\n            'prediction': 1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers that are aliphatic carboxylic acids with a terminal hydroxyl group (-OH) on the aliphatic chain result in a high Fe/Hf value. If the hydroxyl group is attached to an aromatic ring (phenolic), the Fe/Hf value is low.',\n            'patterns': [\n                carboxylic_acid,\n                terminal_hydroxyl\n            ],\n            'exclude_patterns': [\n                phenolic_oh\n            ],\n            'logic': 'AND',\n            'prediction': 1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers containing multiple coordinating groups in a conjugated system, such as dicarbonyls or fused rings with carbonyl groups, result in a high Fe/Hf value.',\n            'patterns': [\n                conjugated_dicarbonyl\n            ],\n            'logic': 'AND',\n            'prediction': 1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers that are simple aliphatic carboxylic acids without additional coordinating functional groups result in a low Fe/Hf value.',\n            'patterns': [\n                carboxylic_acid\n            ],\n            'exclude_patterns': [\n                primary_aliph_amine,\n                thiol_group,\n                thioether_group,\n                ether_linkage,\n                terminal_hydroxyl\n            ],\n            'logic': 'AND',\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers containing strong electron-withdrawing fluorine atoms on an aliphatic chain result in a low Fe/Hf value.',\n            'patterns': [\n                carboxylic_acid,\n                fluorinated_chain\n            ],\n            'logic': 'AND',\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers that are amino acids with bulky aromatic side chains result in a low Fe/Hf value.',\n            'patterns': [\n                bulky_aromatic_side_chain\n            ],\n            'logic': 'AND',\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers that are aromatic carboxylic acids substituted with electron-donating groups at the ortho or para positions result in a low Fe/Hf value.',\n            'patterns': [\n                carboxylic_acid,\n                electron_donating_groups\n            ],\n            'logic': 'AND',\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers containing an aldehyde group (-CHO) in addition to a carboxyl group result in a low Fe/Hf value.',\n            'patterns': [\n                carboxylic_acid,\n                aldehyde_group\n            ],\n            'logic': 'AND',\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers with a pyrazole ring directly attached to a carboxyl group result in a low Fe/Hf value.',\n            'patterns': [\n                pyrazole_carboxylic_acid\n            ],\n            'logic': 'AND',\n            'prediction': -1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers with bulky substituents or extensive conjugation that do not provide additional coordinating atoms result in a low Fe/Hf value.',\n            'patterns': [\n                '[c]=[c]-[c]=[c]-[c]=[c]'  # Extensive conjugation\n            ],\n            'exclude_patterns': [\n                primary_aliph_amine,\n                thiol_group,\n                thioether_group,\n                ether_linkage\n            ],\n            'logic': 'AND',\n            'prediction': -1\n        }\n    ]\n\n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for pat in rule.get('patterns', []):\n            if isinstance(pat, list):\n                sub_patterns = [Chem.MolFromSmarts(p) for p in pat]\n                compiled_patterns.append(sub_patterns)\n            else:\n                compiled_patterns.append(Chem.MolFromSmarts(pat))\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for pat in rule['exclude_patterns']:\n                compiled_excludes.append(Chem.MolFromSmarts(pat))\n            rule['compiled_exclude_patterns'] = compiled_excludes\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'compiled_exclude_patterns' in rule:\n                    for ex_pat in rule['compiled_exclude_patterns']:\n                        if mol.HasSubstructMatch(ex_pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for pat in rule['compiled_patterns']:\n                    if isinstance(pat, list):\n                        # Group of patterns (OR logic within the group)\n                        group_match = False\n                        for sub_pat in pat:\n                            if mol.HasSubstructMatch(sub_pat):\n                                group_match = True\n                                break\n                        match = match and group_match\n                    else:\n                        if not mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f\"Rule {rule['number']}\" for rule in rules])\n    return df\n"
}