{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit. It applies the provided rules to each molecule to determine if it matches the structural criteria specified. Each rule corresponds to a column in the resulting DataFrame, and each SMILES string corresponds to a row. A value of 1 indicates the molecule matches a rule predicting a high target value, -1 indicates a match predicting a low target value, and 0 indicates no match.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    \n    # Primary amine group (-NH2)\n    primary_amine = '[NX3H2]'\n    \n    # Hydroxyl group (-OH)\n    hydroxyl_group = '[OX2H]'\n    \n    # Aliphatic chain of five or more carbons\n    aliphatic_chain_five_or_more = '[CH2][CH2][CH2][CH2][CH2]'\n    \n    # Aromatic carboxylic acid (benzoic acid)\n    aromatic_carboxylic_acid = '[c][CX3](=O)[OX2H1]'\n    \n    # Electron-withdrawing groups (EWGs)\n    nitro_group = '[NX3](=O)=O'  # Nitro group\n    halogen = '[F,Cl,Br,I]'\n    halomethyl = '[CX4][F,Cl,Br,I]'\n    sulfanyl = '[SX2H]'\n    \n    # Electron-donating groups (EDGs)\n    amino_group = '[NX3H2]'\n    methoxy_group = '[OX2][CH3]'\n    \n    # Pyridine ring\n    pyridine_ring = 'n1ccccc1'\n    \n    # Sulfur-containing groups\n    thiol = '[SX2H]'  # Thiol group\n    thioether = '[#16X2][#6]'  # Thioether group\n    \n    # Ether linkage in aliphatic chains (-O-CH2-CH2-)\n    ether_linkage = '[OX2][CH2][CH2]([OX2][CH2][CH2]){2}[OX2]'  # Simplified pattern for multiple ether units\n    \n    # Alpha-amino acid with side-chain carboxylate close to alpha-carbon\n    aspartic_acid_like = '[NX3][CX4H]([CX3](=O)[OX2H1])[CX3](=O)[OX2H1]'\n    \n    # Multiple adjacent hydroxyl groups\n    polyol = '[OX2H][CX4][OX2H][CX4][OX2H]'\n    \n    # Aromatic hydroxyl group\n    aromatic_hydroxyl = '[c][OX2H]'\n    \n    # Amino group attached to aromatic ring\n    aromatic_amino = '[c][NX3H2]'\n    \n    # Rules definition\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are aliphatic carboxylic acids with a terminal primary amino group (-NH2) or hydroxyl group (-OH) at the omega-position, and a carbon chain length of at least five carbons.',\n            'patterns': [\n                [carboxylic_acid],\n                [primary_amine, hydroxyl_group],\n                [aliphatic_chain_five_or_more]\n            ],\n            'smarts_logic': 'custom',\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers that are aromatic carboxylic acids with strong electron-withdrawing groups (EWGs) at the para position (e.g., nitro, halomethyl, sulfanyl).',\n            'patterns': [\n                [aromatic_carboxylic_acid],\n                [nitro_group, halomethyl, sulfanyl]\n            ],\n            'smarts_logic': 'custom',\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers that are aromatic carboxylic acids containing a pyridine ring with an accessible nitrogen atom.',\n            'patterns': [\n                [pyridine_ring],\n                [carboxylic_acid]\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers containing sulfur atoms in functional groups such as thiol (-SH) or thioether (-S-) within close proximity to the carboxylate group.',\n            'patterns': [\n                [carboxylic_acid],\n                [thiol, thioether]\n            ],\n            'smarts_logic': 'custom',\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers that are aliphatic carboxylic acids with flexible polyether chains and terminal amino (-NH2) or other coordinating groups.',\n            'patterns': [\n                [carboxylic_acid],\n                [ether_linkage],\n                [primary_amine, hydroxyl_group]\n            ],\n            'smarts_logic': 'custom',\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers that are aromatic carboxylic acids with electron-donating groups (EDGs) such as amino (-NH2) or hydroxyl (-OH) directly attached to the ring.',\n            'patterns': [\n                [aromatic_carboxylic_acid],\n                [aromatic_amino, aromatic_hydroxyl]\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers that are aliphatic carboxylic acids lacking additional coordinating groups or electron-withdrawing substituents.',\n            'patterns': [\n                [carboxylic_acid]\n            ],\n            'exclude_patterns': [\n                [primary_amine, hydroxyl_group, thiol, methoxy_group]\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers with multiple adjacent hydroxyl groups (polyols) near the carboxylate group.',\n            'patterns': [\n                [carboxylic_acid],\n                [polyol]\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers that are alpha-amino acids with side-chain carboxylate groups close to the alpha-carbon.',\n            'patterns': [\n                [aspartic_acid_like]\n            ],\n            'prediction': 1\n        }\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for group in rule.get('patterns', []):\n            compiled_group = [Chem.MolFromSmarts(p) for p in group]\n            compiled_patterns.append(compiled_group)\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for group in rule['exclude_patterns']:\n                compiled_group = [Chem.MolFromSmarts(p) for p in group]\n                compiled_excludes.append(compiled_group)\n            rule['compiled_exclude_patterns'] = compiled_excludes\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Custom logic for certain rules\n                if rule.get('smarts_logic') == 'custom':\n                    if rule['number'] == 1:\n                        # Rule 1 custom logic\n                        # Check for carboxylic acid group\n                        if not mol.HasSubstructMatch(Chem.MolFromSmarts(carboxylic_acid)):\n                            match = False\n                        else:\n                            # Check for terminal primary amine or hydroxyl group\n                            terminal_groups = [primary_amine, hydroxyl_group]\n                            terminal_match = False\n                            for pat in terminal_groups:\n                                termini = mol.GetSubstructMatches(Chem.MolFromSmarts(pat))\n                                for term in termini:\n                                    atom = mol.GetAtomWithIdx(term[0])\n                                    if len(atom.GetNeighbors()) == 1:\n                                        terminal_match = True\n                                        break\n                                if terminal_match:\n                                    break\n                            if not terminal_match:\n                                match = False\n                            else:\n                                # Check for aliphatic chain of at least five carbons\n                                # Simplified by checking the total number of carbon atoms\n                                num_carbons = sum(1 for atom in mol.GetAtoms() if atom.GetAtomicNum() == 6 and not atom.IsInRing())\n                                if num_carbons < 5:\n                                    match = False\n                        row.append(rule['prediction'] if match else 0)\n                        continue\n                    elif rule['number'] == 2:\n                        # Rule 2 custom logic\n                        # Check for aromatic carboxylic acid\n                        if not mol.HasSubstructMatch(Chem.MolFromSmarts(aromatic_carboxylic_acid)):\n                            match = False\n                        else:\n                            # Check for EWG at para position\n                            ewg_patterns = [nitro_group, halomethyl, sulfanyl]\n                            ewg_match = False\n                            for ewg in ewg_patterns:\n                                # We're approximating para position by checking if EWG is connected to aromatic ring\n                                if mol.HasSubstructMatch(Chem.MolFromSmarts(f'[c][c]([c][c][c]{ewg})[c][CX3](=O)[OX2H1]')):\n                                    ewg_match = True\n                                    break\n                            if not ewg_match:\n                                match = False\n                        row.append(rule['prediction'] if match else 0)\n                        continue\n                    elif rule['number'] == 4:\n                        # Rule 4 custom logic\n                        # Check for carboxylic acid group\n                        if not mol.HasSubstructMatch(Chem.MolFromSmarts(carboxylic_acid)):\n                            match = False\n                        else:\n                            # Check for sulfur-containing group within 3 bonds of carboxylic acid\n                            sulfur_groups = [thiol, thioether]\n                            carboxy_matches = mol.GetSubstructMatches(Chem.MolFromSmarts(carboxylic_acid))\n                            sulfur_matches = []\n                            for pat in sulfur_groups:\n                                sulfur_matches.extend(mol.GetSubstructMatches(Chem.MolFromSmarts(pat)))\n                            sulfur_near_carboxy = False\n                            for c_match in carboxy_matches:\n                                c_atom_idx = c_match[0]\n                                for s_match in sulfur_matches:\n                                    s_atom_idx = s_match[0]\n                                    path_length = Chem.rdmolops.GetShortestPath(mol, c_atom_idx, s_atom_idx)\n                                    if len(path_length) - 1 <= 3:\n                                        sulfur_near_carboxy = True\n                                        break\n                                if sulfur_near_carboxy:\n                                    break\n                            if not sulfur_near_carboxy:\n                                match = False\n                        row.append(rule['prediction'] if match else 0)\n                        continue\n                    elif rule['number'] == 5:\n                        # Rule 5 custom logic\n                        # Check for carboxylic acid group\n                        if not mol.HasSubstructMatch(Chem.MolFromSmarts(carboxylic_acid)):\n                            match = False\n                        else:\n                            # Check for ether linkage\n                            if not mol.HasSubstructMatch(Chem.MolFromSmarts(ether_linkage)):\n                                match = False\n                            else:\n                                # Check for terminal amino or hydroxyl group\n                                terminal_groups = [primary_amine, hydroxyl_group]\n                                terminal_match = False\n                                for pat in terminal_groups:\n                                    termini = mol.GetSubstructMatches(Chem.MolFromSmarts(pat))\n                                    for term in termini:\n                                        atom = mol.GetAtomWithIdx(term[0])\n                                        if len(atom.GetNeighbors()) == 1:\n                                            terminal_match = True\n                                            break\n                                    if terminal_match:\n                                        break\n                                if not terminal_match:\n                                    match = False\n                        row.append(rule['prediction'] if match else 0)\n                        continue\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for group in rule['compiled_exclude_patterns']:\n                        for pat in group:\n                            if mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                        if not match:\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for compiled_group in rule['compiled_patterns']:\n                    group_match = False\n                    for pat in compiled_group:\n                        if mol.HasSubstructMatch(pat):\n                            group_match = True\n                            break\n                    if not group_match:\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df"
}