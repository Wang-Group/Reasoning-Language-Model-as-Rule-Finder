{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. Each SMILES string is analyzed according to a set of predefined rules based on SMARTS patterns. These rules predict whether the structural descriptions match certain functional groups or substructures associated with high or low Fe/Hf values. The output is a DataFrame where each column corresponds to one rule, and each row corresponds to one SMILES string from the input list. A value of 1 indicates that the rule matches the SMILES and predicts a high Fe/Hf value, -1 indicates that the rule matches the SMILES and predicts a low Fe/Hf value, and 0 indicates no match.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    carboxylate_anion = '[CX3](=O)[O-]'\n    \n    # Thiol group (-SH)\n    thiol = '[SX2H]'\n    # Thioether group (-S-)\n    thioether = '[#16X2][$([#6]);!$(S=[O,N])][$([#6]);!$(S=[O,N])]'  # Excludes sulfoxides and sulfones\n    \n    # Primary aliphatic amine (-NH2)\n    primary_amine = '[NX3;H2][C;!$(C=[O,N,S])][C;!$(C=[O,N,S])][C;!$(C=[O,N,S])][C;!$(C=[O,N,S])][C;!$(C=[O,N,S])]'  # Chain of at least 5 carbons\n    \n    # Aromatic carboxylic acid\n    aromatic_carboxylic_acid = '[c][CX3](=O)[OX2H1]'\n    \n    # Electron-withdrawing groups (EWGs) on aromatic ring\n    nitro_group = '[c][NX3](=O)[O-]'\n    bromo_group = '[c][Br]'\n    pyridine_ring = 'n1ccccc1'\n    \n    # Polyether chain (at least two ether linkages)\n    ether_linkage = '[#6][OX2][#6]'\n    \n    # Terminal methoxy group (-OCH3)\n    methoxy_group = '[OX2][CH3]'\n    \n    # Terminal amino group (-NH2)\n    terminal_amino = '[NX3;H2]'\n    \n    # Phenolic hydroxyl group (-OH attached to aromatic ring)\n    phenol = '[c][OX2H]'\n    \n    # Electron-rich heteroaromatic rings\n    indole = 'c1ccc2c(c1)[nH]c3c2cccc3'\n    pyrazole = 'c1cc[nH]n1'\n    pyridone = 'O=C1C=CC=CN1'\n    \n    # Highly fluorinated aliphatic chain\n    fluorinated_chain = '[CX4]([F])([F])([F])'  # Trifluoromethyl group as a marker\n    \n    # Straight-chain aliphatic carboxylic acids without additional functional groups\n    aliphatic_carboxylic_acid = '[CH3][CH2][CH2][CH2][CH2][CH2][CX3](=O)[OX2H1]'  # Octanoic acid example\n    \n    # Multiple carboxylic acid groups without additional coordinating functionalities\n    multiple_carboxylic_acids = '[CX3](=O)[OX2H1].[CX3](=O)[OX2H1]'  # Simplified pattern\n    \n    # Long aliphatic chain terminated with polar groups\n    long_chain_polar_terminal = '[C;!$(C=[O,N,S])]1~[C;!$(C=[O,N,S])]~[C;!$(C=[O,N,S])]~[C;!$(C=[O,N,S])]~[C;!$(C=[O,N,S])]1[OX2H,NX3;H2]'\n    \n    # Sterically hindered carboxylic acid groups\n    steric_hindrance = '[CX3](=O)[OX2H1][C](C)(C)C'  # Tertiary butyl adjacent to COOH\n    \n    # Multiple adjacent hydroxyl groups\n    polyol = '[#6][OX2H][#6][OX2H][#6][OX2H]'  # Three adjacent hydroxyls\n    \n    # Rules definition\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers containing sulfur groups (thiol or thioether) and a carboxylic acid predict high Fe/Hf',\n            'patterns': [[thiol, thioether], [carboxylic_acid, carboxylate_anion]],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers with terminal primary amines on medium to long aliphatic chains predict high Fe/Hf',\n            'patterns': [[primary_amine], [carboxylic_acid, carboxylate_anion]],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Aromatic carboxylic acids with electron-withdrawing substituents predict high Fe/Hf',\n            'patterns': [[aromatic_carboxylic_acid], [nitro_group, bromo_group, pyridine_ring]],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers with polyether chains and terminal polar groups predict high Fe/Hf',\n            'patterns': [[ether_linkage], [methoxy_group, terminal_amino], [carboxylic_acid, carboxylate_anion]],\n            'counts': {ether_linkage: 2},\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers with electron-rich aromatic hydroxyl groups predict low Fe/Hf',\n            'patterns': [[phenol], [carboxylic_acid, carboxylate_anion]],\n            'prediction': -1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers with electron-rich heteroaromatic rings predict low Fe/Hf',\n            'patterns': [[indole, pyrazole, pyridone], [carboxylic_acid, carboxylate_anion]],\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers with highly fluorinated aliphatic chains predict low Fe/Hf',\n            'patterns': [[fluorinated_chain], [carboxylic_acid, carboxylate_anion]],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Straight-chain aliphatic carboxylic acids without additional functional groups predict low Fe/Hf',\n            'patterns': [[aliphatic_carboxylic_acid]],\n            'exclude_patterns': [[thiol, thioether, primary_amine, ether_linkage, phenol]],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers with multiple carboxylic acid groups without additional coordinating functionalities predict low Fe/Hf',\n            'patterns': [[multiple_carboxylic_acids]],\n            'exclude_patterns': [[thiol, thioether, primary_amine, ether_linkage, phenol]],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers with aliphatic chains terminated with polar groups predict high Fe/Hf',\n            'patterns': [[long_chain_polar_terminal], [carboxylic_acid, carboxylate_anion]],\n            'prediction': 1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers with sterically hindered carboxylic acid groups predict low Fe/Hf',\n            'patterns': [[steric_hindrance]],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers with electron-withdrawing groups and additional coordination sites predict high Fe/Hf',\n            'patterns': [[aromatic_carboxylic_acid], [nitro_group, bromo_group, pyridine_ring], [primary_amine, methoxy_group]],\n            'prediction': 1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers with multiple adjacent hydroxyl groups predict low Fe/Hf',\n            'patterns': [[polyol], [carboxylic_acid, carboxylate_anion]],\n            'prediction': -1\n        }\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for group in rule.get('patterns', []):\n            compiled_group = [Chem.MolFromSmarts(p) for p in group]\n            compiled_patterns.append(compiled_group)\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for group in rule['exclude_patterns']:\n                compiled_group = [Chem.MolFromSmarts(p) for p in group]\n                compiled_excludes.append(compiled_group)\n            rule['compiled_exclude_patterns'] = compiled_excludes\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for group in rule['compiled_exclude_patterns']:\n                        for pat in group:\n                            if mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                        if not match:\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for idx, compiled_group in enumerate(rule['compiled_patterns']):\n                    group_match = False\n                    for pat in compiled_group:\n                        matches = mol.GetSubstructMatches(pat)\n                        if matches:\n                            # If a count threshold is specified for this pattern\n                            if 'counts' in rule and pat.GetSmarts() in rule['counts']:\n                                threshold = rule['counts'][pat.GetSmarts()]\n                                if len(matches) >= threshold:\n                                    group_match = True\n                                    break\n                            else:\n                                group_match = True\n                                break\n                    if not group_match:\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df"
}