{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. The matrix has columns corresponding to the specified rules, with values indicating whether each SMILES string matches each rule and the predicted high or low Fe/Hf value according to the rules. The code uses SMARTS patterns and custom check functions to capture complex structural features as per the rules.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    import pandas as pd\n    from rdkit import Chem\n    from rdkit.Chem import AllChem\n\n    # Define SMARTS patterns for functional groups\n    patterns = {\n        'carboxylic_acid': Chem.MolFromSmarts('[CX3](=O)[OX2H1]'),\n        'carboxylate_anion': Chem.MolFromSmarts('[CX3](=O)[O-]'),\n        'primary_amine': Chem.MolFromSmarts('[NX3;H2]'),\n        'secondary_amine': Chem.MolFromSmarts('[NX3;H1][#6]'),\n        'thiol': Chem.MolFromSmarts('[SX2H]'),\n        'thioether': Chem.MolFromSmarts('[#16X2][#6]'),\n        'pyridine_ring': Chem.MolFromSmarts('n1ccccc1'),\n        'aromatic_ring': Chem.MolFromSmarts('a1aaaaa1'),\n        'aromatic_carboxylic_acid': Chem.MolFromSmarts('[a][CX3](=O)[OX1H0-,OX2H1]'),\n        'electron_withdrawing_groups': [\n            Chem.MolFromSmarts('[c][NX3+](=O)[O-]'),  # Nitro group on aromatic ring\n            Chem.MolFromSmarts('[c][CH2Br]'),          # Bromomethyl on aromatic ring\n            Chem.MolFromSmarts('[c][SX2H]'),           # Thiol on aromatic ring\n        ],\n        'electron_donating_groups': [\n            Chem.MolFromSmarts('[c][CH3]'),            # Methyl group on aromatic ring\n            Chem.MolFromSmarts('[c][NX3H2]'),          # Amino group on aromatic ring\n            Chem.MolFromSmarts('[c][OX2H]'),           # Hydroxyl group on aromatic ring\n        ],\n        'hydroxyl_group': Chem.MolFromSmarts('[OX2H]'),\n        'multiple_hydroxyls': Chem.MolFromSmarts('[OX2H]'),\n        'perfluoroalkyl_chain': Chem.MolFromSmarts('[CX4](F)(F)(F)'),  # Trifluoromethyl\n        'ether_linkage': Chem.MolFromSmarts('[#6][OX2][#6]'),\n        'amide_adjacent_to_aromatic': Chem.MolFromSmarts('[a][CX3](=O)[NX3]'),\n        'alpha_amino_acid': Chem.MolFromSmarts('[NX3H2][CX4][CX3](=O)[OX1H0-,OX2H1]'),\n        'aromatic_amino_acid': Chem.MolFromSmarts('[NX3H2][CX4][#6][a]'),\n    }\n\n    # Define custom check functions for complex rules\n\n    def check_rule1(mol):\n        # Rule 1: \u03c9-amino carboxylic acids with aliphatic chains of five or more carbons\n        amine_matches = mol.GetSubstructMatches(patterns['primary_amine'])\n        acid_matches = mol.GetSubstructMatches(patterns['carboxylic_acid'])\n        if not amine_matches or not acid_matches:\n            return False\n        for amine in amine_matches:\n            for acid in acid_matches:\n                n_idx = amine[0]\n                c_idx = acid[0]\n                # Get shortest path\n                path = Chem.rdmolops.GetShortestPath(mol, n_idx, c_idx)\n                # Check if path length is at least 7 (N + 5 carbons + C)\n                if len(path) >= 7:\n                    # Check that intermediate atoms are carbons\n                    intermediate_atoms = path[1:-1]\n                    if all(mol.GetAtomWithIdx(idx).GetSymbol() == 'C' for idx in intermediate_atoms):\n                        return True\n        return False\n\n    def check_rule2(mol):\n        # Rule 2: Aromatic carboxylic acids with strong electron-withdrawing groups at the para position\n        acid_matches = mol.GetSubstructMatches(patterns['aromatic_carboxylic_acid'])\n        if not acid_matches:\n            return False\n        for acid_match in acid_matches:\n            c_idx = acid_match[0]  # Carbon of carboxylic acid attached to aromatic ring\n            c_atom = mol.GetAtomWithIdx(c_idx)\n            # Find the aromatic ring containing this atom\n            ri = mol.GetRingInfo()\n            atom_rings = ri.AtomRings()\n            for ring in atom_rings:\n                if c_idx in ring and len(ring) == 6:\n                    # Identify para position (opposite atom in the ring)\n                    idx_in_ring = ring.index(c_idx)\n                    para_idx = ring[(idx_in_ring + 3) % 6]\n                    para_atom = mol.GetAtomWithIdx(para_idx)\n                    # Check for EWG at para position\n                    for ewg_pattern in patterns['electron_withdrawing_groups']:\n                        if mol.HasSubstructMatch(ewg_pattern, useChirality=False):\n                            ewg_matches = mol.GetSubstructMatches(ewg_pattern)\n                            for match in ewg_matches:\n                                if para_idx in match:\n                                    return True\n        return False\n\n    def check_rule3(mol):\n        # Rule 3: Modifiers containing both sulfur-containing groups and carboxylic acid groups\n        has_acid = mol.HasSubstructMatch(patterns['carboxylic_acid']) or mol.HasSubstructMatch(patterns['carboxylate_anion'])\n        has_sulfur = mol.HasSubstructMatch(patterns['thiol']) or mol.HasSubstructMatch(patterns['thioether'])\n        return has_acid and has_sulfur\n\n    def check_rule4(mol):\n        # Rule 4: Modifiers with pyridine rings adjacent to carboxylic acid groups\n        pyridine_matches = mol.GetSubstructMatches(patterns['pyridine_ring'])\n        acid_matches = mol.GetSubstructMatches(patterns['carboxylic_acid'])\n        if not pyridine_matches or not acid_matches:\n            return False\n        for pyridine in pyridine_matches:\n            for idx in pyridine:\n                atom = mol.GetAtomWithIdx(idx)\n                for neighbor in atom.GetNeighbors():\n                    if neighbor.HasSubstructMatch(patterns['carboxylic_acid']) or neighbor.HasSubstructMatch(patterns['carboxylate_anion']):\n                        return True\n        return False\n\n    def check_rule5(mol):\n        # Rule 5: Amino acids with aromatic side chains without steric hindrance\n        matches = mol.GetSubstructMatches(patterns['aromatic_amino_acid'])\n        return bool(matches)\n\n    def check_rule6(mol):\n        # Rule 6: Simple aliphatic carboxylic acids without additional coordinating groups\n        has_acid = mol.HasSubstructMatch(patterns['carboxylic_acid']) or mol.HasSubstructMatch(patterns['carboxylate_anion'])\n        has_other_groups = mol.HasSubstructMatch(patterns['primary_amine']) or mol.HasSubstructMatch(patterns['secondary_amine']) or mol.HasSubstructMatch(patterns['thiol']) or mol.HasSubstructMatch(patterns['thioether']) or mol.HasSubstructMatch(patterns['ether_linkage'])\n        return has_acid and not has_other_groups\n\n    def check_rule7(mol):\n        # Rule 7: Aromatic carboxylic acids with electron-donating groups at the para position\n        acid_matches = mol.GetSubstructMatches(patterns['aromatic_carboxylic_acid'])\n        if not acid_matches:\n            return False\n        for acid_match in acid_matches:\n            c_idx = acid_match[0]\n            c_atom = mol.GetAtomWithIdx(c_idx)\n            ri = mol.GetRingInfo()\n            atom_rings = ri.AtomRings()\n            for ring in atom_rings:\n                if c_idx in ring and len(ring) == 6:\n                    idx_in_ring = ring.index(c_idx)\n                    para_idx = ring[(idx_in_ring + 3) % 6]\n                    for edg_pattern in patterns['electron_donating_groups']:\n                        if mol.GetAtomWithIdx(para_idx).HasSubstructMatch(edg_pattern):\n                            return True\n        return False\n\n    def check_rule8(mol):\n        # Rule 8: Modifiers with multiple hydroxyl groups on aliphatic chains without other strong coordinating groups\n        hydroxyl_matches = mol.GetSubstructMatches(patterns['hydroxyl_group'])\n        has_acid = mol.HasSubstructMatch(patterns['carboxylic_acid']) or mol.HasSubstructMatch(patterns['carboxylate_anion'])\n        if len(hydroxyl_matches) >= 2 and has_acid:\n            return True\n        return False\n\n    def check_rule9(mol):\n        # Rule 9: Carboxylic acids attached to perfluorinated alkyl chains\n        has_acid = mol.HasSubstructMatch(patterns['carboxylic_acid']) or mol.HasSubstructMatch(patterns['carboxylate_anion'])\n        has_perfluoro = mol.HasSubstructMatch(patterns['perfluoroalkyl_chain'])\n        return has_acid and has_perfluoro\n\n    def check_rule10(mol):\n        # Rule 10: Aliphatic carboxylic acids with terminal hydroxyl groups and sufficient chain length (6 or more carbons)\n        acid_matches = mol.GetSubstructMatches(patterns['carboxylic_acid'])\n        hydroxyl_matches = mol.GetSubstructMatches(patterns['hydroxyl_group'])\n        if not acid_matches or not hydroxyl_matches:\n            return False\n        # Check for chain length between acid and hydroxyl group\n        for acid in acid_matches:\n            for hydroxyl in hydroxyl_matches:\n                c_idx = acid[0]\n                o_idx = hydroxyl[0]\n                path = Chem.rdmolops.GetShortestPath(mol, c_idx, o_idx)\n                if len(path) >= 7:\n                    return True\n        return False\n\n    # Define the rules with their check functions\n    rules = [\n        {'number': 1, 'description': 'Rule 1', 'prediction': 1, 'check_function': check_rule1},\n        {'number': 2, 'description': 'Rule 2', 'prediction': 1, 'check_function': check_rule2},\n        {'number': 3, 'description': 'Rule 3', 'prediction': 1, 'check_function': check_rule3},\n        {'number': 4, 'description': 'Rule 4', 'prediction': 1, 'check_function': check_rule4},\n        {'number': 5, 'description': 'Rule 5', 'prediction': 1, 'check_function': check_rule5},\n        {'number': 6, 'description': 'Rule 6', 'prediction': -1, 'check_function': check_rule6},\n        {'number': 7, 'description': 'Rule 7', 'prediction': -1, 'check_function': check_rule7},\n        {'number': 8, 'description': 'Rule 8', 'prediction': -1, 'check_function': check_rule8},\n        {'number': 9, 'description': 'Rule 9', 'prediction': -1, 'check_function': check_rule9},\n        {'number': 10, 'description': 'Rule 10', 'prediction': 1, 'check_function': check_rule10},\n        # Add more rules as needed\n    ]\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                if rule['check_function'](mol):\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f\"Rule {rule['number']}\" for rule in rules])\n    return df"
}