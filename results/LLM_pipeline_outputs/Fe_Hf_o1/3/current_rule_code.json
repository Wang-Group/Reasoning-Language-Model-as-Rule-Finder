{
    "prefix": "This code defines a function 'rule2matrix' that converts a list of SMILES strings into a feature matrix based on defined chemical rules using RDKit. Each rule corresponds to a column in the output DataFrame, and each row corresponds to a SMILES string from the list. The matrix entries are 0, 1, or -1, depending on whether the SMILES matches the rule patterns and the predicted target value (high or low). The code takes into account the suggestions provided, adjusts SMARTS patterns for better matching, and handles errors gracefully.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    \"\"\"\n    Converts a list of SMILES strings into a feature matrix based on defined chemical rules.\n    Each rule is represented as a column in the output DataFrame, and each row corresponds\n    to a SMILES string from the input list.\n    \"\"\"\n\n    # Define SMARTS patterns for functional groups, updated per the suggestions.\n\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1]'\n\n    # Thiol group (-SH)\n    thiol = '[SX2H]'\n\n    # Thioether group (-S-)\n    thioether = '[#16X2][#6]'\n\n    # Long aliphatic chain (three or more carbons between amino group and carboxylic acid) with terminal amino group (-NH2)\n    long_chain_primary_amine = '[NX3H2][CH2]{3,}[CX3](=O)[OX1H0-,OX2H1]'\n\n    # Electron-withdrawing groups on aromatic ring at para position (halogens and nitro group)\n    para_ewgs = [\n        '[cH]1ccc([F,Cl,Br,I])cc1C(=O)[OX2H1,OX1-]',    # Halogen at para position\n        '[cH]1ccc([N+](=O)[O-])cc1C(=O)[OX2H1,OX1-]'      # Nitro group at para position\n    ]\n\n    # Electron-donating groups on aromatic ring at para position (amino and hydroxyl groups)\n    para_edgs = [\n        '[cH]1ccc([NX3H2,NX3H1])cc1C(=O)[OX2H1,OX1-]',    # Amino group at para position\n        '[cH]1ccc([OX2H])cc1C(=O)[OX2H1,OX1-]'            # Hydroxyl group at para position\n    ]\n\n    # Pyridine ring with nitrogen available for coordination\n    pyridine_ring = 'n1ccccc1'\n\n    # Fluorinated alkyl chain (e.g., trifluoromethyl group)\n    fluorinated_alkyl_chain = '[CX4](F)(F)(F)'\n\n    # Cyclic structures containing multiple oxygen atoms (simplified pattern for lactones)\n    cyclic_with_multiple_oxygens = '[O]1CCOC[C]1=O'\n\n    # Define the rules\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers containing both a carboxylic acid group and a sulfur-containing functional group (thiol \u2013SH or thioether \u2013S\u2013R) result in a High Fe/Hf value.',\n            'patterns': {\n                'must_match': [carboxylic_acid],\n                'must_match_one_of': [thiol, thioether]\n            },\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers with long aliphatic chains (five or more carbons) containing a terminal amino group (\u2013NH\u2082) result in a High Fe/Hf value.',\n            'patterns': {\n                'must_match': [long_chain_primary_amine]\n            },\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers with aromatic carboxylic acids bearing strong electron-withdrawing groups (e.g., nitro, halogens) at the para position result in a High Fe/Hf value.',\n            'patterns': {\n                'must_match_one_of': para_ewgs\n            },\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers containing a pyridine ring with the nitrogen atom unimpeded for coordination result in a High Fe/Hf value.',\n            'patterns': {\n                'must_match': [pyridine_ring]\n            },\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers with flexible aliphatic chains containing ether linkages (\u2013O\u2013) and terminal coordinating groups result in a High Fe/Hf value.',\n            'custom_function': 'rule5_check',\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers with multiple hydroxyl groups (three or more) on short aliphatic chains (six carbons or fewer) result in a Low Fe/Hf value.',\n            'custom_function': 'rule6_check',\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Aromatic carboxylic acids with electron-donating groups (e.g., amino, hydroxyl) directly attached to the ring result in a Low Fe/Hf value.',\n            'patterns': {\n                'must_match_one_of': para_edgs\n            },\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers with fluorinated alkyl chains result in a Low Fe/Hf value.',\n            'patterns': {\n                'must_match': [fluorinated_alkyl_chain]\n            },\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Simple aliphatic carboxylic acids without additional coordinating groups result in a Low Fe/Hf value.',\n            'patterns': {\n                'must_match': [carboxylic_acid],\n                'must_not_match': ['[!#6;R]', '[!#1][N,O,S]', '[$([#6][!#6;!#1])]', '[a]']\n            },\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers with a single hydroxyl group on a long aliphatic chain (seven carbons or more) result in a High Fe/Hf value.',\n            'custom_function': 'rule10_check',\n            'prediction': 1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers with cyclic structures containing multiple oxygen atoms positioned to chelate Fe ions result in a High Fe/Hf value.',\n            'patterns': {\n                'must_match': [cyclic_with_multiple_oxygens]\n            },\n            'prediction': 1\n        }\n    ]\n\n    # Compile the SMARTS patterns\n    for rule in rules:\n        if 'patterns' in rule:\n            for key in ['must_match', 'must_not_match', 'must_match_one_of']:\n                if key in rule['patterns']:\n                    compiled_patterns = []\n                    for pattern in rule['patterns'][key]:\n                        compiled_patterns.append(Chem.MolFromSmarts(pattern))\n                    rule['patterns'][f'compiled_{key}'] = compiled_patterns\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # If the rule has a custom function\n                if 'custom_function' in rule:\n                    func_name = rule['custom_function']\n                    function = globals()[func_name]\n                    if function(mol):\n                        row.append(rule['prediction'])\n                    else:\n                        row.append(0)\n                    continue\n                # Check must_not_match patterns\n                if 'patterns' in rule and 'compiled_must_not_match' in rule['patterns']:\n                    for pat in rule['patterns']['compiled_must_not_match']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check must_match patterns\n                if 'patterns' in rule and 'compiled_must_match' in rule['patterns']:\n                    for pat in rule['patterns']['compiled_must_match']:\n                        if not mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check must_match_one_of patterns\n                if 'patterns' in rule and 'compiled_must_match_one_of' in rule['patterns']:\n                    group_match = False\n                    for pat in rule['patterns']['compiled_must_match_one_of']:\n                        if mol.HasSubstructMatch(pat):\n                            group_match = True\n                            break\n                    if not group_match:\n                        match = False\n                        row.append(0)\n                        continue\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df\n\n# Custom functions for rules requiring special checks\n\ndef rule5_check(mol):\n    \"\"\"\n    Rule 5: Modifiers with flexible aliphatic chains containing ether linkages (-O-) and terminal coordinating groups.\n    \"\"\"\n    try:\n        # Patterns for ether linkages and terminal carboxylic acid or amino group\n        pattern1 = Chem.MolFromSmarts('[OX2]([CH2])[CH2][OX2][CH2][CH2][CX3](=O)[OX1H0-,OX2H1]')  # Ether chain ending with carboxylic acid\n        pattern2 = Chem.MolFromSmarts('[OX2]([CH2])[CH2][OX2][CH2][CH2][NX3H2]')  # Ether chain ending with amino group\n        if mol.HasSubstructMatch(pattern1) or mol.HasSubstructMatch(pattern2):\n            return True\n        else:\n            return False\n    except Exception as e:\n        return False\n\ndef rule6_check(mol):\n    \"\"\"\n    Rule 6: Modifiers with multiple hydroxyl groups (three or more) on short aliphatic chains (six carbons or fewer).\n    \"\"\"\n    try:\n        # Check for three or more hydroxyl groups\n        hydroxyl_pattern = Chem.MolFromSmarts('[OX2H]')\n        hydroxyl_matches = mol.GetSubstructMatches(hydroxyl_pattern)\n        if len(hydroxyl_matches) >= 3:\n            # Check if the aliphatic chain is six carbons or fewer\n            chains = Chem.rdmolops.GetMolFrags(mol, asMols=True)\n            for chain in chains:\n                carbons = [atom for atom in chain.GetAtoms() if atom.GetAtomicNum() == 6 and not atom.IsInRing() and not atom.GetIsAromatic()]\n                if len(carbons) <= 6:\n                    return True\n        return False\n    except Exception as e:\n        return False\n\ndef rule10_check(mol):\n    \"\"\"\n    Rule 10: Modifiers with a single hydroxyl group on a long aliphatic chain (seven carbons or more).\n    \"\"\"\n    try:\n        # Check for exactly one hydroxyl group\n        hydroxyl_pattern = Chem.MolFromSmarts('[OX2H]')\n        hydroxyl_matches = mol.GetSubstructMatches(hydroxyl_pattern)\n        if len(hydroxyl_matches) != 1:\n            return False\n        else:\n            # Find the longest carbon chain\n            chains = Chem.GetSymmSSSR(mol)\n            max_chain_length = 0\n            for bond in mol.GetBonds():\n                if bond.GetBeginAtom().GetAtomicNum() == 6 and bond.GetEndAtom().GetAtomicNum() == 6:\n                    length = len(Chem.rdmolops.GetShortestPath(mol, bond.GetBeginAtomIdx(), bond.GetEndAtomIdx()))\n                    if length > max_chain_length:\n                        max_chain_length = length\n            if max_chain_length >= 7:\n                return True\n            else:\n                return False\n    except Exception as e:\n        return False\n"
}