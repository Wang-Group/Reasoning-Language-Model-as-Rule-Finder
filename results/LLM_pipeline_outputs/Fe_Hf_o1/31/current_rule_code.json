{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit, following the provided rules.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    from rdkit import Chem\n    import pandas as pd\n    \n    # Define SMARTS patterns\n    carboxylic_acid = Chem.MolFromSmarts('[CX3](=O)[OX1H0-,OX2H1]')  # Carboxylic acid group (-COOH)\n    primary_amine = Chem.MolFromSmarts('[NX3H2]')  # Primary amine (-NH2)\n    terminal_primary_amine = Chem.MolFromSmarts('[NX3H2][CH2]')  # Terminal primary amine\n    aliphatic_chain = Chem.MolFromSmarts('[CX4H2][CX4H2][CX4H2]')  # Aliphatic chain of at least 3 carbons\n    \n    thiol = Chem.MolFromSmarts('[SX2H]')  # Thiol group (-SH)\n    thioether = Chem.MolFromSmarts('[#16X2]([#6])[#6]')  # Thioether (-S-)\n    \n    pyridine_ring = Chem.MolFromSmarts('n1cccc1')  # Pyridine ring\n    \n    # Electron-withdrawing groups\n    nitro_group = Chem.MolFromSmarts('[NX3+(=O)[O-]]')  # Nitro group (-NO2)\n    bromomethyl_group = Chem.MolFromSmarts('[CH2Br]')  # Bromomethyl group (-CH2Br)\n    aromatic_ring = Chem.MolFromSmarts('c1ccccc1')  # Aromatic ring\n    para_substitution = Chem.MolFromSmarts('c1ccc(cc1)-[*]')  # Para-substituted aromatic ring\n    \n    # Electron-donating groups\n    hydroxyl_group = Chem.MolFromSmarts('[OX2H]')  # Hydroxyl group (-OH)\n    amino_group = Chem.MolFromSmarts('[NX3H2]')  # Amino group (-NH2)\n    \n    # Heteroatoms for chelation\n    heteroatoms = Chem.MolFromSmarts('[#7,#8,#16]')  # N, O, S\n    \n    # Multiple hydroxyl groups\n    polyol = Chem.MolFromSmarts('[#6][OX2H][#6][OX2H][#6]')  # Chain with multiple -OH groups\n    \n    # Fluorinated aliphatic chain\n    fluorinated_chain = Chem.MolFromSmarts('[CF3][CF2][CF2][CF2][CF3]')\n    \n    # Carbonyl groups adjacent to carboxylic acid\n    adjacent_carbonyl = Chem.MolFromSmarts('[CX3](=O)[CX3](=O)[OX1H0-,OX2H1]')\n    \n    # Heteroaromatic rings with nitrogen in resonance\n    pyridone = Chem.MolFromSmarts('O=c1ccncc1')\n    pyrazole = Chem.MolFromSmarts('c1c[nH]ncc1')\n    \n    # Bulky aromatic systems\n    indole = Chem.MolFromSmarts('c1ccc2c(c1)cc[nH]2')\n    \n    # Intramolecular hydrogen bonding\n    intramolecular_Hbond = Chem.MolFromSmarts('[OH].[NX3][CX3](=O)[OH]')\n    \n    # Define rules\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers containing a terminal primary amino group (-NH2) on an aliphatic chain that is three or more carbons away from the carboxylic acid group (-COOH) predict a high Fe/Hf value.',\n            'function': 'check_rule1',\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers containing sulfur-containing functional groups, such as thiols (-SH) or thioethers (-S-), predict a high Fe/Hf value.',\n            'function': 'check_rule2',\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers with a pyridine ring where the nitrogen atom is available for coordination predict a high Fe/Hf value.',\n            'function': 'check_rule3',\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers that are aromatic carboxylic acids substituted at the para position with strong electron-withdrawing groups predict a high Fe/Hf value.',\n            'function': 'check_rule4',\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers containing multiple coordinating functional groups with heteroatoms like N, O, or S positioned to allow chelation predict a high Fe/Hf value.',\n            'function': 'check_rule5',\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers that are simple aliphatic carboxylic acids without additional coordinating functional groups predict a low Fe/Hf value.',\n            'function': 'check_rule6',\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers containing aromatic rings substituted with electron-donating groups at the para position predict a low Fe/Hf value.',\n            'function': 'check_rule7',\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers containing multiple hydroxyl groups (-OH) on an aliphatic chain or cyclic structure, without an effective chelating arrangement, predict a low Fe/Hf value.',\n            'function': 'check_rule8',\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers with fluorinated aliphatic chains predict a low Fe/Hf value.',\n            'function': 'check_rule9',\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers containing carbonyl groups adjacent to the carboxylic acid group predict a low Fe/Hf value.',\n            'function': 'check_rule10',\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers containing heteroaromatic rings with nitrogen atoms involved in resonance predict a low Fe/Hf value.',\n            'function': 'check_rule11',\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers with bulky aromatic systems or fused ring structures that may cause steric hindrance predict a low Fe/Hf value.',\n            'function': 'check_rule12',\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers containing electron-donating groups at positions that can form intramolecular hydrogen bonds may decrease the availability of the coordinating group, predicting a low Fe/Hf value.',\n            'function': 'check_rule13',\n            'prediction': -1\n        }\n    ]\n    \n    # Initialize results list\n    results = []\n    \n    # Define rule check functions\n    def check_rule1(mol):\n        try:\n            carboxy_matches = mol.GetSubstructMatches(carboxylic_acid)\n            amine_matches = mol.GetSubstructMatches(terminal_primary_amine)\n            if not carboxy_matches or not amine_matches:\n                return 0\n            for c_match in carboxy_matches:\n                c_idx = c_match[0]\n                for a_match in amine_matches:\n                    n_idx = a_match[0]\n                    path = Chem.GetShortestPath(mol, c_idx, n_idx)\n                    # Exclude start and end atoms\n                    path_atoms = path[1:-1]\n                    # Count number of carbons in path_atoms\n                    num_carbons = sum(1 for idx in path_atoms if mol.GetAtomWithIdx(idx).GetAtomicNum() == 6)\n                    if num_carbons >= 3:\n                        return 1\n            return 0\n        except:\n            return 0\n    \n    def check_rule2(mol):\n        try:\n            if mol.HasSubstructMatch(thiol) or mol.HasSubstructMatch(thioether):\n                return 1\n            return 0\n        except:\n            return 0\n    \n    def check_rule3(mol):\n        try:\n            if mol.HasSubstructMatch(pyridine_ring):\n                return 1\n            return 0\n        except:\n            return 0\n    \n    def check_rule4(mol):\n        try:\n            if mol.HasSubstructMatch(carboxylic_acid) and mol.HasSubstructMatch(aromatic_ring):\n                para_matches = mol.GetSubstructMatches(para_substitution)\n                for match in para_matches:\n                    substituted_atom = mol.GetAtomWithIdx(match[-1])\n                    if substituted_atom.HasSubstructMatch(nitro_group) or substituted_atom.HasSubstructMatch(bromomethyl_group):\n                        return 1\n            return 0\n        except:\n            return 0\n    \n    def check_rule5(mol):\n        try:\n            heteroatom_matches = mol.GetSubstructMatches(heteroatoms)\n            if len(heteroatom_matches) >= 2:\n                # Check if heteroatoms are positioned to allow chelation (simplified assumption)\n                return 1\n            return 0\n        except:\n            return 0\n    \n    def check_rule6(mol):\n        try:\n            if mol.HasSubstructMatch(carboxylic_acid):\n                if not (mol.HasSubstructMatch(primary_amine) or mol.HasSubstructMatch(thiol) or mol.HasSubstructMatch(thioether) or mol.HasSubstructMatch(hydroxyl_group) or mol.HasSubstructMatch(aromatic_ring)):\n                    return -1\n            return 0\n        except:\n            return 0\n    \n    def check_rule7(mol):\n        try:\n            if mol.HasSubstructMatch(carboxylic_acid) and mol.HasSubstructMatch(aromatic_ring):\n                para_matches = mol.GetSubstructMatches(para_substitution)\n                for match in para_matches:\n                    substituted_atom = mol.GetAtomWithIdx(match[-1])\n                    if substituted_atom.HasSubstructMatch(hydroxyl_group) or substituted_atom.HasSubstructMatch(amino_group):\n                        return -1\n            return 0\n        except:\n            return 0\n    \n    def check_rule8(mol):\n        try:\n            if mol.HasSubstructMatch(polyol):\n                return -1\n            return 0\n        except:\n            return 0\n    \n    def check_rule9(mol):\n        try:\n            if mol.HasSubstructMatch(fluorinated_chain):\n                return -1\n            return 0\n        except:\n            return 0\n    \n    def check_rule10(mol):\n        try:\n            if mol.HasSubstructMatch(adjacent_carbonyl):\n                return -1\n            return 0\n        except:\n            return 0\n    \n    def check_rule11(mol):\n        try:\n            if mol.HasSubstructMatch(pyridone) or mol.HasSubstructMatch(pyrazole):\n                return -1\n            return 0\n        except:\n            return 0\n    \n    def check_rule12(mol):\n        try:\n            if mol.HasSubstructMatch(indole):\n                return -1\n            return 0\n        except:\n            return 0\n    \n    def check_rule13(mol):\n        try:\n            if mol.HasSubstructMatch(intramolecular_Hbond):\n                return -1\n            return 0\n        except:\n            return 0\n    \n    # Map function names to actual functions\n    rule_functions = {\n        'check_rule1': check_rule1,\n        'check_rule2': check_rule2,\n        'check_rule3': check_rule3,\n        'check_rule4': check_rule4,\n        'check_rule5': check_rule5,\n        'check_rule6': check_rule6,\n        'check_rule7': check_rule7,\n        'check_rule8': check_rule8,\n        'check_rule9': check_rule9,\n        'check_rule10': check_rule10,\n        'check_rule11': check_rule11,\n        'check_rule12': check_rule12,\n        'check_rule13': check_rule13\n    }\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                func = rule_functions[rule['function']]\n                match = func(mol)\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    \n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df"
}