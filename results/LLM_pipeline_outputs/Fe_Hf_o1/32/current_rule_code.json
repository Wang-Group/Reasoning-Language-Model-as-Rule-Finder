{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit. It parses each SMILES string, applies a series of structural rules defined as SMARTS patterns, and generates a DataFrame where each column corresponds to one rule, and each row corresponds to one SMILES string from the input list. The values in the matrix indicate whether a rule matches (1 for High Fe/Hf, -1 for Low Fe/Hf) or does not match (0).",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    primary_amino = '[NX3;H2]'\n    secondary_amino = '[NX3;H1][#6]'\n    thiol = '[SX2H]'\n    thioether = '[#16X2]([#6])[#6]'\n    halogen = '[F,Cl,Br,I]'\n    nitro_group = '[NX3](=O)[OX1]'\n    hydroxyl_group = '[OX2H]'\n    ether_linkage = '[#6][OX2][#6]'\n    pyridine_ring = 'n1ccccc1'\n    aromatic_c_oh = '[c][OX2H]'\n    aromatic_c_nh2 = '[c][NX3;H2]'\n    aromatic_c_ch3 = '[c][CH3]'\n    amide_adjacent_aromatic = '[c][CX3](=O)[NX3]'\n\n    fused_aromatic_rings = '[*;r5,r6;!r3,r4]1~[*;r5,r6;!r3,r4]~[*;r5,r6;!r3,r4]~[*;r5,r6;!r3,r4]~[*;r5,r6;!r3,r4]~1[*;r5,r6]'\n\n    # Define the rules\n    rules = [\n        {\n            'number': 1,\n            'description': 'High Fe/Hf (True): Modifiers containing both amino (-NH2) and carboxyl (-COOH) groups, particularly in amino acids.',\n            'patterns': [\n                ['[NX3;H2]'],       # Amino group\n                ['[CX3](=O)[OX2H1]']  # Carboxylic acid group\n            ],\n            'exclude_patterns': [\n                ['[NX3;H2][a]']  # Exclude amino group attached to aromatic\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'High Fe/Hf (True): Modifiers containing sulfur-functional groups such as thiol (-SH) or thioether (-S-) and carboxyl (-COOH) groups.',\n            'patterns': [\n                ['[SX2H]', '[#16X2]([#6])[#6]'],  # Thiol or thioether\n                ['[CX3](=O)[OX2H1]']  # Carboxyl group\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'High Fe/Hf (True): Modifiers that are aromatic carboxylic acids with electron-withdrawing groups attached to the aromatic ring.',\n            'patterns': [\n                ['[c][CX3](=O)[OX2H1]'],  # Aromatic carboxylic acid\n                ['[c][F,Cl,Br,I]', '[c][NX3](=O)[OX1]', 'n1ccccc1']  # EWG attached to aromatic ring\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'High Fe/Hf (True): Modifiers containing flexible polyether chains with ether linkages and a terminal carboxyl (-COOH) or amino (-NH2) group.',\n            'patterns': [\n                ['[#6][OX2][#6]'],  # Ether linkage\n                ['[CX3](=O)[OX2H1]', '[NX3;H2]']  # Carboxyl or amino group\n            ],\n            'count_threshold': {'[#6][OX2][#6]': 2},  # At least two ether linkages\n            'prediction': 1\n        },\n        {\n            'number':5,\n            'description':'High Fe/Hf (True): Modifiers combining multiple coordinating groups (amino, carboxyl, amide, hydroxyl).',\n            'patterns': [\n                ['[NX3;H2]', '[CX3](=O)[OX2H1]', '[CX3](=O)[NX3;H2,H1][#6]', '[OX2H]'],  # At least two different coordinating groups\n            ],\n            'count_threshold_groups': 2,  # At least two different groups must be present\n            'prediction':1\n        },\n        {\n            'number': 6,\n            'description': 'Low Fe/Hf (False): Simple aliphatic carboxylic acids without additional donor groups.',\n            'patterns': [\n                ['[CX3](=O)[OX2H1]']  # Carboxyl group\n            ],\n            'exclude_patterns': [\n                ['[NX3]'],       # Exclude amines\n                ['[S]'],         # Exclude sulfur groups\n                ['[#6][OX2][#6]'], # Exclude ether linkages\n                ['[F,Cl,Br,I]'], # Exclude halogens\n                ['[a]']          # Exclude aromatic systems\n            ],\n            'prediction': -1\n        },\n        {\n            'number':7,\n            'description':'Low Fe/Hf (False): Aromatic carboxylic acids with electron-donating groups attached to aromatic ring.',\n            'patterns': [\n                ['[c][CX3](=O)[OX2H1]'],  # Aromatic carboxylic acid\n                ['[c][NX3;H2]', '[c][OX2H]', '[c][CH3]']  # EDG attached to aromatic ring\n            ],\n            'prediction': -1\n        },\n        {\n            'number':8,\n            'description':'Low Fe/Hf (False): Modifiers containing multiple hydroxyl (-OH) groups on aliphatic chains (polyols).',\n            'patterns': [\n                ['[CX4][OX2H]']  # Aliphatic hydroxyl group\n            ],\n            'count_threshold': {'[CX4][OX2H]':2},  # At least two hydroxyl groups\n            'prediction': -1\n        },\n        {\n            'number':9,\n            'description':'Low Fe/Hf (False): Modifiers containing fluorinated alkyl chains or multiple fluorine atoms.',\n            'patterns': [\n                ['[CX4][F]']  # Carbon with fluorine\n            ],\n            'count_threshold': {'[CX4][F]':2},  # At least two fluorine atoms\n            'prediction': -1\n        },\n        {\n            'number':10,\n            'description':'Low Fe/Hf (False): Modifiers with conjugated carbonyl groups adjacent to carboxyl groups.',\n            'patterns': [\n                ['[CX3](=O)[OX2H1]'],  # Carboxyl group\n                ['[c][CX3](=O)[#6]']  # Conjugated carbonyl group on aromatic ring\n            ],\n            'prediction': -1\n        },\n        {\n            'number':11,\n            'description':'Modifiers containing nitrogen heterocycles directly attached to carboxyl group (Low Fe/Hf), or with a spacer (High Fe/Hf).',\n            'patterns': [\n                ['[n][CX3](=O)[OX2H1]']  # Nitrogen heterocycle directly attached to carboxyl group\n            ],\n            'prediction': -1\n        },\n        {\n            'number':11.1,\n            'description':'Modifiers containing nitrogen heterocycles connected via spacer to carboxyl group (High Fe/Hf).',\n            'patterns': [\n                ['[n][CX4][CX3](=O)[OX2H1]']  # Nitrogen heterocycle connected via spacer to carboxyl group\n            ],\n            'prediction': 1\n        },\n        {\n            'number':12,\n            'description':'Low Fe/Hf (False): Modifiers with bulky aromatic side groups (e.g., indole).',\n            'patterns': [\n                ['[nH]1c2ccccc2cc1', 'c1cc2c(cc1)oc2']  # Indole or benzofuran\n            ],\n            'prediction': -1\n        }\n    ]\n\n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for group in rule.get('patterns', []):\n            compiled_group = [Chem.MolFromSmarts(p) for p in group]\n            compiled_patterns.append(compiled_group)\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for group in rule['exclude_patterns']:\n                compiled_group = [Chem.MolFromSmarts(p) for p in group]\n                compiled_excludes.append(compiled_group)\n            rule['compiled_exclude_patterns'] = compiled_excludes\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for group in rule['compiled_exclude_patterns']:\n                        for pat in group:\n                            if mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                        if not match:\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Special case for Rule 5 requiring count of groups\n                if rule.get('number') == 5:\n                    group_matches = 0\n                    matched_groups = set()\n                    for pattern in rule['compiled_patterns'][0]:\n                        if mol.HasSubstructMatch(pattern):\n                            matched_groups.add(pattern)\n                    if len(matched_groups) >= rule['count_threshold_groups']:\n                        row.append(rule['prediction'])\n                    else:\n                        row.append(0)\n                    continue\n                # Special handling for count thresholds\n                if 'count_threshold' in rule:\n                    pattern_counts = {}\n                    for idx, compiled_group in enumerate(rule['compiled_patterns']):\n                        group_match = False\n                        for pat in compiled_group:\n                            matches = mol.GetSubstructMatches(pat)\n                            count_required = rule['count_threshold'].get(pat.GetSmarts(), 1)\n                            if len(matches) >= count_required:\n                                group_match = True\n                                break\n                        if not group_match:\n                            match = False\n                            break\n                    if match:\n                        row.append(rule['prediction'])\n                    else:\n                        row.append(0)\n                    continue\n                # Check required patterns\n                for compiled_group in rule['compiled_patterns']:\n                    group_match = False\n                    for pat in compiled_group:\n                        if mol.HasSubstructMatch(pat):\n                            group_match = True\n                            break\n                    if not group_match:\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                # print(f\"Error processing rule {rule['number']} for SMILES {smi}: {e}\")\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df\n"
}