{
    "prefix": "This code defines the function 'rule2matrix' that converts a list of SMILES strings into a feature matrix using RDkit. It applies 13 structural rules based on molecular features, using SMARTS patterns to detect substructures corresponding to each rule. The output is a DataFrame where each column corresponds to a rule, and each row corresponds to a SMILES string from the list. Each cell contains a value of 1 if the molecule matches the rule and predicts a high Fe/Hf value, -1 if it predicts a low Fe/Hf value, or 0 if it does not match the rule.\n\nErrors in substructure matching are handled gracefully by returning 0 for that rule in the event of exceptions.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define the SMARTS patterns for functional groups\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    \n    # Aliphatic primary amine (-NH2)\n    primary_aliphatic_amine = '[NX3;H2][CX4]'\n    \n    # Thiol group (-SH)\n    thiol = '[SX2H]'\n    \n    # Thioether (-S-)\n    thioether = '[SX2][#6]'\n\n    # Sulfur functional groups (-SH or -S-)\n    sulfur_groups = [thiol, thioether]\n\n    # Aromatic carboxylic acid\n    aromatic_carboxylic_acid = '[c][CX3](=O)[OX2H1]'\n\n    # Electron-withdrawing groups (EWGs)\n    nitro_group = '[NX3](=O)=O'\n    halogens = '[F,Cl,Br,I]'\n    trifluoromethyl = '[CX4](F)(F)F'\n\n    # Electron-donating groups (EDGs)\n    amino_group = '[NX3;H2,H1][#6]'\n    methoxy_group = '[OX2][CH3]'\n    hydroxyl_group = '[OX2H]'\n    edg_groups = [amino_group, methoxy_group, hydroxyl_group]\n\n    # Polyether chain (simplified as two or more ether linkages)\n    ether_linkage = '[#6][OX2][#6]'\n    \n    # Aromatic ring\n    aromatic_ring = '[a]'\n\n    # Perfluorinated chains\n    perfluoro_alkane = '[CX4](F)(F)(F)'\n    perfluoro_alkene = '[CX3](F)(F)=C(F)[F]'\n\n    # Pyridine ring\n    pyridine = 'n1ccccc1'\n\n    # Phenolic hydroxyl group\n    phenolic_hydroxyl = '[c][OX2H]'\n\n    rules = [\n        {\n            'number': 1,\n            'description': 'Rule 1: Modifiers that are aliphatic carboxylic acids with a terminal primary amino group (-NH2) and without additional carboxyl groups.',\n            'patterns': [\n                carboxylic_acid,\n                primary_aliphatic_amine,\n            ],\n            'exclude_patterns': [\n                aromatic_ring,\n            ],\n            'count_patterns': {\n                carboxylic_acid: 1,\n            },\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Rule 2: Modifiers containing sulfur functional groups (-SH or thioethers) along with a carboxylic acid group.',\n            'patterns': [\n                carboxylic_acid,\n                sulfur_groups,\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Rule 3: Modifiers that are aromatic carboxylic acids with strong EWGs at the para position (e.g., nitro, bromomethyl).',\n            'patterns': [\n                aromatic_carboxylic_acid,\n                [halogens, nitro_group],\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Rule 4: Modifiers with flexible polyether chains terminating with coordinating groups (e.g., carboxyl or amino groups).',\n            'patterns': [\n                ether_linkage,\n                [carboxylic_acid, amino_group],\n            ],\n            'count_threshold': {\n                ether_linkage: 2,\n            },\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Rule 5: Modifiers that are aliphatic carboxylic acids without additional coordinating functional groups.',\n            'patterns': [\n                carboxylic_acid,\n            ],\n            'exclude_patterns': [\n                amino_group,\n                hydroxyl_group,\n                sulfur_groups,\n                ether_linkage,\n                halogens,\n                aromatic_ring,\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 6,\n            'description': 'Rule 6: Modifiers that are aromatic carboxylic acids with EDGs at the para position.',\n            'patterns': [\n                aromatic_carboxylic_acid,\n                edg_groups,\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Rule 7: Modifiers that are aromatic carboxylic acids with phenolic hydroxyl groups.',\n            'patterns': [\n                aromatic_carboxylic_acid,\n                phenolic_hydroxyl,\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Rule 8: Modifiers that are polyhydroxy aliphatic acids (with multiple adjacent hydroxyl groups).',\n            'patterns': [\n                carboxylic_acid,\n                hydroxyl_group,\n            ],\n            'count_threshold': {\n                hydroxyl_group: 2,\n            },\n            'exclude_patterns': [\n                aromatic_ring,\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Rule 9: Modifiers that are aromatic carboxylic acids substituted with pyridyl groups.',\n            'patterns': [\n                aromatic_carboxylic_acid,\n                pyridine,\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 10,\n            'description': 'Rule 10: Modifiers that are aliphatic carboxylic acids with a terminal hydroxyl group (-OH) and no additional hydroxyl or carboxyl groups.',\n            'patterns': [\n                carboxylic_acid,\n                hydroxyl_group,\n            ],\n            'exclude_patterns': [\n                aromatic_ring,\n            ],\n            'count_patterns': {\n                carboxylic_acid: 1,\n                hydroxyl_group:1,\n            },\n            'prediction': 1\n        },\n        {\n            'number': 11,\n            'description': 'Rule 11: Modifiers that are aromatic carboxylic acids fused with oxygen-containing heterocycles.',\n            'patterns': [\n                aromatic_carboxylic_acid,\n                '[o]1cccc1',  # Furan ring\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 12,\n            'description': 'Rule 12: Modifiers that are amino acids with hydrophobic side chains (high) or polar/bulky aromatic side chains (low).',\n            'patterns': [\n                '[NX3;H2][CX4;!$(C[OX2H])][CX3](=O)[OX2H1]',\n            ],\n            'substructure_patterns': {\n                'hydrophobic': [\n                    '[CX4][CH3]',  # Methyl group (alanine)\n                    '[CX4][CX4][CH3]',  # Ethyl group (valine)\n                    '[CX4][c1ccccc1]',  # Phenyl group (phenylalanine)\n                ],\n                'polar_aromatic': [\n                    '[CX4][c1c[nH]c2c1cccc2]',  # Indole ring (tryptophan)\n                    '[CX4][c1ccncc1]',  # Pyridine ring\n                    '[CX4][CX3](=O)[NX3]',  # Amide linkage (glutamine)\n                    '[CX4][OX2H]',  # Hydroxyl side chain (serine)\n                ],\n            },\n            'prediction': None  # Prediction depends on side chain type\n        },\n        {\n            'number':13,\n            'description': 'Rule 13: Modifiers containing perfluorinated chains.',\n            'patterns': [\n                perfluoro_alkane,\n            ],\n            'prediction': -1\n        },\n    ]\n\n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for pattern in rule.get('patterns', []):\n            # If pattern is a list of patterns, compile each\n            if isinstance(pattern, list):\n                compiled_subpatterns = [Chem.MolFromSmarts(pat) for pat in pattern]\n                compiled_patterns.append(compiled_subpatterns)\n            else:\n                compiled_patterns.append([Chem.MolFromSmarts(pattern)])\n        rule['compiled_patterns'] = compiled_patterns\n\n        # Compile exclude patterns\n        exclude_patterns = rule.get('exclude_patterns', [])\n        compiled_exclude = []\n        for pattern in exclude_patterns:\n            # If pattern is a list of patterns, compile each\n            if isinstance(pattern, list):\n                compiled_subpatterns = [Chem.MolFromSmarts(pat) for pat in pattern]\n                compiled_exclude.extend(compiled_subpatterns)\n            else:\n                compiled_exclude.append(Chem.MolFromSmarts(pattern))\n        rule['compiled_exclude_patterns'] = compiled_exclude\n\n        # Compile substructure patterns for Rule 12\n        if rule.get('substructure_patterns'):\n            compiled_substructure_patterns = {}\n            for key, patterns in rule['substructure_patterns'].items():\n                compiled_substructure_patterns[key] = [Chem.MolFromSmarts(pat) for pat in patterns]\n            rule['compiled_substructure_patterns'] = compiled_substructure_patterns\n\n    # Initialize results\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n\n                # Check exclude patterns\n                for pat in rule.get('compiled_exclude_patterns', []):\n                    if mol.HasSubstructMatch(pat):\n                        match = False\n                        break\n                if not match:\n                    row.append(0)\n                    continue\n\n                # Check required patterns\n                for group in rule['compiled_patterns']:\n                    group_match = False\n                    for pat in group:\n                        matches = mol.GetSubstructMatches(pat)\n                        if matches:\n                            # If a count threshold is specified for this pattern\n                            count_thresholds = rule.get('count_threshold', {})\n                            if pat.GetSmarts() in count_thresholds:\n                                if len(matches) >= count_thresholds[pat.GetSmarts()]:\n                                    group_match = True\n                                    break\n                            else:\n                                group_match = True\n                                break\n                    if not group_match:\n                        match = False\n                        break\n\n                # Check count patterns\n                count_patterns = rule.get('count_patterns', {})\n                for smarts_pattern, count_required in count_patterns.items():\n                    pat = Chem.MolFromSmarts(smarts_pattern)\n                    matches = mol.GetSubstructMatches(pat)\n                    if len(matches) != count_required:\n                        match = False\n                        break\n                if not match:\n                    row.append(0)\n                    continue\n\n                # For Rule 12, need special handling\n                if rule['number'] ==12:\n                    is_hydrophobic = False\n                    is_polar = False\n                    # Check hydrophobic side chains\n                    for pat in rule['compiled_substructure_patterns']['hydrophobic']:\n                        if mol.HasSubstructMatch(pat):\n                            is_hydrophobic = True\n                            break\n                    # Check polar/aromatic side chains\n                    for pat in rule['compiled_substructure_patterns']['polar_aromatic']:\n                        if mol.HasSubstructMatch(pat):\n                            is_polar = True\n                            break\n                    if is_hydrophobic:\n                        row.append(1)\n                    elif is_polar:\n                        row.append(-1)\n                    else:\n                        # Side chain not identified, default to 0\n                        row.append(0)\n                else:\n                    if match:\n                        row.append(rule['prediction'])\n                    else:\n                        row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df"
}