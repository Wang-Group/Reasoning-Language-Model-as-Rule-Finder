{
    "prefix": "This code defines a function named rule2matrix that converts a list of SMILES strings into a feature matrix based on the specified rules using RDKit. Each rule is represented by SMARTS patterns that match certain structural features described in the rules. The function returns a pandas DataFrame where each column corresponds to a rule, and each row corresponds to a SMILES string from the input list. The values in the matrix are assigned as follows:\n\n- A value of 0 if the structural description of the rule does not match the SMILES.\n- A value of 1 if the structural description of the rule matches the SMILES and predicts a high target value.\n- A value of -1 if the structural description of the rule matches the SMILES and predicts a low target value.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX1H1]'\n    \n    # Primary aliphatic amine group (-NH2)\n    primary_aliphatic_amine = '[NX3H2][CX4]'\n    \n    # Aliphatic chain with terminal amino and carboxylic acid groups (\u03c9-amino acid)\n    omega_amino_acid = '[NX3H2][CH2]{3,}[CX3](=O)[OX1H1]'\n    \n    # Aromatic carboxylic acid (benzoic acid)\n    aromatic_carboxylic_acid = 'c1ccccc1C(=O)[O;H]'\n    \n    # Electron-withdrawing groups (EWGs)\n    nitro_group = '[N+](=O)[O-]'\n    bromomethyl_group = '[CH2Br]'\n    \n    # Electron-donating groups (EDGs)\n    amino_group = '[NH2]'\n    methyl_group = '[CH3]'\n    hydroxy_group = '[OH]'\n    \n    # Thiol group (-SH)\n    thiol_group = '[SX2H]'\n    \n    # Pyridine ring\n    pyridine_ring = 'n1ccccc1'\n    \n    # Multiple hydroxyl groups (polyols)\n    hydroxyl_group = '[OX2H]'\n    \n    # Aromatic ring with ortho-hydroxyl or ortho-carbonyl groups\n    ortho_hydroxyl_carbonyl = '[c][c](O)[c](C(=O)O)[c]'\n    \n    # Perfluorinated alkyl chain attached to carboxylic acid\n    perfluoro_alkyl_carboxylic_acid = 'C(F)(F)F'\n    \n    # Methoxy group on aromatic ring\n    methoxy_on_aromatic = 'c[OX2][CH3]'\n    \n    # Indole ring (tryptophan side chain)\n    indole_ring = 'c1cc2ccccc2[nH]1'\n    \n    # Aromatic amide group adjacent to aromatic ring\n    aromatic_amide = 'c1ccc(cc1)C(=O)N'\n    \n    # Aliphatic chain containing ether groups and terminal carboxylic acid\n    aliphatic_ether_chain = '[#6]-O-[#6]-O-[#6]-C(=O)[O;H]'\n    \n    # Define the rules with their associated patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are \u03c9-amino acids (aliphatic chains with terminal amino and carboxylic acid groups) predict a high Fe/Hf value (True).',\n            'patterns': [omega_amino_acid],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers that are aromatic carboxylic acids substituted at the para position with strong electron-withdrawing groups (e.g., nitro, bromomethyl) predict a high Fe/Hf value (True).',\n            'patterns': ['[cAH]1[cAH][cAH]([C](=O)[O;H])[cAH][cAH]([$(N(=O)=O),$(CBr)])c1'],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers that are aromatic carboxylic acids substituted at the para position with electron-donating groups (e.g., amino, methyl, hydroxy) predict a low Fe/Hf value (False).',\n            'patterns': ['[cAH]1[cAH][cAH]([C](=O)[O;H])[cAH][cAH]([$(NH2),$(CH3),$(OH)])c1'],\n            'prediction': -1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers containing both a carboxylic acid group and a thiol group (-SH) predict a high Fe/Hf value (True).',\n            'patterns': [carboxylic_acid, thiol_group],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers with pyridine rings that can act as ligands predict a high Fe/Hf value (True).',\n            'patterns': [pyridine_ring, carboxylic_acid],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers that are amino acids with side chains containing additional coordinating groups (e.g., amino, thiol, methoxy) predict a high Fe/Hf value (True).',\n            'patterns': ['[NX3][CX4][CX3](=O)[OX1H1]', '[CX4][NX3H2]', '[CX4][SX2H]', '[CX4][OX2][CH3]'],\n            'prediction': 1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers with flexible aliphatic chains containing ether groups and a terminal carboxylic acid predict a high Fe/Hf value (True).',\n            'patterns': [aliphatic_ether_chain],\n            'prediction': 1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers that are simple aliphatic carboxylic acids without additional coordinating functional groups predict a low Fe/Hf value (False).',\n            'patterns': [carboxylic_acid],\n            'exclude_patterns': [primary_aliphatic_amine, thiol_group, aliphatic_ether_chain, hydroxyl_group],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers with multiple hydroxyl groups and a carboxylic acid predict a low Fe/Hf value (False).',\n            'patterns': [carboxylic_acid, hydroxyl_group],\n            'count_threshold': {'[OX2H]': 2},\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers that are aromatic carboxylic acids with ortho-hydroxyl or ortho-carbonyl groups predict a low Fe/Hf value (False).',\n            'patterns': ['[cAH]1[cAH]([OH])[cAH][cAH]([C](=O)[O;H])[cAH]c1'],\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers containing perfluorinated alkyl chains attached to a carboxylic acid predict a low Fe/Hf value (False).',\n            'patterns': [carboxylic_acid, perfluoro_alkyl_carboxylic_acid],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers with aromatic rings and methoxy substituents predict a high Fe/Hf value (True).',\n            'patterns': [methoxy_on_aromatic, aromatic_carboxylic_acid],\n            'prediction': 1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers that are amino acids with bulky aromatic side chains (e.g., indole from tryptophan) predict a low Fe/Hf value (False).',\n            'patterns': [indole_ring, '[NX3][CX3](=O)[OX1H1]'],\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers with aliphatic chains containing a hydroxyl group and a carboxylic acid predict a high Fe/Hf value (True), provided there is minimal steric hindrance.',\n            'patterns': [carboxylic_acid, hydroxyl_group],\n            'exclude_patterns': [hydroxyl_group + hydroxyl_group],  # Exclude multiple hydroxyl groups\n            'prediction': 1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers that are aromatic carboxylic acids with side chains that may hinder coordination through steric or electronic effects predict a low Fe/Hf value (False).',\n            'patterns': [aromatic_carboxylic_acid, aromatic_amide],\n            'prediction': -1\n        }\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        try:\n            compiled_patterns = [Chem.MolFromSmarts(p) for p in rule.get('patterns', [])]\n            rule['compiled_patterns'] = compiled_patterns\n            # Compile exclude patterns if any\n            if 'exclude_patterns' in rule:\n                compiled_excludes = [Chem.MolFromSmarts(p) for p in rule['exclude_patterns']]\n                rule['compiled_exclude_patterns'] = compiled_excludes\n        except Exception as e:\n            # Handle exception if SMARTS pattern cannot be compiled\n            rule['compiled_patterns'] = []\n            rule['compiled_exclude_patterns'] = []\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for pat in rule['compiled_exclude_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for pat in rule['compiled_patterns']:\n                    matches = mol.GetSubstructMatches(pat)\n                    if not matches:\n                        match = False\n                        break\n                    # If a count threshold is specified for this pattern\n                    if 'count_threshold' in rule and pat.GetSmarts() in rule['count_threshold']:\n                        threshold = rule['count_threshold'][pat.GetSmarts()]\n                        if len(matches) < threshold:\n                            match = False\n                            break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df"
}