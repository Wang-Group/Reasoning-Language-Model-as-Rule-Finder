{
    "prefix": "This code defines a function `rule2matrix` that converts a list of SMILES strings into a feature matrix using RDKit. The function applies eleven structural rules to each SMILES string, using SMARTS patterns for substructure matching. Each rule predicts whether a modifier will have a high or low Fe/Hf value based on its structural features. The output is a pandas DataFrame where each column corresponds to one rule, and each row corresponds to one SMILES string from the input list. The values are 1 if the rule matches and predicts a high Fe/Hf value, -1 if the rule matches and predicts a low Fe/Hf value, and 0 if the rule does not match.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define the SMARTS patterns for each rule\n    \n    # Rule 1: Aliphatic amino acids with side chains containing an amino or acetamido group (with six or more carbons) result in a high Fe/Hf value.\n    rule1_patterns = [\n        Chem.MolFromSmarts('[NX3H2][C][C][C][C][C;$(C(N))[CX3](=O)[OX1H]]'),  # Amino acid with side chain containing amino group\n        Chem.MolFromSmarts('[NX3H2][C][C][C][C][C;$(C(NC(=O)C))[CX3](=O)[OX1H]]')  # Amino acid with side chain containing acetamido group\n    ]\n    \n    # Rule 2: Aromatic carboxylic acids with electron-withdrawing groups at the para position result in a high Fe/Hf value.\n    rule2_patterns = [\n        Chem.MolFromSmarts('c1cc([CX3](=O)[OX1H])ccc1[F,Cl,Br,I,N+](=O)[O-]'),  # Para-substituted EWG\n        Chem.MolFromSmarts('c1cc([CX3](=O)[OX1H])ccc1C(=O)[#6]')  # Para-acyl group\n    ]\n    \n    # Rule 3: Modifiers containing both a thiol (-SH) group and a carboxylic acid group\n    rule3_pattern = Chem.MolFromSmarts('[#6][SX2H].[CX3](=O)[OX1H]')\n    \n    # Rule 4: Modifiers with pyridine rings attached via the para position to a carboxylic acid group\n    rule4_pattern = Chem.MolFromSmarts('c1ccncc1-c2ccccc2C(=O)O')\n    \n    # Rule 5: Modifiers with flexible polyether chains terminating with a carboxylic acid or amino group\n    rule5_patterns = [\n        Chem.MolFromSmarts('[OX2][CH2][OX2][CH2][OX2][CH2][CX3](=O)[OX1H]'),  # Polyether chain ending with COOH\n        Chem.MolFromSmarts('[OX2][CH2][OX2][CH2][OX2][CH2][NH2]')  # Polyether chain ending with NH2\n    ]\n    \n    # Rule 6: Aliphatic carboxylic acids with medium-length (C7\u2013C8) chains and terminal hydroxyl or amino groups\n    rule6_patterns = [\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CH2][CH2][CH2][CH2][CH2][CH2][OX2H]'),  # C7 chain with terminal OH\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CH2][CH2][CH2][CH2][CH2][CH2][NH2]')   # C7 chain with terminal NH2\n    ]\n    \n    # Rule 7: Amino acids with small or non-coordinating side chains\n    rule7_pattern = Chem.MolFromSmarts('[NX3H2][CH][C](C)[CX3](=O)[OX1H]')\n    \n    # Rule 8: Aromatic carboxylic acids with electron-donating substituents at the para position\n    rule8_patterns = [\n        Chem.MolFromSmarts('c1cc([CX3](=O)[OX1H])cc(c1)[OX2H]'),  # Para-hydroxybenzoic acid\n        Chem.MolFromSmarts('c1cc([CX3](=O)[OX1H])cc(c1)[OCH3]')   # Para-methoxybenzoic acid\n    ]\n    \n    # Rule 9: Modifiers containing multiple hydroxyl groups (polyols) without strong coordinating groups\n    rule9_pattern = Chem.MolFromSmarts('[#6][OX2H][#6][OX2H][#6][OX2H][CX3](=O)[OX1H]')\n    \n    # Rule 10: Modifiers with aldehyde groups adjacent to carboxylic acids\n    rule10_pattern = Chem.MolFromSmarts('[CX3H](=O)c[CX3](=O)[OX1H]')\n    \n    # Rule 11: Modifiers lacking strong coordinating groups and containing perfluoroalkyl chains\n    rule11_pattern = Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4](F)(F)[F]')\n    \n    # Combine all rules into a list\n    rules = [\n        {'number': 1, 'patterns': rule1_patterns, 'prediction': 1},\n        {'number': 2, 'patterns': rule2_patterns, 'prediction': 1},\n        {'number': 3, 'patterns': [rule3_pattern], 'prediction': 1},\n        {'number': 4, 'patterns': [rule4_pattern], 'prediction': 1},\n        {'number': 5, 'patterns': rule5_patterns, 'prediction': 1},\n        {'number': 6, 'patterns': rule6_patterns, 'prediction': 1},\n        {'number': 7, 'patterns': [rule7_pattern], 'prediction': -1},\n        {'number': 8, 'patterns': rule8_patterns, 'prediction': -1},\n        {'number': 9, 'patterns': [rule9_pattern], 'prediction': -1},\n        {'number': 10, 'patterns': [rule10_pattern], 'prediction': -1},\n        {'number': 11, 'patterns': [rule11_pattern], 'prediction': -1}\n    ]\n    \n    # Initialize the results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            match = False\n            try:\n                for pattern in rule['patterns']:\n                    if mol.HasSubstructMatch(pattern):\n                        match = True\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    \n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df"
}