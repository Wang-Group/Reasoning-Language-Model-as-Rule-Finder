{
    "prefix": "This code defines a function to convert a list of SMILES strings into a feature matrix based on a set of chemical rules using RDKit. Each rule corresponds to a substructure pattern that, if matched in a molecule, will result in a prediction of either a high (+1) or low (-1) Fe/Hf value, or 0 if the rule does not match. The function compiles the SMARTS patterns for each rule and applies them to each molecule in the SMILES list, constructing a DataFrame of the results.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    primary_aliphatic_amine = '[NX3H2][CX4]'\n    thiol_group = '[SX2H]'\n    thioether_group = '[SX2][#6]'\n    ether_linkage = '[#6][OX2][#6]'\n    pyridine_ring = '[n][a][a][a][a][a]'\n    halogen_on_aromatic = '[c][F,Cl,Br,I]'\n    nitro_group_on_aromatic = '[c][N+](=O)[O-]'\n    methyl_on_aromatic = '[c][CH3]'\n    methoxy_on_aromatic = '[c][OCH3]'\n    hydroxyl_on_aromatic = '[c][OH]'\n    hydroxyl_group = '[OX2H]'\n    aldehyde_on_aromatic = '[c][CX3H](=O)'\n    fluorinated_alkyl = '[CX4]([F])([F])[F]'\n    aromatic_carboxylic_acid = '[c][CX3](=O)[OX2H1]'\n    amino_acid_aromatic_side_chain = '[NX3][CX4][CX4][c]1[c][c][c][c][c]1'\n    multiple_carboxylic_acids = '[CX3](=O)[OX2H1].[CX3](=O)[OX2H1]'\n\n    # Define the rules with their associated patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'High Fe/Hf Value (True): Modifiers that are \u03c9-amino aliphatic carboxylic acids\u2014linear aliphatic chains with a terminal amino group (-NH2) at the end opposite the carboxylate group.',\n            'patterns': [[primary_aliphatic_amine], [carboxylic_acid]],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'High Fe/Hf Value (True): Modifiers capable of forming five-membered chelate rings through adjacent amino and carboxylate groups on short (four-carbon) aliphatic chains.',\n            'patterns': [[primary_aliphatic_amine], [carboxylic_acid]],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'High Fe/Hf Value (True): Modifiers that are aromatic carboxylic acids with strong electron-withdrawing groups\u2014such as nitro (-NO2) or halogens (e.g., bromo -Br)\u2014attached directly to the aromatic ring.',\n            'patterns': [[aromatic_carboxylic_acid], [halogen_on_aromatic, nitro_group_on_aromatic]],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'High Fe/Hf Value (True): Modifiers containing thiol (-SH) groups in proximity to carboxylate groups.',\n            'patterns': [[thiol_group], [carboxylic_acid]],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'High Fe/Hf Value (True): Modifiers that are aromatic carboxylic acids with pyridine rings or pyridinyl substituents capable of coordinating through nitrogen atoms.',\n            'patterns': [[pyridine_ring], [carboxylic_acid]],\n            'prediction': 1\n        },\n        # Additional rules (6 to 15) should be added here following the same structure\n    ]\n\n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for group in rule.get('patterns', []):\n            compiled_group = [Chem.MolFromSmarts(p) for p in group]\n            compiled_patterns.append(compiled_group)\n        rule['compiled_patterns'] = compiled_patterns\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for group in rule['exclude_patterns']:\n                compiled_group = [Chem.MolFromSmarts(p) for p in group]\n                compiled_excludes.append(compiled_group)\n            rule['compiled_exclude_patterns'] = compiled_excludes\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for group in rule['compiled_exclude_patterns']:\n                        for pat in group:\n                            if mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                        if not match:\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for compiled_group in rule['compiled_patterns']:\n                    group_match = False\n                    for pat in compiled_group:\n                        matches = mol.GetSubstructMatches(pat)\n                        if matches:\n                            group_match = True\n                            break\n                    if not group_match:\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}