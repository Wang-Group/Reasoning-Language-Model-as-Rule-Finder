{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit, based on specific chemical rules.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    rules = [\n        ['[CX3](=O)[OX2H1]', '[NX3H2]'],  # Rule 1: Carboxylic acid and amino group\n        ['c1cc(O)ccc1'],  # Rule 2: Phenyl group with para hydroxyl\n        ['[SX2H]', '[CX3](=O)[OX2H1]'],  # Rule 3: Sulfanyl and carboxylic acid\n        ['c1cncc(C(=O)O)c1'],  # Rule 4: Pyridine with carboxylic acid\n        ['c1c[nH]c2c1cccc2', '[NX3H2]', '[OX2H1]'],  # Rule 5: Indole with electron-donating groups\n        ['[NX3+](=O)[O-]', '[c][OX2H1]'],  # Rule 6: Nitro with electron-donating groups\n        ['c1ccc(C(=O)O)cc1', '[Br,Cl,I,NX3+](=O)'],  # Rule 7: Benzoic acid with electron-withdrawing groups\n        ['[CX4](F)(F)(F)(F)'],  # Rule 8: Highly fluorinated alkyl chain\n        ['[OX2][CX4][OX2][CX4][OX2]'],  # Rule 9: Multiple ether linkages\n        ['[NX3H2][CX4][OX2H1]'],  # Rule 10: Amino and hydroxyl in a linear chain\n        ['[NX3H2][CX4][CX4][CX4][CX4][CX4][CX4]'],  # Rule 11: Long aliphatic chain with terminal amino\n        ['[CX3H]=O', '[NX3+](=O)'],  # Rule 12: Formyl with electron-withdrawing group\n        ['c1cc2c(c1)C(=O)OC2=O'],  # Rule 13: Benzofuranone structure\n        ['c1ccncc1', 'c1ccccc1'],  # Rule 14: Pyridine with non-conjugated phenyl\n        ['c1ccc(C(=O)O)cc1', '[CX3H]=O'],  # Rule 15: Carboxylic acid and formyl on benzene\n    ]\n    results = []\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            results.append([0] * len(rules))\n            continue\n        row = []\n        for i, rule in enumerate(rules):\n            try:\n                if all(mol.HasSubstructMatch(Chem.MolFromSmarts(r)) for r in rule):\n                    if i in [0, 1, 2, 3, 4, 5, 6, 12]:  # Rules predicting high yield\n                        row.append(1)\n                    else:  # Rules predicting low yield\n                        row.append(-1)\n                else:\n                    row.append(0)\n            except:\n                row.append(0)\n        results.append(row)\n    df = pd.DataFrame(results, columns=[f'Rule {i+1}' for i in range(len(rules))])\n    return df"
}