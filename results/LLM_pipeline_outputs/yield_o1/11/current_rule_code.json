{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit based on specified chemical rules. Each rule corresponds to structural patterns in the molecules that predict a high or low target value. The output is a DataFrame where each column corresponds to one rule, and each cell contains 0 if the rule does not match the molecule, 1 if the rule matches and predicts a high target value, or -1 if the rule matches and predicts a low target value.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and structural motifs\n    \n    # Rule 1 patterns\n    amino_acid_backbone = Chem.MolFromSmarts('[NX3][CX4H]([CX3](=O)[OX1H])[*]')\n    carboxylic_acid = Chem.MolFromSmarts('[CX3](=O)[OX1H]')\n    aromatic_nitrogen = Chem.MolFromSmarts('[n]')\n    \n    # Rule 2 patterns\n    aromatic_carboxylic_acid = Chem.MolFromSmarts('[c][CX3](=O)[OX1H]')\n    ewg_on_aromatic = [Chem.MolFromSmarts('[c][F]'), Chem.MolFromSmarts('[c][Cl]'),\n                       Chem.MolFromSmarts('[c][Br]'), Chem.MolFromSmarts('[c][I]'),\n                       Chem.MolFromSmarts('[c][NX3](=O)=O')]\n    edg_on_aromatic = [Chem.MolFromSmarts('[c][CH3]'), Chem.MolFromSmarts('[c][OX2H]'),\n                       Chem.MolFromSmarts('[c][OX2][CH3]')]\n    \n    # Rule 3 patterns\n    heterocyclic_carboxylic_acid = Chem.MolFromSmarts('[n][CX3](=O)[OX1H]')\n    \n    # Rule 5 patterns\n    thiol = Chem.MolFromSmarts('[SX2H]')\n    carboxylic_acid_adjacent_thiol = Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][SX2H]')\n    \n    # Rule 6 patterns\n    carboxylic_acid_adjacent_hydroxyl = Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][OX2H]')\n    multiple_ether_linkages = Chem.MolFromSmarts('[#6][OX2][#6][OX2][#6]')\n    \n    # Rule 7 patterns\n    aldehyde_adjacent_carboxylate = Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][CX3H](=O)')\n    ketone_near_carboxylate = Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][CX3](=O)[#6]')\n    amide_near_carboxylate = Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][NX3][CX3](=O)[#6]')\n    \n    # Rule 8 patterns\n    perfluoroalkyl_chain = Chem.MolFromSmarts('[CX4](F)(F)(F)')\n    \n    # Rule 9 patterns\n    aromatic_adjacent_carboxylate = Chem.MolFromSmarts('[CX3](=O)[OX1H][c]')\n    \n    # Define rules with their associated patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'High Yield: Modifiers that are amino acids with side chains containing additional coordinating groups such as extra carboxylate groups or nitrogen-containing heterocycles.',\n            'match_func': lambda mol: (\n                mol.HasSubstructMatch(amino_acid_backbone) and\n                (len(mol.GetSubstructMatches(carboxylic_acid)) > 1 or mol.HasSubstructMatch(aromatic_nitrogen))\n            ),\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'High Yield: Modifiers that are aromatic carboxylic acids with strong electron-withdrawing substituents attached directly to the aromatic ring.',\n            'match_func': lambda mol: (\n                mol.HasSubstructMatch(aromatic_carboxylic_acid) and\n                any(mol.HasSubstructMatch(pat) for pat in ewg_on_aromatic)\n            ),\n            'prediction': 1\n        },\n        {\n            'number': 2.1,\n            'description': 'Low Yield: Modifiers that are aromatic carboxylic acids with electron-donating substituents attached directly to the aromatic ring.',\n            'match_func': lambda mol: (\n                mol.HasSubstructMatch(aromatic_carboxylic_acid) and\n                any(mol.HasSubstructMatch(pat) for pat in edg_on_aromatic)\n            ),\n            'prediction': -1\n        },\n        {\n            'number': 3,\n            'description': 'High Yield: Modifiers containing nitrogenous heterocycles capable of coordinating with metals, such as pyridine or pyrazole carboxylic acids.',\n            'match_func': lambda mol: mol.HasSubstructMatch(heterocyclic_carboxylic_acid),\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'High Yield: Modifiers containing thiol groups near the carboxylate, such as mercapto carboxylic acids.',\n            'match_func': lambda mol: mol.HasSubstructMatch(carboxylic_acid_adjacent_thiol),\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'High Yield: Modifiers with multiple hydroxyl groups adjacent to the carboxylate. Low Yield: Modifiers with multiple ether linkages.',\n            'match_func': lambda mol: (\n                mol.HasSubstructMatch(carboxylic_acid_adjacent_hydroxyl) and\n                len(mol.GetSubstructMatches('[OX2H]')) > 2\n            ),\n            'prediction': 1\n        },\n        {\n            'number': 6.1,\n            'description': 'Low Yield: Modifiers with multiple ether linkages.',\n            'match_func': lambda mol: mol.HasSubstructMatch(multiple_ether_linkages),\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Low Yield: Modifiers that have aldehyde or ketone groups adjacent to the carboxylate, or amide bonds near the carboxylate.',\n            'match_func': lambda mol: (\n                mol.HasSubstructMatch(aldehyde_adjacent_carboxylate) or\n                mol.HasSubstructMatch(ketone_near_carboxylate) or\n                mol.HasSubstructMatch(amide_near_carboxylate)\n            ),\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Low Yield: Modifiers containing strong electron-withdrawing groups that excessively reduce electron density on the carboxylate, such as perfluoroalkyl chains.',\n            'match_func': lambda mol: mol.HasSubstructMatch(perfluoroalkyl_chain),\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Low Yield: Modifiers with bulky aromatic side chains without additional coordinating groups, especially when adjacent to the carboxylate.',\n            'match_func': lambda mol: mol.HasSubstructMatch(aromatic_adjacent_carboxylate),\n            'prediction': -1\n        }\n    ]\n    \n    # Initialize results list\n    results = []\n    \n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If molecule cannot be parsed, append zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                if rule['match_func'](mol):\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception:\n                row.append(0)\n        results.append(row)\n    \n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df\n"
}