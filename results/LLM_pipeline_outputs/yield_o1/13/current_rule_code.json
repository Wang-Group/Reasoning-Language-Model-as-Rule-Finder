{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. Each rule corresponds to a column in the DataFrame, and each SMILES string corresponds to a row. The code defines SMARTS patterns for each rule based on the specified structural descriptions and applies them to each molecule to generate the feature matrix. A value of 1 indicates that the molecule matches the rule and predicts a high target value, -1 indicates a low target value, and 0 indicates no match.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    import pandas as pd\n    from rdkit import Chem\n\n    # Define SMARTS patterns for the rules\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are \u03b1-amino dicarboxylic acids with the amino group adjacent to one carboxylate and an additional carboxylate side chain give high yield.',\n            'patterns': [\n                '[NX3;H2][CX4H]([#6])[CX3](=O)[OX2H1]',  # \u03b1-amino acid backbone\n                '[CX3](=O)[OX2H1]',  # Additional carboxylic acid group\n            ],\n            'min_counts': { '[CX3](=O)[OX2H1]': 2 },  # At least two carboxylic acid groups\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers that are aromatic carboxylic acids containing nitrogen heterocycles or nitrogenous aromatic systems give high yield.',\n            'patterns': [\n                '[n][a]',  # Nitrogen in an aromatic system\n                '[c][CX3](=O)[OX2H1]',  # Aromatic carboxylic acid group\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers that are aromatic carboxylic acids with strong electron-withdrawing groups at the para position (e.g., nitro, bromomethyl) give high yield.',\n            'patterns': [\n                '[c][CX3](=O)[OX2H1]',  # Aromatic carboxylic acid group\n                '[c][c][c]([NX3+](=O)[O-])[c][c]',  # Nitro group at para position\n                '[c][c][c]([CX4][Br])[c][c]',  # Bromomethyl group at para position\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers that are aliphatic carboxylic acids with amino or thiol groups within three carbons of the carboxyl group give high yield.',\n            'patterns': [\n                '[CX3](=O)[OX2H1][CX4][CX4][NX3;H2,H1]',  # Amino group within three carbons\n                '[CX3](=O)[OX2H1][CX4][CX4][SX2H]',  # Thiol group within three carbons\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers that are aliphatic carboxylic acids with long hydrophobic chains (e.g., eight carbons or more) give high yield.',\n            'patterns': [\n                '[CX3](=O)[OX2H1][CX4][CX4][CX4][CX4][CX4][CX4][CX4]',  # Chain of at least 8 carbons including carboxyl carbon\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers with multiple hydroxyl groups (polyhydroxy carboxylic acids) give high yield.',\n            'patterns': [\n                '[OX2H]',  # Hydroxyl group\n                '[CX3](=O)[OX2H1]',  # Carboxylic acid group\n            ],\n            'min_counts': { '[OX2H]': 2 },  # At least two hydroxyl groups\n            'prediction': 1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers that are aromatic carboxylic acids with electron-donating groups at the para position and short aliphatic chains give low yield.',\n            'patterns': [\n                '[c][CX3](=O)[OX2H1]',  # Aromatic carboxylic acid group\n                '[c][c][c]([c])[c][c]',  # Para position available for substituent\n                '[c][c][c]([CX4H3])[c][c]',  # Electron-donating group (e.g., methyl) at para position\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers with functional groups (e.g., amino, hydroxyl) more than four carbons away from the carboxyl group give low yield.',\n            'patterns': [\n                '[CX3](=O)[OX2H1]******[NX3;H2,H1]',  # Amino group more than four bonds away\n                '[CX3](=O)[OX2H1]******[OX2H]',  # Hydroxyl group more than four bonds away\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers containing fluorinated alkyl chains give low yield.',\n            'patterns': [\n                '[CX4]([F])[F]',  # CF2 groups in chain\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers with aldehyde or ketone groups adjacent to the carboxylic acid give low yield.',\n            'patterns': [\n                '[CX3](=O)[CX3](=O)[OX2H1]',  # Ketone adjacent to carboxylic acid\n                '[CX3H1](=O)[CX3](=O)[OX2H1]',  # Aldehyde adjacent to carboxylic acid\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers with ether linkages or polyether chains give low yield.',\n            'patterns': [\n                '[OX2][CX4][OX2]',  # Ether linkage in chain\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers with thiol groups attached directly to aromatic rings give low yield due to potential catalyst poisoning.',\n            'patterns': [\n                '[c][SX2H]',  # Thiol group attached to aromatic ring\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers that are amino acids with hydrophobic aromatic side chains lacking additional coordinating groups give low yield.',\n            'patterns': [\n                '[NX3;H2][CX4][CX3](=O)[OX2H1]',  # Amino acid backbone\n                '[c]',  # Aromatic ring in side chain\n            ],\n            'exclude_patterns': [\n                '[OX2H]',  # Exclude additional hydroxyl groups\n                '[NX3;H2,H1]',  # Exclude additional amino groups\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers containing aromatic oxygen heterocycles attached to carboxylic acids give high yield.',\n            'patterns': [\n                '[o][c]',  # Oxygen heterocycle\n                '[c][CX3](=O)[OX2H1]',  # Carboxylic acid group\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers with extended aliphatic chains bearing electron-donating groups on aromatic rings give high yield due to combined hydrophobic and coordination effects.',\n            'patterns': [\n                '[CX4][CX4][CX4][CX4][c][OX2H]',  # Extended chain to aromatic ring with hydroxyl group\n            ],\n            'prediction': 1\n        },\n    ]\n\n    # Precompile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for smarts in rule.get('patterns', []):\n            compiled_patterns.append(Chem.MolFromSmarts(smarts))\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for smarts in rule['exclude_patterns']:\n                compiled_excludes.append(Chem.MolFromSmarts(smarts))\n            rule['compiled_exclude_patterns'] = compiled_excludes\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for pat in rule['compiled_exclude_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for pat in rule['compiled_patterns']:\n                    matches = mol.GetSubstructMatches(pat)\n                    if not matches:\n                        match = False\n                        break\n                    # If a count threshold is specified for this pattern\n                    if 'min_counts' in rule and pat.GetSmarts() in rule['min_counts']:\n                        threshold = rule['min_counts'][pat.GetSmarts()]\n                        if len(matches) < threshold:\n                            match = False\n                            break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}