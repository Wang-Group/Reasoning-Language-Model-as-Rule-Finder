{
    "prefix": "This code defines a function `rule2matrix` that takes a list of SMILES strings and applies a set of chemical rules to generate a feature matrix. Each rule checks for specific structural patterns within the molecules, using SMARTS patterns, and predicts a High Yield (1), Low Yield (-1), or No Match (0). The code incorporates suggestions to improve pattern matching and includes all the rules specified, ensuring accurate assessments by refining SMARTS patterns, considering chain lengths, and checking functional group positions. The function returns a pandas DataFrame with the results, where each column corresponds to a rule and each row corresponds to a SMILES string.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups using corrected patterns from suggestions\n    \n    # Carboxylic acid group (-COOH or -COO-)\n    carboxylic_acid_patterns = ['[CX3](=O)[OX1H1]', '[CX3](=O)[O-]']\n    \n    # Alpha amino acid with dicarboxylic acid groups (Rule 1)\n    alpha_amino_acid_dicarboxylic = '[NX3;H2][CX4][CX3](=O)[OX1H1]'\n    \n    # Adjacent carboxylic acids for dicarboxylic acid (Rule 1)\n    dicarboxylic_acid = '[CX3](=O)[OX1H1][CX4][CX3](=O)[OX1H1]'\n    \n    # Omega amino aliphatic carboxylic acids (Rule 2 and Rule 9)\n    amino_group = '[NX3;H2,H1]'\n    \n    # Adjacent hydroxyl groups (vicinal diols) (Rule 3)\n    vicinal_diol = '[CX4H]([OX2H])[CX4H]([OX2H])'\n    \n    # Electron-withdrawing groups (EWGs) for Rule 4\n    ewg_patterns = ['[N+](=O)[O-]', 'C#N', '[CX3](F)(F)F', '[S](=O)(=O)[O-]', '[F,Cl,Br,I]']\n    \n    # Electron-donating groups (EDGs) for Rule 14\n    edg_patterns = ['[CH3]', '[OX2H]', '[OX2][CH3]', '[NX3;H2]']\n    \n    # Sulfur-containing groups (Rule 10)\n    sulfur_functional_groups = ['[#16]']  # Any sulfur atom\n    \n    # Bulky amide near coordinating site (Rule 15)\n    bulky_amide_near_coordination = '[NX3][CX3](=O)[CX4][CX4][NX3;H2]'\n    \n    # Define the rules with their associated patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are \u03b1-amino acids with dicarboxylic acid groups result in a High Yield.',\n            'patterns': [alpha_amino_acid_dicarboxylic],\n            'count_patterns': {''.join(carboxylic_acid_patterns): 2},\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers that are small \u03c9-amino aliphatic carboxylic acids with chain lengths of five or fewer carbons result in a High Yield.',\n            'patterns': carboxylic_acid_patterns + [amino_group],\n            'max_chain_length': 5,\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers that are aliphatic carboxylic acids with multiple adjacent hydroxyl groups result in a High Yield.',\n            'patterns': carboxylic_acid_patterns + [vicinal_diol],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers that are aromatic carboxylic acids with strong electron-withdrawing groups at the para position result in a High Yield.',\n            'patterns': ['c1cc([#6])cc([#6])c1[CX3](=O)[OX1H1]'],\n            'ewg_patterns': ewg_patterns,\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers that are aromatic carboxylic acids with para-amino groups result in a High Yield.',\n            'patterns': ['c1ccc(N)cc1[CX3](=O)[OX1H1]'],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers that are nitrogen-containing heterocyclic carboxylic acids with the carboxyl group directly attached to the ring result in a High Yield.',\n            'patterns': ['[nH0;r5,r6][c,n][c,n][c,n][c,n][CX3](=O)[OX1H1]'],\n            'prediction': 1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers that are aliphatic carboxylic acids with long hydrocarbon chains and without additional functional groups result in a High Yield.',\n            'patterns': carboxylic_acid_patterns + ['[CH2][CH2][CH2][CH2][CH2][CH2][CH2]'],\n            'exclude_patterns': ['[!#6;!H0]'],\n            'prediction': 1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers that are aromatic amino acids with extended conjugation result in a High Yield.',\n            'patterns': ['[NX3;H2][CX4H][CX3](=O)[OX1H1][CX4][c]1c2ccccc2[nH]c1'],\n            'prediction': 1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers that are \u03c9-amino aliphatic carboxylic acids with chain lengths longer than five carbons result in a Low Yield.',\n            'patterns': carboxylic_acid_patterns + [amino_group],\n            'min_chain_length': 6,\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers containing sulfur-functional groups result in a Low Yield.',\n            'patterns': sulfur_functional_groups,\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers that are aromatic carboxylic acids with aldehyde groups adjacent to the carboxylic acid result in a Low Yield.',\n            'patterns': ['c1cc(C=O)cc([#6])c1[CX3](=O)[OX1H1]'],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers with perfluorinated alkyl chains or trifluoromethyl groups result in a Low Yield.',\n            'patterns': ['[CX4](F)(F)F', '[CX4](F)(F)(F)[CX4](F)(F)(F)'],\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers that are aliphatic carboxylic acids with long chain ether linkages result in a Low Yield.',\n            'patterns': carboxylic_acid_patterns + ['[#6][OX2][#6][OX2][#6][OX2][#6]'],\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers that are aromatic carboxylic acids with weak electron-donating groups at the para position result in a Low Yield.',\n            'patterns': ['c1cc([C,N,O;X4&H0])cc([#6])c1[CX3](=O)[OX1H1]'],\n            'edg_patterns': edg_patterns,\n            'prediction': -1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers featuring bulky amide groups near coordinating sites tend to result in a Low Yield.',\n            'patterns': [bulky_amide_near_coordination],\n            'prediction': -1\n        }\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        # Compile include patterns\n        rule['compiled_patterns'] = [Chem.MolFromSmarts(pat) for pat in rule.get('patterns', [])]\n        # Compile exclude patterns\n        if 'exclude_patterns' in rule:\n            rule['compiled_exclude_patterns'] = [Chem.MolFromSmarts(pat) for pat in rule['exclude_patterns']]\n        # Compile EWG and EDG patterns if any\n        if 'ewg_patterns' in rule:\n            rule['compiled_ewg_patterns'] = [Chem.MolFromSmarts(pat) for pat in rule['ewg_patterns']]\n        if 'edg_patterns' in rule:\n            rule['compiled_edg_patterns'] = [Chem.MolFromSmarts(pat) for pat in rule['edg_patterns']]\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'compiled_exclude_patterns' in rule:\n                    for pat in rule['compiled_exclude_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for pat in rule['compiled_patterns']:\n                    if not mol.HasSubstructMatch(pat):\n                        match = False\n                        break\n                if not match:\n                    row.append(0)\n                    continue\n                # Additional checks\n                if 'count_patterns' in rule:\n                    for patt, count in rule['count_patterns'].items():\n                        patt_mol = Chem.MolFromSmarts(patt)\n                        matches = mol.GetSubstructMatches(patt_mol)\n                        if len(matches) < count:\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                if 'adjacent_hydroxyls' in rule and rule['adjacent_hydroxyls']:\n                    # Check for adjacent hydroxyl groups\n                    vicinal_diol_pat = Chem.MolFromSmarts(vicinal_diol)\n                    if not mol.HasSubstructMatch(vicinal_diol_pat):\n                        match = False\n                        row.append(0)\n                        continue\n                if 'max_chain_length' in rule or 'min_chain_length' in rule:\n                    # Check chain length between amino group and carboxylic acid\n                    amino_atoms = [match[0] for match in mol.GetSubstructMatches(Chem.MolFromSmarts(amino_group))]\n                    carboxylic_atoms = []\n                    for patt in carboxylic_acid_patterns:\n                        carboxylic_atoms.extend([match[0] for match in mol.GetSubstructMatches(Chem.MolFromSmarts(patt))])\n                    shortest_path_length = None\n                    for n_idx in amino_atoms:\n                        for c_idx in carboxylic_atoms:\n                            try:\n                                path = Chem.rdmolops.GetShortestPath(mol, n_idx, c_idx)\n                                path_length = len(path) - 1\n                                if shortest_path_length is None or path_length < shortest_path_length:\n                                    shortest_path_length = path_length\n                            except:\n                                continue\n                    if shortest_path_length is None:\n                        match = False\n                        row.append(0)\n                        continue\n                    if 'max_chain_length' in rule and shortest_path_length > rule['max_chain_length']:\n                        match = False\n                        row.append(0)\n                        continue\n                    if 'min_chain_length' in rule and shortest_path_length < rule['min_chain_length']:\n                        match = False\n                        row.append(0)\n                        continue\n                if 'compiled_ewg_patterns' in rule:\n                    # Check for EWG at para position\n                    ewg_match = False\n                    for ewg_pat in rule['compiled_ewg_patterns']:\n                        if mol.HasSubstructMatch(ewg_pat):\n                            ewg_match = True\n                            break\n                    if not ewg_match:\n                        match = False\n                        row.append(0)\n                        continue\n                if 'compiled_edg_patterns' in rule:\n                    # Check for EDG at para position\n                    edg_match = False\n                    for edg_pat in rule['compiled_edg_patterns']:\n                        if mol.HasSubstructMatch(edg_pat):\n                            edg_match = True\n                            break\n                    if not edg_match:\n                        match = False\n                        row.append(0)\n                        continue\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}