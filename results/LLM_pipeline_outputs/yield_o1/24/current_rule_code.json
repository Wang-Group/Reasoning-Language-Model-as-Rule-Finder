{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. It defines SMARTS patterns corresponding to the provided rules, applies them to the SMILES strings, and generates a DataFrame where each column represents a rule and each row corresponds to a SMILES string. Each cell contains 1, -1, or 0 depending on whether the rule matches and whether it predicts a high or low yield.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define the rules with their corrected SMARTS patterns\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers containing both amino and carboxylic acid groups on short aliphatic chains (2 to 5 carbons) lead to high yield.',\n            'pattern': '[NX3;H2][CH2]{1,4}[CX3](=O)[OX1H0-,OX2H1]',\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Aromatic carboxylic acids with para-substituents capable of metal coordination lead to high yield.',\n            'pattern': 'c1cc([$(N),$(O)])ccc1C(=O)[OX1H0-,OX2H1]',\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers with multiple hydroxyl groups near carboxylic acid groups lead to high yield.',\n            'pattern': '[OX2H]',\n            'min_count': 2,\n            'additional_pattern': '[CX3](=O)[OX1H0-,OX2H1]',\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers with heterocyclic nitrogen atoms capable of metal coordination lead to high yield.',\n            'pattern': '[$(n1ccccc1),$(n1ncccc1),$(c1ncccc1)][CX3](=O)[OX1H0-,OX2H1]',\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers with sulfhydryl groups on short chains lead to high yield.',\n            'pattern': '[SX2H][CH2]{0,3}[CX3](=O)[OX1H0-,OX2H1]',\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers with long aliphatic chains without additional polar functional groups result in high yield.',\n            'pattern': '[CH2]{5,7}[CX3](=O)[OX1H0-,OX2H1]',\n            'exclude_patterns': ['[OX2H]', '[NX3;H2,H1]', '[#6][OX2][#6]', '[F,Cl,Br,I]', '[#6]=[O]', '[#6]#[N]'],\n            'prediction': 1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers with electron-withdrawing groups adjacent to carboxylic acid groups lead to low yield.',\n            'patterns': ['[#6][CX3](=O)[CX3](=O)[OX1H0-,OX2H1]', '[CX3H1](=O)[CX3](=O)[OX1H0-,OX2H1]', '[#6][C](F)(F)F[CX3](=O)[OX1H0-,OX2H1]'],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers containing amide bonds adjacent to carboxylic acid groups lead to low yield.',\n            'pattern': '[CX3](=O)[NX3][CH2]*[CX3](=O)[OX1H0-,OX2H1]',\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers with flexible polyether chains lead to low yield.',\n            'pattern': '[#6][OX2][#6][OX2][#6][OX2][#6][CX3](=O)[OX1H0-,OX2H1]',\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers with nitrogen-containing aromatic side chains lead to high yield.',\n            'pattern': '[#6][c][n].*[CX3](=O)[OX1H0-,OX2H1]',\n            'prediction': 1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers with aldehyde or ketone groups on aliphatic chains lead to low yield.',\n            'pattern': '[#6][CH2]{1,5}[CX3](=O)[CX3H1](=O)',\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers with aromatic systems capable of chelation lead to high yield.',\n            'pattern': 'c1cc(O)cc(C(=O)[OX1H0-,OX2H1])c1',\n            'prediction': 1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers with bulky substituents near coordination sites lead to low yield.',\n            'pattern': '[CX4]([#6])([#6])([#6])[#6].*[CX3](=O)[OX1H0-,OX2H1]',\n            'prediction': -1\n        }\n    ]\n    \n    # Compile the patterns\n    for rule in rules:\n        try:\n            if 'patterns' in rule:\n                rule['compiled_patterns'] = [Chem.MolFromSmarts(pat) for pat in rule['patterns']]\n            else:\n                rule['compiled_pattern'] = Chem.MolFromSmarts(rule['pattern'])\n            if 'exclude_patterns' in rule:\n                rule['compiled_exclude_patterns'] = [Chem.MolFromSmarts(p) for p in rule['exclude_patterns']]\n        except Exception as e:\n            rule['compiled_pattern'] = None\n            rule['compiled_patterns'] = []\n            rule['compiled_exclude_patterns'] = []\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = False\n                # Handle exclude patterns\n                if 'compiled_exclude_patterns' in rule:\n                    exclude = False\n                    for excl_pat in rule['compiled_exclude_patterns']:\n                        if mol.HasSubstructMatch(excl_pat):\n                            exclude = True\n                            break\n                    if exclude:\n                        row.append(0)\n                        continue\n                # Handle multiple patterns (list of patterns)\n                if 'compiled_patterns' in rule:\n                    for pat in rule['compiled_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = True\n                            break\n                else:\n                    # Handle single pattern\n                    if mol.HasSubstructMatch(rule['compiled_pattern']):\n                        match = True\n                # Handle min_count for certain patterns (e.g., Rule 3)\n                if match and 'min_count' in rule:\n                    count = len(mol.GetSubstructMatches(Chem.MolFromSmarts(rule['pattern'])))\n                    if count >= rule['min_count']:\n                        # Also check for additional_pattern if provided\n                        if 'additional_pattern' in rule:\n                            additional_match = mol.HasSubstructMatch(Chem.MolFromSmarts(rule['additional_pattern']))\n                            if additional_match:\n                                row.append(rule['prediction'])\n                            else:\n                                row.append(0)\n                        else:\n                            row.append(rule['prediction'])\n                    else:\n                        row.append(0)\n                elif match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f\"Rule {rule['number']}\" for rule in rules])\n    return df"
}