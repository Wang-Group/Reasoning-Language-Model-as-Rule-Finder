{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for the rules\n    \n    # Rule 1: Modifiers that are alpha-amino acids with a side chain carboxylate group (dicarboxylic amino acids) result in a high yield.\n    # Patterns:\n    # - Alpha-amino acid backbone: N-C-C(=O)-O\n    # - Additional carboxylate group in the side chain\n    amino_acid_backbone_smarts = '[NX3H2][CX4][CX3](=O)[OX1-,OX2H]'\n    carboxylate_group_smarts = '[CX3](=O)[OX1-,OX2H]'\n    \n    # Rule 2: Modifiers that are alpha-amino acids with heteroaromatic side chains result in a high yield.\n    # Patterns:\n    # - Alpha-amino acid backbone\n    # - Heteroaromatic ring in the side chain\n    heteroaromatic_ring_smarts = '[a;!#6]'\n    \n    # Rule 2 (Low Yield): Modifiers that are alpha-amino acids with non-heteroaromatic side chains result in a low yield.\n    # Patterns:\n    # - Alpha-amino acid backbone\n    # - Aromatic ring in the side chain\n    # - Exclude heteroaromatic rings\n    aromatic_ring_smarts = '[a]'\n    \n    # Rule 3: Linear aliphatic carboxylic acids with amino, sulfhydryl, or hydroxyl groups within three carbons of the carboxylate result in a high yield.\n    # Patterns:\n    # - Linear aliphatic carboxylic acid\n    # - Amino, sulfhydryl, or hydroxyl group within three carbons of the carboxylate\n    near_functional_group_smarts = ['[NX3H2][CX4][CX4][CX3](=O)[OX1-,OX2H]',  # Amino within 3 carbons\n                                    '[OX2H][CX4][CX4][CX3](=O)[OX1-,OX2H]',  # Hydroxyl within 3 carbons\n                                    '[SX2H][CX4][CX4][CX3](=O)[OX1-,OX2H]']  # Sulfhydryl within 3 carbons\n    \n    # Rule 3 (Low Yield): Functional groups more than five carbons away from carboxylate result in a low yield.\n    far_functional_group_smarts = ['[NX3H2][CX4][CX4][CX4][CX4][CX3](=O)[OX1-,OX2H]',\n                                   '[OX2H][CX4][CX4][CX4][CX4][CX3](=O)[OX1-,OX2H]',\n                                   '[SX2H][CX4][CX4][CX4][CX4][CX3](=O)[OX1-,OX2H]']\n    \n    # Rule 4: Aromatic carboxylic acids with para-substituted amino or nitro groups result in a high yield.\n    # Patterns:\n    # - Aromatic carboxylic acid\n    # - Para-substituted amino or nitro group\n    aromatic_carboxylic_acid_smarts = 'c1ccccc1C(=O)[OX1-,OX2H]'\n    para_amino_smarts = 'c1cc([NX3H2])ccc1C(=O)[OX1-,OX2H]'\n    para_nitro_smarts = 'c1cc([NX3](=O)=O)ccc1C(=O)[OX1-,OX2H]'\n    \n    # Rule 4 (Low Yield): Aromatic carboxylic acids with non-coordinating substituents or electron-donating groups result in a low yield.\n    para_methyl_smarts = 'c1cc(C)ccc1C(=O)[OX1-,OX2H]'\n    para_formyl_smarts = 'c1cc(C=O)ccc1C(=O)[OX1-,OX2H]'\n    \n    # Compile SMARTS patterns\n    compiled_patterns = {\n        'Rule 1': {\n            'patterns': [Chem.MolFromSmarts(amino_acid_backbone_smarts)],\n            'additional': {\n                'pattern': Chem.MolFromSmarts(carboxylate_group_smarts),\n                'min_count': 2\n            },\n            'prediction': 1\n        },\n        'Rule 2 High': {\n            'patterns': [Chem.MolFromSmarts(amino_acid_backbone_smarts), Chem.MolFromSmarts(heteroaromatic_ring_smarts)],\n            'prediction': 1\n        },\n        'Rule 2 Low': {\n            'patterns': [Chem.MolFromSmarts(amino_acid_backbone_smarts), Chem.MolFromSmarts(aromatic_ring_smarts)],\n            'exclude': [Chem.MolFromSmarts(heteroaromatic_ring_smarts)],\n            'prediction': -1\n        },\n        'Rule 3 High': {\n            'patterns': [Chem.MolFromSmarts(p) for p in near_functional_group_smarts],\n            'prediction': 1\n        },\n        'Rule 3 Low': {\n            'patterns': [Chem.MolFromSmarts(p) for p in far_functional_group_smarts],\n            'prediction': -1\n        },\n        'Rule 4 High': {\n            'patterns': [Chem.MolFromSmarts(para_amino_smarts), Chem.MolFromSmarts(para_nitro_smarts)],\n            'prediction': 1\n        },\n        'Rule 4 Low': {\n            'patterns': [Chem.MolFromSmarts(para_methyl_smarts), Chem.MolFromSmarts(para_formyl_smarts)],\n            'prediction': -1\n        }\n    }\n    \n    # Initialize results list\n    results = []\n    rule_names = list(compiled_patterns.keys())\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(compiled_patterns))\n            continue\n        row = []\n        for rule_name in rule_names:\n            try:\n                rule = compiled_patterns[rule_name]\n                match = False\n                # Check patterns\n                if 'patterns' in rule:\n                    for pat in rule['patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = True\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check additional patterns\n                if 'additional' in rule:\n                    additional_pat = rule['additional']['pattern']\n                    matches = mol.GetSubstructMatches(additional_pat)\n                    if len(matches) < rule['additional'].get('min_count', 1):\n                        match = False\n                    else:\n                        match = True\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check exclude patterns\n                if 'exclude' in rule:\n                    for pat in rule['exclude']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=rule_names)\n    return df\n"
}