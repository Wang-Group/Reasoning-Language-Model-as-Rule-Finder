{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit. It applies a set of structural rules to determine whether each molecule matches certain criteria, assigning values of 1 for rules that predict a high yield, -1 for rules that predict a low yield, and 0 if the rule does not apply. The feature matrix is returned as a pandas DataFrame, where each column corresponds to one rule and each row corresponds to one SMILES string from the list.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    carboxylic_acid_pat = Chem.MolFromSmarts('[CX3](=O)[OX2H1]')\n    amino_group_pat = Chem.MolFromSmarts('[NX3;H2,H1;!$(N=*)]')  # Excludes imines and other sp2 nitrogens\n    hydroxyl_group_pat = Chem.MolFromSmarts('[OX2H]')\n    thiol_group_pat = Chem.MolFromSmarts('[SX2H]')\n    aliphatic_C_pat = Chem.MolFromSmarts('[C;!R]')  # Aliphatic carbon\n    aromatic_C_pat = Chem.MolFromSmarts('[c]')\n    nitro_group_pat = Chem.MolFromSmarts('[NX3](=O)=O')\n    bromo_pat = Chem.MolFromSmarts('[Br]')\n    methyl_group_pat = Chem.MolFromSmarts('[CX4H3]')\n    indole_pat = Chem.MolFromSmarts('c1c[cH]c2[cH]c[cH][nH]c12')\n    methoxy_group_pat = Chem.MolFromSmarts('[OX2][CH3]')\n    formyl_group_pat = Chem.MolFromSmarts('[CX3H1](=O)')\n    fluorinated_alkyl_pat = Chem.MolFromSmarts('[CX4][F]')\n    ether_linkage_pat = Chem.MolFromSmarts('[#6][OX2][#6]')\n    amino_acid_pat = Chem.MolFromSmarts('[NX3;H2,H1][CX4][CX3](=O)[OX2H1]')\n    aromatic_ring_pat = Chem.MolFromSmarts('a1aaaaa1')\n    heterocycle_N_pat = Chem.MolFromSmarts('[$([nH1]),$([nH0])]1aaaa1')\n    # Define the rules with their associated patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'High Yield: Aliphatic carboxylic acids with amino (-NH2), hydroxyl (-OH), or thiol (-SH) groups within three carbons of the carboxyl group.',\n            'function': 'apply_rule_1',\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'High Yield: Aromatic carboxylic acids with electron-withdrawing groups (nitro, bromo, amino) in the para position.',\n            'function': 'apply_rule_2',\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Low Yield: Aromatic carboxylic acids with electron-donating groups (methyl) in the para position.',\n            'function': 'apply_rule_3',\n            'prediction': -1\n        },\n        {\n            'number': 4,\n            'description': 'High Yield: Heterocyclic carboxylic acids containing nitrogen atoms within the ring.',\n            'function': 'apply_rule_4',\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'High Yield: Aliphatic carboxylic acids with multiple adjacent hydroxyl (-OH) groups.',\n            'function': 'apply_rule_5',\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Low Yield: Aliphatic carboxylic acids with amino (-NH2) or hydroxyl (-OH) groups located more than three carbons away from the carboxyl group.',\n            'function': 'apply_rule_6',\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Low Yield: Modifiers containing fluorinated alkyl chains near the carboxyl group.',\n            'function': 'apply_rule_7',\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Low Yield: Aromatic carboxylic acids with ortho-substituted hydroxyl (-OH) or formyl (-CHO) groups.',\n            'function': 'apply_rule_8',\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'High Yield: Amino acids with indole side chains (tryptophan).',\n            'function': 'apply_rule_9',\n            'prediction': 1\n        },\n        {\n            'number': 10,\n            'description': 'High Yield: Aliphatic carboxylic acids without additional functional groups.',\n            'function': 'apply_rule_10',\n            'prediction': 1\n        },\n        {\n            'number': 11,\n            'description': 'Low Yield: Modifiers with polyether chains or flexible linkers bearing amino (-NH2) or methoxy (-OCH3) groups distant from the carboxyl group.',\n            'function': 'apply_rule_11',\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Low Yield: Modifiers with bulky substituents adjacent to the carboxyl group (e.g., aromatic rings).',\n            'function': 'apply_rule_12',\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Low Yield: Aromatic carboxylic acids containing formyl (-CHO) groups.',\n            'function': 'apply_rule_13',\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'High Yield: Aliphatic carboxylic acids containing sulfur groups (-SH) within three carbons of the carboxyl group.',\n            'function': 'apply_rule_14',\n            'prediction': 1\n        },\n        {\n            'number': 15,\n            'description': 'High Yield: Aromatic carboxylic acids with methoxy (-OCH3) groups in the meta or para position.',\n            'function': 'apply_rule_15',\n            'prediction': 1\n        }\n    ]\n    # Initialize results list\n    results = []\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        # Apply each rule function\n        for rule in rules:\n            func_name = rule['function']\n            prediction = rule['prediction']\n            try:\n                match = globals()[func_name](mol)\n                if match:\n                    row.append(prediction)\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n\n    # Function definitions for rules\n    def apply_rule_1(mol):\n        # Rule 1 implementation\n        try:\n            # Find carboxylic acid carbons\n            carboxyl_carbons = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid_pat)]\n            # Find amino/hydroxyl/thiol groups\n            amino_atoms = [match[0] for match in mol.GetSubstructMatches(amino_group_pat)]\n            hydroxyl_atoms = [match[0] for match in mol.GetSubstructMatches(hydroxyl_group_pat)]\n            thiol_atoms = [match[0] for match in mol.GetSubstructMatches(thiol_group_pat)]\n            functional_atoms = amino_atoms + hydroxyl_atoms + thiol_atoms\n            # For each carboxyl carbon, check if any functional group is within 3 bonds\n            for c_idx in carboxyl_carbons:\n                for f_idx in functional_atoms:\n                    path = Chem.GetShortestPath(mol, c_idx, f_idx)\n                    if len(path) - 1 <= 3:\n                        return True\n            return False\n        except:\n            return False\n\n    def apply_rule_2(mol):\n        # Rule 2 implementation\n        try:\n            # Find aromatic carboxylic acids\n            aromatic_carboxylic_acid_pat = Chem.MolFromSmarts('[c][CX3](=O)[OX2H1]')\n            matches = mol.GetSubstructMatches(aromatic_carboxylic_acid_pat)\n            if not matches:\n                return False\n            # For each match, check for EWG in para position\n            for match in matches:\n                aromatic_c_idx = match[0]  # Aromatic carbon attached to carboxyl group\n                # Get the ring that contains the aromatic carbon\n                ring_info = mol.GetRingInfo()\n                rings = ring_info.AtomRings()\n                for ring in rings:\n                    if aromatic_c_idx in ring and len(ring) == 6:\n                        # Find the index of the aromatic carbon in the ring\n                        idx_in_ring = ring.index(aromatic_c_idx)\n                        # Para position is three atoms away in the ring (opposite side)\n                        para_idx = ring[(idx_in_ring + 3) % 6]\n                        para_atom = mol.GetAtomWithIdx(para_idx)\n                        # Check for substituents at para position\n                        for neighbor in para_atom.GetNeighbors():\n                            if neighbor.GetIdx() != para_idx and neighbor.GetIdx() not in ring:\n                                sub_mol = Chem.PathToSubmol(mol, [neighbor.GetIdx()])\n                                if sub_mol.HasSubstructMatch(nitro_group_pat) or sub_mol.HasSubstructMatch(bromo_pat) or sub_mol.HasSubstructMatch(amino_group_pat):\n                                    return True\n            return False\n        except:\n            return False\n\n    def apply_rule_3(mol):\n        # Rule 3 implementation\n        try:\n            # Find aromatic carboxylic acids\n            aromatic_carboxylic_acid_pat = Chem.MolFromSmarts('[c][CX3](=O)[OX2H1]')\n            matches = mol.GetSubstructMatches(aromatic_carboxylic_acid_pat)\n            if not matches:\n                return False\n            # For each match, check for methyl group in para position\n            for match in matches:\n                aromatic_c_idx = match[0]\n                ring_info = mol.GetRingInfo()\n                rings = ring_info.AtomRings()\n                for ring in rings:\n                    if aromatic_c_idx in ring and len(ring) == 6:\n                        idx_in_ring = ring.index(aromatic_c_idx)\n                        para_idx = ring[(idx_in_ring + 3) % 6]\n                        para_atom = mol.GetAtomWithIdx(para_idx)\n                        for neighbor in para_atom.GetNeighbors():\n                            if neighbor.GetIdx() != para_idx and neighbor.GetIdx() not in ring:\n                                sub_mol = Chem.PathToSubmol(mol, [neighbor.GetIdx()])\n                                if sub_mol.HasSubstructMatch(methyl_group_pat):\n                                    return True\n            return False\n        except:\n            return False\n\n    def apply_rule_4(mol):\n        # Rule 4 implementation\n        try:\n            matches = mol.GetSubstructMatches(heterocycle_N_pat)\n            for match in matches:\n                atom = mol.GetAtomWithIdx(match[0])\n                # Check if the heterocycle has a carboxylic acid group\n                for neighbor in atom.GetNeighbors():\n                    if neighbor.HasSubstructMatch(carboxylic_acid_pat):\n                        return True\n            return False\n        except:\n            return False\n\n    def apply_rule_5(mol):\n        # Rule 5 implementation\n        try:\n            hydroxyl_matches = mol.GetSubstructMatches(hydroxyl_group_pat)\n            hydroxyl_atoms = [match[0] for match in hydroxyl_matches]\n            # Check for adjacent hydroxyl groups\n            for i in range(len(hydroxyl_atoms)):\n                atom_i = mol.GetAtomWithIdx(hydroxyl_atoms[i])\n                for j in range(i+1, len(hydroxyl_atoms)):\n                    atom_j = mol.GetAtomWithIdx(hydroxyl_atoms[j])\n                    path = Chem.GetShortestPath(mol, atom_i.GetIdx(), atom_j.GetIdx())\n                    if len(path) == 2:  # Adjacent hydroxyl groups\n                        # Check for carboxylic acid in the molecule\n                        if mol.HasSubstructMatch(carboxylic_acid_pat):\n                            return True\n            return False\n        except:\n            return False\n\n    def apply_rule_6(mol):\n        # Rule 6 implementation\n        try:\n            # Similar to Rule 1 but for groups more than 3 bonds away\n            carboxyl_carbons = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid_pat)]\n            amino_atoms = [match[0] for match in mol.GetSubstructMatches(amino_group_pat)]\n            hydroxyl_atoms = [match[0] for match in mol.GetSubstructMatches(hydroxyl_group_pat)]\n            functional_atoms = amino_atoms + hydroxyl_atoms\n            found_far = False\n            found_close = False\n            for c_idx in carboxyl_carbons:\n                for f_idx in functional_atoms:\n                    path = Chem.GetShortestPath(mol, c_idx, f_idx)\n                    if len(path) - 1 > 3:\n                        found_far = True\n                    elif len(path) - 1 <= 3:\n                        found_close = True\n            if found_far and not found_close:\n                return True\n            return False\n        except:\n            return False\n\n    def apply_rule_7(mol):\n        # Rule 7 implementation\n        try:\n            # Check for fluorinated alkyl chains near carboxyl group\n            carboxyl_carbons = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid_pat)]\n            fluorinated_carbons = [match[0] for match in mol.GetSubstructMatches(fluorinated_alkyl_pat)]\n            for c_idx in carboxyl_carbons:\n                for f_idx in fluorinated_carbons:\n                    path = Chem.GetShortestPath(mol, c_idx, f_idx)\n                    if len(path) - 1 <= 3:\n                        return True\n            return False\n        except:\n            return False\n\n    def apply_rule_8(mol):\n        # Rule 8 implementation\n        try:\n            # Find aromatic carboxylic acids\n            aromatic_carboxylic_acid_pat = Chem.MolFromSmarts('[c][CX3](=O)[OX2H1]')\n            matches = mol.GetSubstructMatches(aromatic_carboxylic_acid_pat)\n            if not matches:\n                return False\n            # Check for ortho-substituted hydroxyl or formyl groups\n            for match in matches:\n                aromatic_c_idx = match[0]\n                ring_info = mol.GetRingInfo()\n                rings = ring_info.AtomRings()\n                for ring in rings:\n                    if aromatic_c_idx in ring and len(ring) == 6:\n                        idx_in_ring = ring.index(aromatic_c_idx)\n                        ortho_indices = [ring[(idx_in_ring + 1) % 6], ring[(idx_in_ring - 1) % 6]]\n                        for ortho_idx in ortho_indices:\n                            ortho_atom = mol.GetAtomWithIdx(ortho_idx)\n                            for neighbor in ortho_atom.GetNeighbors():\n                                if neighbor.GetIdx() not in ring:\n                                    sub_mol = Chem.PathToSubmol(mol, [neighbor.GetIdx()])\n                                    if sub_mol.HasSubstructMatch(hydroxyl_group_pat) or sub_mol.HasSubstructMatch(formyl_group_pat):\n                                        return True\n            return False\n        except:\n            return False\n\n    def apply_rule_9(mol):\n        # Rule 9 implementation\n        try:\n            # Check for amino acid with indole side chain\n            if mol.HasSubstructMatch(indole_pat) and mol.HasSubstructMatch(amino_acid_pat):\n                return True\n            return False\n        except:\n            return False\n\n    def apply_rule_10(mol):\n        # Rule 10 implementation\n        try:\n            # Aliphatic carboxylic acids without additional functional groups\n            if mol.HasSubstructMatch(carboxylic_acid_pat):\n                # Exclude molecules with other functional groups\n                if not (mol.HasSubstructMatch(amino_group_pat) or mol.HasSubstructMatch(hydroxyl_group_pat) or mol.HasSubstructMatch(thiol_group_pat) or mol.HasSubstructMatch(aromatic_C_pat)):\n                    return True\n            return False\n        except:\n            return False\n\n    def apply_rule_11(mol):\n        # Rule 11 implementation\n        try:\n            # Check for polyether chains or flexible linkers with amino or methoxy groups distant from carboxyl\n            if mol.HasSubstructMatch(ether_linkage_pat) and (mol.HasSubstructMatch(amino_group_pat) or mol.HasSubstructMatch(methoxy_group_pat)):\n                # Check the distance from carboxyl group\n                carboxyl_carbons = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid_pat)]\n                functional_atoms = [match[0] for match in mol.GetSubstructMatches(amino_group_pat)] + [match[0] for match in mol.GetSubstructMatches(methoxy_group_pat)]\n                for c_idx in carboxyl_carbons:\n                    for f_idx in functional_atoms:\n                        path = Chem.GetShortestPath(mol, c_idx, f_idx)\n                        if len(path) - 1 > 3:\n                            return True\n            return False\n        except:\n            return False\n\n    def apply_rule_12(mol):\n        # Rule 12 implementation\n        try:\n            # Check for bulky substituents adjacent to carboxyl group\n            carboxyl_carbons = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid_pat)]\n            for c_idx in carboxyl_carbons:\n                carboxyl_carbon = mol.GetAtomWithIdx(c_idx)\n                for neighbor in carboxyl_carbon.GetNeighbors():\n                    if neighbor.GetAtomicNum() == 6 and neighbor.IsInRing():\n                        return True\n            return False\n        except:\n            return False\n\n    def apply_rule_13(mol):\n        # Rule 13 implementation\n        try:\n            # Aromatic carboxylic acids with formyl groups\n            aromatic_carboxylic_acid_pat = Chem.MolFromSmarts('[c][CX3](=O)[OX2H1]')\n            formyl_group_pat = Chem.MolFromSmarts('[CX3H1](=O)[#6]')\n            if mol.HasSubstructMatch(aromatic_carboxylic_acid_pat) and mol.HasSubstructMatch(formyl_group_pat):\n                return True\n            return False\n        except:\n            return False\n\n    def apply_rule_14(mol):\n        # Rule 14 implementation\n        try:\n            # Similar to Rule 1 but for sulfur groups\n            carboxyl_carbons = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid_pat)]\n            thiol_atoms = [match[0] for match in mol.GetSubstructMatches(thiol_group_pat)]\n            for c_idx in carboxyl_carbons:\n                for f_idx in thiol_atoms:\n                    path = Chem.GetShortestPath(mol, c_idx, f_idx)\n                    if len(path) - 1 <= 3:\n                        return True\n            return False\n        except:\n            return False\n\n    def apply_rule_15(mol):\n        # Rule 15 implementation\n        try:\n            # Check for methoxy groups in meta or para position\n            aromatic_carboxylic_acid_pat = Chem.MolFromSmarts('[c][CX3](=O)[OX2H1]')\n            matches = mol.GetSubstructMatches(aromatic_carboxylic_acid_pat)\n            if not matches:\n                return False\n            for match in matches:\n                aromatic_c_idx = match[0]\n                ring_info = mol.GetRingInfo()\n                rings = ring_info.AtomRings()\n                for ring in rings:\n                    if aromatic_c_idx in ring and len(ring) == 6:\n                        idx_in_ring = ring.index(aromatic_c_idx)\n                        # Meta positions\n                        meta_indices = [ring[(idx_in_ring + 2) % 6], ring[(idx_in_ring - 2) % 6]]\n                        # Para position\n                        para_idx = ring[(idx_in_ring + 3) % 6]\n                        positions = meta_indices + [para_idx]\n                        for pos_idx in positions:\n                            pos_atom = mol.GetAtomWithIdx(pos_idx)\n                            for neighbor in pos_atom.GetNeighbors():\n                                if neighbor.GetIdx() not in ring:\n                                    sub_mol = Chem.PathToSubmol(mol, [neighbor.GetIdx()])\n                                    if sub_mol.HasSubstructMatch(methoxy_group_pat):\n                                        return True\n            return False\n        except:\n            return False"
}