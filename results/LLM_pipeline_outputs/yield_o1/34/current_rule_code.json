{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit according to specified natural language rules. Each rule corresponds to specific structural features identified by SMARTS patterns. The output is a DataFrame where each column represents a rule, and each row corresponds to a SMILES string from the input list. A value of 1 indicates that the SMILES matches the rule and predicts a high target value, -1 indicates a low target value, and 0 indicates no match.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define the rules with their associated patterns and predictions\n    rules = [\n        # Rule 1: High Yield\n        {\n            'number': 1,\n            'description': 'High yield: Amino acids with side chains containing additional acidic groups (carboxyl or hydroxyl).',\n            'patterns': [\n                [  # Amino acid backbone\n                    '[NX3][CX4H]([#6])[CX3](=O)[OX1H]',\n                ],\n                [  # Side chain containing additional acidic groups\n                    '[CX3](=O)[OX1H]',  # Carboxylic acid group\n                    '[OX2H]',            # Hydroxyl group\n                ],\n            ],\n            'prediction': 1\n        },\n        # Rule 1: Low Yield\n        {\n            'number': 2,\n            'description': 'Low yield: Amino acids with non-polar or bulky side chains.',\n            'patterns': [\n                [  # Amino acid backbone\n                    '[NX3][CX4H]([#6])[CX3](=O)[OX1H]',\n                ],\n            ],\n            'exclude_patterns': [\n                [  # Side chain containing additional acidic groups\n                    '[CX3](=O)[OX1H]',  # Carboxylic acid group\n                    '[OX2H]',            # Hydroxyl group\n                ],\n            ],\n            'prediction': -1\n        },\n        # Rule 2: High Yield\n        {\n            'number': 3,\n            'description': 'High yield: Aromatic carboxylic acids with electron-withdrawing substituents (e.g., nitro, halogens) in the para position.',\n            'patterns': [\n                [  # Aromatic carboxylic acid\n                    'c1ccccc1C(=O)O',  # Benzoic acid ring\n                ],\n                [  # EWG in para position\n                    'c1ccc(cc1)[N+](=O)[O-]',  # Nitro group\n                    'c1ccc(cc1)[F,Cl,Br,I]',   # Halogens\n                ],\n            ],\n            'prediction': 1\n        },\n        # Rule 2: Low Yield\n        {\n            'number': 4,\n            'description': 'Low yield: Aromatic carboxylic acids with electron-donating substituents (e.g., methyl, methoxy) in the para position.',\n            'patterns': [\n                [  # Aromatic carboxylic acid\n                    'c1ccccc1C(=O)O',\n                ],\n                [  # EDG in para position\n                    'c1ccc(cc1)[OX2H,OX2][#6]',  # Hydroxyl or methoxy group\n                    'c1ccc(cc1)C',                # Methyl group\n                ],\n            ],\n            'prediction': -1\n        },\n        # Rule 3: High Yield\n        {\n            'number': 5,\n            'description': 'High yield: Nitrogen-containing heterocycles attached directly or via short linkers to carboxyl group.',\n            'patterns': [\n                [  # Nitrogen-containing heterocycle\n                    'n1ccccc1',  # Pyridine\n                    'c1cn[nH]c1',  # Pyrazole\n                ],\n                [\n                    '[CX3](=O)[OX1H]',  # Carboxylic acid\n                ],\n            ],\n            'prediction': 1\n        },\n        # Rule 3: Low Yield\n        {\n            'number': 6,\n            'description': 'Low yield: Nitrogen-containing heterocycles with bulky aromatic linkers to carboxyl group.',\n            'patterns': [\n                [\n                    'n1ccccc1c2ccccc2',  # Pyridine attached via benzene\n                ],\n                [\n                    '[CX3](=O)[OX1H]',  # Carboxylic acid\n                ],\n            ],\n            'prediction': -1\n        },\n        # Rule 4: High Yield\n        {\n            'number': 7,\n            'description': 'High yield: Aliphatic carboxylic acids with multiple hydroxyl groups near carboxylate.',\n            'patterns': [\n                [\n                    'C(=O)[OX1H]',        # Carboxylic acid\n                ],\n                [\n                    '[CX4][OX2H]',        # Hydroxyl group on adjacent carbon\n                ],\n            ],\n            'prediction': 1\n        },\n        # Rule 4: Low Yield\n        {\n            'number': 8,\n            'description': 'Low yield: Aliphatic carboxylic acids with insufficient hydroxyl groups or distant hydroxyl groups.',\n            'patterns': [\n                [\n                    'C(=O)[OX1H]',        # Carboxylic acid\n                ],\n            ],\n            'exclude_patterns': [\n                [\n                    '[CX4][OX2H]',        # Exclude if hydroxyl group is present near carboxylate\n                ],\n            ],\n            'prediction': -1\n        },\n        # Rule 5: High Yield\n        {\n            'number': 9,\n            'description': 'High yield: Aliphatic carboxylic acids with accessible thiol groups.',\n            'patterns': [\n                [\n                    'C(=O)[OX1H]',        # Carboxylic acid\n                ],\n                [\n                    '[CX4][SX2H]',        # Thiol group adjacent\n                ],\n            ],\n            'prediction': 1\n        },\n        # Rule 5: Low Yield\n        {\n            'number': 10,\n            'description': 'Low yield: Thiol groups in aromatic systems.',\n            'patterns': [\n                [\n                    'c1ccccc1[SX2H]',     # Thiol on aromatic ring\n                ],\n                [\n                    '[CX3](=O)[OX1H]',    # Carboxylic acid\n                ],\n            ],\n            'prediction': -1\n        },\n        # Additional rules can be added similarly...\n    ]\n\n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns_groups = []\n        for group in rule.get('patterns', []):\n            compiled_group = [Chem.MolFromSmarts(pat) for pat in group]\n            compiled_patterns_groups.append(compiled_group)\n        rule['compiled_patterns'] = compiled_patterns_groups\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_exclude_groups = []\n            for group in rule['exclude_patterns']:\n                compiled_group = [Chem.MolFromSmarts(pat) for pat in group]\n                compiled_exclude_groups.append(compiled_group)\n            rule['compiled_exclude_patterns'] = compiled_exclude_groups\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'compiled_exclude_patterns' in rule:\n                    for group in rule['compiled_exclude_patterns']:\n                        for pat in group:\n                            if mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                        if not match:\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for group in rule['compiled_patterns']:\n                    group_match = any(mol.HasSubstructMatch(pat) for pat in group)\n                    if not group_match:\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df\n"
}