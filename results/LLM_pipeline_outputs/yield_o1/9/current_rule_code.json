{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit, following the provided natural language rules. Each rule corresponds to specific structural features, represented using SMARTS patterns. The code checks for these patterns in each molecule and assigns a value according to the rules:\n\n- A value of 0 if the structural description of the rule does not match the SMILES.\n- A value of 1 if the structural description of the rule matches the SMILES and predicts a high target value.\n- A value of -1 if the structural description of the rule matches the SMILES and predicts a low target value.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and structures according to the rules\n\n    # Patterns for common functional groups\n    carboxylic_acid = '[CX3](=O)[OX2H1]'  # Carboxylic acid group (-COOH)\n    amino_group = '[NX3;H2,H1;!$([N][C,S]);!$([N]=[C,S,N,O])]'  # Primary or secondary amine\n    alpha_amino_acid = '[NX3;H2][CX4H]([#6])[CX3](=O)[OX2H1]'  # Alpha amino acid backbone\n    carboxylic_acid_any = '[CX3](=O)[OX1H0-,OX2H1]'  # Carboxylic acid group (includes deprotonated)\n    hydroxyl_group = '[OX2H]'  # Hydroxyl group (-OH)\n    thiol_group = '[SX2H]'  # Thiol group (-SH)\n    ether_linkage = '[#6][OX2][#6]'  # Ether linkage (-O-)\n    aldehyde_group = '[CX3H1](=O)[#6]'  # Aldehyde group (-CHO)\n    nitro_group = '[NX3](=O)=O'  # Nitro group (-NO2)\n    halogen = '[F,Cl,Br,I]'  # Halogen atoms\n    aromatic_ring = '[c]'  # Aromatic carbon\n    aliphatic_chain_6_8 = '[C;X4][C;X4][C;X4][C;X4][C;X4][C;X4]'  # Aliphatic chain of 6 carbons\n    perfluoroalkyl = '[CX4]([F,Cl,Br,I])[F,Cl,Br,I][F,Cl,Br,I]'  # Trifluoromethyl or similar\n\n    # Initialize the list of rules\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are \u03b1-amino dicarboxylic acids yield high yields.',\n            'patterns': [\n                alpha_amino_acid,  # Alpha amino acid backbone\n            ],\n            'counts': [1, 2],  # At least 1 alpha amino acid pattern, at least 2 carboxylic acids\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Para-substituted benzoic acids with electron-withdrawing para-substituents (amino, nitro, halomethyl) yield high yields; with methyl, formyl, thiol substituents yield low yields.',\n            'patterns': [\n                'c1ccc([CX3](=O)[OX1H0-,OX2H1])cc1*',  # Benzoic acid\n            ],\n            'high_yield_substituents': [\n                '[NX3;H2]',  # Amino group\n                '[NX3+](=O)[O-]',  # Nitro group\n                '[CH2][F,Cl,Br,I]'  # Halomethyl group\n            ],\n            'low_yield_substituents': [\n                '[CH3]',  # Methyl group\n                aldehyde_group,  # Formyl group\n                thiol_group  # Thiol group\n            ],\n            'prediction': None  # Prediction will be set based on substituent\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers with multiple adjacent hydroxyl groups (polyols) on aliphatic chains yield high yields; single or distant hydroxyl groups yield low yields.',\n            'patterns': [\n                hydroxyl_group,\n            ],\n            'adjacent_hydroxyls': True,\n            'prediction': None  # Prediction will be set based on adjacency\n        },\n        {\n            'number': 4,\n            'description': 'Unsubstituted aliphatic carboxylic acids with chain lengths of 6 to 8 carbons yield high yields; introduction of polar functional groups lowers the yield.',\n            'patterns': [\n                carboxylic_acid_any,\n                '[CCCCCC,CCCCCCC,CCCCCCCC]'  # Chains of 6-8 carbons\n            ],\n            'exclude_patterns': [\n                amino_group,\n                hydroxyl_group,\n                thiol_group\n            ],\n            'prediction': 1\n        },\n        # Additional rules can be added here following the same structure\n    ]\n\n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = [Chem.MolFromSmarts(pat) for pat in rule.get('patterns', [])]\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile high/low yield substituents if present\n        if 'high_yield_substituents' in rule:\n            rule['compiled_high_yield_substituents'] = [Chem.MolFromSmarts(pat) for pat in rule['high_yield_substituents']]\n        if 'low_yield_substituents' in rule:\n            rule['compiled_low_yield_substituents'] = [Chem.MolFromSmarts(pat) for pat in rule['low_yield_substituents']]\n        # Compile exclude patterns if present\n        if 'exclude_patterns' in rule:\n            rule['compiled_exclude_patterns'] = [Chem.MolFromSmarts(pat) for pat in rule['exclude_patterns']]\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for pat in rule['compiled_exclude_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for idx, pat in enumerate(rule['compiled_patterns']):\n                    matches = mol.GetSubstructMatches(pat)\n                    if not matches:\n                        match = False\n                        break\n                    if 'counts' in rule:\n                        required_count = rule['counts'][idx]\n                        if len(matches) < required_count:\n                            match = False\n                            break\n                if not match:\n                    row.append(0)\n                    continue\n                # Additional checks for specific rules\n                if rule['number'] == 2:\n                    # Para-substituted benzoic acid\n                    match_high = False\n                    match_low = False\n                    for sub_pat in rule['compiled_high_yield_substituents']:\n                        if mol.HasSubstructMatch(sub_pat):\n                            match_high = True\n                            break\n                    for sub_pat in rule['compiled_low_yield_substituents']:\n                        if mol.HasSubstructMatch(sub_pat):\n                            match_low = True\n                            break\n                    if match_high:\n                        row.append(1)\n                    elif match_low:\n                        row.append(-1)\n                    else:\n                        row.append(0)\n                    continue\n                elif rule['number'] == 3:\n                    # Multiple adjacent hydroxyl groups\n                    hydroxyl_matches = mol.GetSubstructMatches(rule['compiled_patterns'][0])\n                    if len(hydroxyl_matches) >= 2:\n                        # Check if any hydroxyl groups are adjacent\n                        adjacent = False\n                        for i in range(len(hydroxyl_matches)):\n                            for j in range(i+1, len(hydroxyl_matches)):\n                                path = Chem.GetShortestPath(mol, hydroxyl_matches[i][0], hydroxyl_matches[j][0])\n                                if len(path) == 2:\n                                    adjacent = True\n                                    break\n                            if adjacent:\n                                break\n                        if adjacent:\n                            row.append(1)\n                        else:\n                            row.append(-1)\n                    else:\n                        row.append(-1)\n                    continue\n                # Default prediction\n                row.append(rule['prediction'])\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}