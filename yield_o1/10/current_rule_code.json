{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. Each column corresponds to one of the defined rules, and each row corresponds to a SMILES string. The value is 1 if the SMILES matches a rule predicting a high yield, -1 if it matches a rule predicting a low yield, and 0 otherwise.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for common functional groups\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    amino_group = '[NX3H2]'\n    n_acylated_amino = '[NX3][CX3](=O)'\n    aromatic_ring = 'a'\n    thiol_group = '[SX2H]'\n    ether_linkage = '[#6][OX2][#6]'\n    aldehyde_group = '[CX3H1](=O)'\n    fluorine_atom = '[F]'\n    # Compile SMARTS patterns\n    carboxylic_acid_pat = Chem.MolFromSmarts(carboxylic_acid)\n    amino_group_pat = Chem.MolFromSmarts(amino_group)\n    n_acylated_amino_pat = Chem.MolFromSmarts(n_acylated_amino)\n    aromatic_ring_pat = Chem.MolFromSmarts(aromatic_ring)\n    thiol_group_pat = Chem.MolFromSmarts(thiol_group)\n    ether_linkage_pat = Chem.MolFromSmarts(ether_linkage)\n    aldehyde_group_pat = Chem.MolFromSmarts(aldehyde_group)\n    fluorine_atom_pat = Chem.MolFromSmarts(fluorine_atom)\n    \n    # Define the rules with their associated patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'High yield: \u03b1-amino acids without bulky hydrophobic side chains or acyl modifications',\n            'patterns': [\n                carboxylic_acid_pat,\n                amino_group_pat\n            ],\n            'exclude_patterns': [\n                n_acylated_amino_pat,\n                Chem.MolFromSmarts('[CX4H]([NX3H2])([CX3](=O)[OX2H1])[a]')  # \u03b1-carbon attached to aromatic ring\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'High yield: Aromatic carboxylic acids with metal-coordinating groups at para position',\n            'patterns': [\n                Chem.MolFromSmarts('[c]1ccc([NX3H2,NX3+0](=O)[O-,OX1-,OX2])cc1[CX3](=O)[OX1H0-,OX2H1]'),  # Aromatic ring with para amino or nitro group and carboxylic acid\n                Chem.MolFromSmarts('[c]1ccc([OX2H])cc1[CX3](=O)[OX1H0-,OX2H1]')  # Aromatic ring with para hydroxyl group and carboxylic acid\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'High yield: Heterocyclic carboxylic acids with ring nitrogen directly attached to carboxyl group',\n            'patterns': [\n                Chem.MolFromSmarts('[n][c][c][c][c][CX3](=O)[OX1H0-,OX2H1]'),  # Heterocycle with nitrogen and carboxylic acid directly attached\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'High yield: Unsubstituted medium-chain aliphatic carboxylic acids (6 to 8 carbons) without additional polar groups',\n            'patterns': [\n                Chem.MolFromSmarts('[CH3][CH2]{4,6}[CX3](=O)[OX1H0-,OX2H1]')  # Aliphatic chain of 5-7 carbons ending with carboxylic acid\n            ],\n            'exclude_patterns': [\n                amino_group_pat,\n                thiol_group_pat,\n                ether_linkage_pat\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'High yield: Aliphatic carboxylic acids with thiol groups on the aliphatic chain',\n            'patterns': [\n                carboxylic_acid_pat,\n                thiol_group_pat\n            ],\n            'exclude_patterns': [\n                aromatic_ring_pat  # Exclude aromatic rings\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Low yield: Compounds with multiple ether linkages in aliphatic chains terminating with a carboxylic acid group',\n            'patterns': [\n                carboxylic_acid_pat,\n                Chem.MolFromSmarts('([#6][OX2]){2,}[#6]')  # At least two ether linkages in a chain\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Low yield: Amino acids or peptides with acylated amino groups or additional amide linkages',\n            'patterns': [\n                carboxylic_acid_pat,\n                Chem.MolFromSmarts('[NX3][CX3](=O)')  # Acylated amino group\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Low yield: Heavily fluorinated aliphatic carboxylic acids',\n            'patterns': [\n                carboxylic_acid_pat,\n                fluorine_atom_pat\n            ],\n            'count_threshold': {fluorine_atom: 3},  # At least 3 fluorine atoms\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Low yield: Aromatic carboxylic acids with formyl groups adjacent to the carboxyl group',\n            'patterns': [\n                Chem.MolFromSmarts('c1cc([CX3H](=O))ccc1[CX3](=O)[OX1H0-,OX2H1]')  # Aromatic ring with aldehyde and carboxylic acid adjacent\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'High yield: Aromatic carboxylic acids connected through aliphatic chains of four or more carbons to additional functional groups',\n            'patterns': [\n                Chem.MolFromSmarts('[c][C][CH2][CH2][CH2][CX3](=O)[OX1H0-,OX2H1]')  # Aromatic ring connected via 4-carbon chain to carboxylic acid\n            ],\n            'prediction': 1\n        }\n    ]\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for pat in rule['exclude_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for pat in rule['patterns']:\n                    matches = mol.GetSubstructMatches(pat)\n                    if not matches:\n                        match = False\n                        break\n                    # If a count threshold is specified for this pattern\n                    if 'count_threshold' in rule and pat in rule['count_threshold']:\n                        threshold = rule['count_threshold'][pat]\n                        if len(matches) < threshold:\n                            match = False\n                            break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}