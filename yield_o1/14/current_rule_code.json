{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit, applying 15 rules based on structural patterns to predict high or low yield. Each rule corresponds to a specific structural feature described by SMARTS patterns. The function `rule2matrix` processes each SMILES string, checks for matches with the defined rules, and returns a DataFrame where each column represents a rule and each row corresponds to a SMILES string from the input list.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and substructures\n    # Rule 1: \u03b1-amino acids (amino and carboxyl groups on the same carbon)\n    alpha_amino_acid = '[NX3H2][CX4H][CX3](=O)[OX2H1]'\n    \n    # Rule 2: Aromatic carboxylic acids with electron-withdrawing groups at para position\n    aromatic_carboxylic_acid = '[c][CX3](=O)[OX2H1]'\n    electron_withdrawing_group = '[c][F,Cl,Br,I,$(N(=O)=O),$(C(F)(F)F)]'\n    \n    # Rule 3: Heteroaromatic carboxylic acids containing pyridine nitrogen atoms\n    heteroaromatic_nitrogen = '[n]'\n    heteroaromatic_carboxylic_acid = '[n;a][a][a][a][a][CX3](=O)[OX2H1]'\n    \n    # Rule 4: Aliphatic carboxylic acids with long hydrocarbon chains (6 or more carbons)\n    long_chain_carboxylic_acid = '[CX3](=O)[OX2H1][C][C][C][C][C][C]'\n    \n    # Rule 5: Hydroxyl groups adjacent to the carboxyl group\n    adjacent_hydroxyl_carboxylic_acid = '[OX2H][CX4][CX3](=O)[OX2H1]'\n    \n    # Rule 6: Thiol groups within three carbons of the carboxyl group\n    thiol_near_carboxylic_acid = '[#16X2H][CX4][CX4][CX3](=O)[OX2H1]'\n    \n    # Rule 7: Perfluoroalkyl groups attached to the carboxyl group\n    perfluoroalkyl_carboxylic_acid = '[CX3](=O)[OX2H1][CX4](F)(F)F'\n    \n    # Rule 8: Aromatic carboxylic acids with aldehyde or ketone groups adjacent to the ring\n    aromatic_carboxylic_with_adjacent_carbonyl = '[c][CX3](=O)[OX2H1].[c][CX3]=O'\n    \n    # Rule 9: Amide bonds involving the carboxyl group or N-acetylated amino acids\n    amide_bond_carboxylic_acid = '[NX3][CX3](=O)[OX2H1]'\n    n_acetylated_amino_acid = '[NX3][CX3](=O)[CX4][NX3][CX3](=O)[OX2H1]'\n    \n    # Rule 10: Aliphatic carboxylic acids with ether linkages and terminal polar groups\n    ether_linkage_polar_terminal = '[CX3](=O)[OX2H1][CX4][OX2][CX4][OX2][CX4][OX2H1]'\n    \n    # Rule 11: Aromatic carboxylic acids with bulky substituents near coordinating sites\n    bulky_substituents_near_carboxyl = '[c][CX3](=O)[OX2H1][c][c][c][c]'\n    \n    # Rule 12: Long-chain aliphatic carboxylic acids with polar groups distant from carboxyl\n    long_chain_polar_distant = '[CX3](=O)[OX2H1][C][C][C][C][C][C][C][NX3H2,OX2H]'\n    \n    # Rule 13: Aromatic carboxylic acids with ortho-hydroxyl groups\n    ortho_hydroxyl_aromatic_carboxylic_acid = '[c][c]([OX2H])[c][c][c][CX3](=O)[OX2H1]'\n    \n    # Rule 14: Functional groups capable of intramolecular interactions reducing coordination\n    intramolecular_interactions = '[NX3][CX3](=O)[NX3][CX3](=O)[OX2H1]'\n    \n    # Rule 15: Chelating groups like adjacent carbonyl and hydroxyl groups\n    chelating_groups = '[CX3](=O)[CX3](=O)[OX2H1]'\n    \n    # Compile SMARTS patterns\n    patterns = {\n        'Rule 1': {'pattern': Chem.MolFromSmarts(alpha_amino_acid), 'prediction': 1},\n        'Rule 2': {'pattern': [Chem.MolFromSmarts(aromatic_carboxylic_acid), Chem.MolFromSmarts(electron_withdrawing_group)], 'prediction': 1},\n        'Rule 3': {'pattern': [Chem.MolFromSmarts(heteroaromatic_carboxylic_acid), Chem.MolFromSmarts(heteroaromatic_nitrogen)], 'prediction': 1},\n        'Rule 4': {'pattern': Chem.MolFromSmarts(long_chain_carboxylic_acid), 'prediction': 1},\n        'Rule 5': {'pattern': Chem.MolFromSmarts(adjacent_hydroxyl_carboxylic_acid), 'prediction': 1},\n        'Rule 6': {'pattern': Chem.MolFromSmarts(thiol_near_carboxylic_acid), 'prediction': 1},\n        'Rule 7': {'pattern': Chem.MolFromSmarts(perfluoroalkyl_carboxylic_acid), 'prediction': -1},\n        'Rule 8': {'pattern': Chem.MolFromSmarts(aromatic_carboxylic_with_adjacent_carbonyl), 'prediction': -1},\n        'Rule 9': {'pattern': [Chem.MolFromSmarts(amide_bond_carboxylic_acid), Chem.MolFromSmarts(n_acetylated_amino_acid)], 'prediction': -1},\n        'Rule 10': {'pattern': Chem.MolFromSmarts(ether_linkage_polar_terminal), 'prediction': -1},\n        'Rule 11': {'pattern': Chem.MolFromSmarts(bulky_substituents_near_carboxyl), 'prediction': -1},\n        'Rule 12': {'pattern': Chem.MolFromSmarts(long_chain_polar_distant), 'prediction': -1},\n        'Rule 13': {'pattern': Chem.MolFromSmarts(ortho_hydroxyl_aromatic_carboxylic_acid), 'prediction': 1},\n        'Rule 14': {'pattern': Chem.MolFromSmarts(intramolecular_interactions), 'prediction': -1},\n        'Rule 15': {'pattern': Chem.MolFromSmarts(chelating_groups), 'prediction': 1}\n    }\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(patterns))\n            continue\n        row = []\n        for rule_name, rule in patterns.items():\n            try:\n                match = False\n                if isinstance(rule['pattern'], list):\n                    # For patterns that require multiple matches\n                    sub_match = True\n                    for pat in rule['pattern']:\n                        if not mol.HasSubstructMatch(pat):\n                            sub_match = False\n                            break\n                    match = sub_match\n                else:\n                    # Single pattern match\n                    if mol.HasSubstructMatch(rule['pattern']):\n                        match = True\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=patterns.keys())\n    return df\n"
}