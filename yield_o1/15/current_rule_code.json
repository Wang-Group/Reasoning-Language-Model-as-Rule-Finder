{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit, applying the provided natural language rules to predict high or low yields based on structural features. Each rule is translated into SMARTS patterns for substructure searching. The output is a DataFrame where each column corresponds to a rule, and each row corresponds to a SMILES string from the input list.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    # Amino group (-NH2)\n    primary_amino = '[NX3H2]'\n    # Secondary amino group (-NH-)\n    secondary_amino = '[NX3H1]'\n    # Alpha-amino acid backbone: amino group attached to alpha carbon, which is attached to carboxylic acid\n    alpha_amino_acid = '[NX3H2][CX4H][CX3](=O)[OX2H1]'\n    # Additional carboxylic acid group in side chain\n    side_chain_carboxylic_acid = '[CX3](=O)[OX2H1]'\n    # Aromatic ring\n    aromatic_ring = '[a]'\n    # Para-substituted electron-donating groups on aromatic ring\n    para_amino_on_aromatic = 'c1ccc(N)cc1C(=O)O'\n    para_hydroxyl_on_aromatic = 'c1ccc(O)cc1C(=O)O'\n    # Aliphatic chain with functional group within three carbons of carboxyl group\n    aliphatic_chain_amino = '[CX3](=O)[OX2H1][C;X4][C;X4][C;X4][NX3;H2,H1]'\n    aliphatic_chain_hydroxyl = '[CX3](=O)[OX2H1][C;X4][C;X4][C;X4][OX2H]'\n    aliphatic_chain_thiol = '[CX3](=O)[OX2H1][C;X4][C;X4][C;X4][SX2H]'\n    # Nitrogenous heterocycles directly attached to carboxyl group\n    pyridine_carboxylic_acid = '[n][c][c][c][c][c][CX3](=O)[OX2H1]'\n    pyrazole_carboxylic_acid = '[n][n][c][c][c][CX3](=O)[OX2H1]'\n    # Electron-withdrawing groups on aromatic ring\n    aromatic_with_ewg = '[c]1[c][c][c]([CX3H]=O)[c][c]1C(=O)O'\n    aromatic_with_cf3 = '[c]1[c][c][c](C(F)(F)F)[c][c]1C(=O)O'\n    # Amide bond adjacent to carboxyl group\n    amide_adjacent_to_carboxyl = '[CX3](=O)[NX3][CX3](=O)[OX2H1]'\n    # Ether linkage near carboxyl group\n    ether_near_carboxyl = '[CX3](=O)[OX2H1][CX4][OX2][CX4]'\n    # Multiple hydroxyl groups near carboxyl group\n    multiple_hydroxyls = '[CX3](=O)[OX2H1][CX4][OX2H]'\n    # Ketone group near carboxyl group\n    ketone_near_carboxyl = '[CX3](=O)[CX3](=O)[CX4][CX3](=O)[OX2H1]'\n    # Biaryl structures without additional coordinating groups\n    biaryl_structure = 'c1ccc(cc1)-c2ccc(cc2)C(=O)O'\n    # Patterns for Rule 1\n    rule1_patterns = [alpha_amino_acid, side_chain_carboxylic_acid]\n    # Patterns for Rule 2\n    rule2_patterns = [aromatic_ring, carboxylic_acid, [para_amino_on_aromatic, para_hydroxyl_on_aromatic]]\n    # Patterns for Rule 3\n    rule3_patterns = [carboxylic_acid, [aliphatic_chain_amino, aliphatic_chain_hydroxyl, aliphatic_chain_thiol]]\n    # Patterns for Rule 4\n    rule4_patterns = [carboxylic_acid, [pyridine_carboxylic_acid, pyrazole_carboxylic_acid]]\n    # Patterns for Rule 5\n    rule5_patterns = [aromatic_ring, carboxylic_acid, [aromatic_with_ewg, aromatic_with_cf3]]\n    # Patterns for Rule 6\n    rule6_patterns = [amide_adjacent_to_carboxyl]\n    # Patterns for Rule 7\n    rule7_patterns = [carboxylic_acid, ether_near_carboxyl]\n    # Patterns for Rule 8\n    rule8_patterns = [carboxylic_acid, multiple_hydroxyls]\n    # Patterns for Rule 9\n    rule9_patterns = [carboxylic_acid, '[SX2H]']\n    # Patterns for Rule 10\n    rule10_patterns = [alpha_amino_acid, '[!$([NX3][a])]', '[c]']\n    # Patterns for Rule 11\n    rule11_patterns = [carboxylic_acid, ketone_near_carboxyl]\n    # Patterns for Rule 12\n    rule12_patterns = [carboxylic_acid, '[NX3;H2,H1]', '[OX2H]', '[SX2H]']\n    # Patterns for Rule 13\n    rule13_patterns = ['[CX3](=O)[OX2H1][CC][CC][CC][C;!$(C[OX2H])]']\n    # Patterns for Rule 14\n    rule14_patterns = [biaryl_structure]\n    # Patterns for Rule 15\n    rule15_patterns = [carboxylic_acid, '[c][c](OC)[c]']\n    # Define the rules\n    rules = [\n        {\n            'number': 1,\n            'description': 'Alpha-amino dicarboxylic acids result in a high yield.',\n            'patterns': rule1_patterns,\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Aromatic carboxylic acids with electron-donating groups in the para position result in a high yield.',\n            'patterns': rule2_patterns,\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Aliphatic carboxylic acids with functional groups within three carbons result in a high yield.',\n            'patterns': rule3_patterns,\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Carboxylic acids containing nitrogenous heterocycles directly attached result in a high yield.',\n            'patterns': rule4_patterns,\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Aromatic carboxylic acids with electron-withdrawing groups attached result in a low yield.',\n            'patterns': rule5_patterns,\n            'prediction': -1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers with amide bonds adjacent to the carboxyl group result in a low yield.',\n            'patterns': rule6_patterns,\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers with ether linkages near the carboxyl group result in a low yield.',\n            'patterns': rule7_patterns,\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers with multiple hydroxyl groups near the carboxyl group result in a high yield.',\n            'patterns': rule8_patterns,\n            'prediction': 1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers with thiol groups near the carboxyl group result in a high yield.',\n            'patterns': rule9_patterns,\n            'prediction': 1\n        },\n        {\n            'number': 10,\n            'description': 'Alpha-amino acids with bulky hydrophobic side chains and no additional coordinating groups result in a low yield.',\n            'patterns': rule10_patterns,\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers with ketone groups near the carboxyl group result in a low yield.',\n            'patterns': rule11_patterns,\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers with multiple coordinating groups near the carboxyl group result in a high yield.',\n            'patterns': rule12_patterns,\n            'prediction': 1\n        },\n        {\n            'number': 13,\n            'description': 'Aliphatic carboxylic acids with medium-length chains and no polar groups result in a high yield.',\n            'patterns': rule13_patterns,\n            'prediction': 1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers containing biaryl structures without additional coordinating groups result in a low yield.',\n            'patterns': rule14_patterns,\n            'prediction': -1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers with methoxy groups on the aromatic ring result in a high yield.',\n            'patterns': rule15_patterns,\n            'prediction': 1\n        }\n    ]\n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for group in rule['patterns']:\n            if isinstance(group, list):\n                compiled_group = [Chem.MolFromSmarts(pat) for pat in group]\n                compiled_patterns.append(compiled_group)\n            else:\n                compiled_patterns.append([Chem.MolFromSmarts(group)])\n        rule['compiled_patterns'] = compiled_patterns\n    # Initialize results list\n    results = []\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check required patterns\n                for compiled_group in rule['compiled_patterns']:\n                    group_match = False\n                    for pat in compiled_group:\n                        if mol.HasSubstructMatch(pat):\n                            group_match = True\n                            break\n                    if not group_match:\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}