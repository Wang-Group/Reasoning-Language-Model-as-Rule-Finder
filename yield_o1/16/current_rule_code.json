{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. It defines several rules based on structural features expressed as SMARTS patterns. For each SMILES string, the code checks whether the molecule matches the patterns associated with each rule, assigning a value of 1 if the rule predicts a high target value, -1 if it predicts a low target value, or 0 if there is no match.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define the rules with their associated SMARTS patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'High Yield: Modifiers that are dicarboxylic amino acids (\u03b1-amino acids with two carboxylate groups).',\n            'patterns': [\n                # \u03b1-amino acid with two carboxylic acid groups\n                '[NX3;H2][CH1][CH](C(=O)[O-])[C](=O)[O-]',  # Simplified pattern for aspartic and glutamic acid anions\n                '[NX3;H2][CH1][CH](C(=O)O)[C](=O)O'  # Protonated carboxylic acids\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'High Yield: Modifiers that are aromatic carboxylic acids with a para-substituted amino or nitro group.',\n            'patterns': [\n                # Para-amino-benzoic acid\n                'c1cc(N)ccc1C(=O)O',\n                # Para-nitro-benzoic acid\n                'c1cc([N+](=O)[O-])ccc1C(=O)O'\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'High Yield: Modifiers that are linear aliphatic carboxylic acids with chain lengths of six to eight carbons and no additional polar substituents.',\n            'patterns': [\n                # Aliphatic chain of 6-8 carbons ending with carboxylic acid\n                'CCCCCC(=O)O',  # Hexanoic acid\n                'CCCCCCC(=O)O',  # Heptanoic acid\n                'CCCCCCCC(=O)O'  # Octanoic acid\n            ],\n            'exclude_patterns': [\n                # Exclude molecules with polar substituents (e.g., hydroxyl, amino)\n                '[#6][OX2H]',  # Hydroxyl group\n                '[#6][NX3;H2,H1]',  # Amino group\n                '[#6][SX2H]'  # Thiol group\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'High Yield: Modifiers that are hydroxylated aliphatic carboxylic acids with multiple hydroxyl groups near the carboxyl group.',\n            'patterns': [\n                # Molecules with carboxylic acid and multiple hydroxyls nearby\n                '[C](O)(O)[C](O)[C](O)C(=O)O'  # Simplified pattern for gluconic acid\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'High Yield: Modifiers that are aromatic carboxylic acids with a para-substituted bromomethyl group.',\n            'patterns': [\n                # 4-(Bromomethyl)benzoic acid\n                'c1cc(ccc1C(=O)O)CBr'\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'High Yield: Modifiers that are heterocyclic carboxylic acids where the heterocycle contains nitrogen atoms and the carboxyl group is directly attached.',\n            'patterns': [\n                # Pyridine-3-carboxylic acid (nicotinic acid)\n                'n1cc(ccc1)C(=O)O',\n                # 1H-Pyrazole-4-carboxylic acid\n                'c1c(C(=O)O)[nH]n1'\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 7,\n            'description': 'High Yield: Modifiers that are aliphatic carboxylic acids with a terminal thiol group.',\n            'patterns': [\n                # 3-Sulfanylpropanoic acid\n                'OC(=O)CCS'\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 8,\n            'description': 'Low Yield: Modifiers that are aromatic carboxylic acids with a para-formyl (aldehyde) group.',\n            'patterns': [\n                # 4-Formylbenzoic acid\n                'O=CC1=CC=C(C=C1)C(=O)O'\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Low Yield: Modifiers that are fluorinated aliphatic carboxylic acids.',\n            'patterns': [\n                # Perfluorinated carboxylic acid\n                'C(F)(F)C(F)(F)C(F)(F)C(=O)O'\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Low Yield: Modifiers containing ether linkages near the carboxyl group.',\n            'patterns': [\n                # Molecules with ether linkage and carboxylic acid\n                'COCCOC(=O)O'\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Low Yield: Modifiers that are aromatic carboxylic acids with a para-methyl group.',\n            'patterns': [\n                # 4-Methylbenzoic acid\n                'CC1=CC=C(C=C1)C(=O)O'\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Low Yield: Modifiers that are amino acids with bulky hydrophobic side chains.',\n            'patterns': [\n                # Phenylalanine\n                'N[C@@H](CC1=CC=CC=C1)C(=O)O'\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Low Yield: Modifiers that are linear aliphatic carboxylic acids with terminal amino groups located six or more carbons away from the carboxyl group.',\n            'patterns': [\n                # 8-Aminooctanoic acid\n                'NCCCCCCCC(=O)O'\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'High Yield: Modifiers that are aromatic carboxylic acids connected via an aliphatic spacer (four carbons or more) to a heterocyclic ring.',\n            'patterns': [\n                # 4-Pyridin-4-ylbutanoic acid\n                'OC(=O)CCCC1=CC=NC=C1'\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers that are aromatic carboxylic acids with a para-hydroxy group directly attached to the ring result in a low yield, whereas those with the hydroxy group attached via an aliphatic linker result in a high yield.',\n            'patterns': [\n                # Low Yield: Hydroxy directly attached\n                'OC1=CC=C(C=C1)C(=O)O',  # 4-Hydroxybenzoic acid\n                # High Yield: Hydroxy attached via linker\n                'OCCC1=CC=C(C=C1)C(=O)O'  # 3-(4-Hydroxyphenyl)propanoic acid\n            ],\n            'prediction': [\n                -1,  # For directly attached hydroxy\n                1    # For hydroxy via linker\n            ]\n        }\n    ]\n\n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for pattern in rule['patterns']:\n            compiled_patterns.append(Chem.MolFromSmarts(pattern))\n        rule['compiled_patterns'] = compiled_patterns\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = False\n                # For Rule 15 which has different predictions\n                if rule['number'] == 15:\n                    matches = []\n                    for idx, pat in enumerate(rule['compiled_patterns']):\n                        if mol.HasSubstructMatch(pat):\n                            match = True\n                            row.append(rule['prediction'][idx])\n                            break\n                    if not match:\n                        row.append(0)\n                else:\n                    # Exclude patterns if any\n                    exclude = False\n                    if 'exclude_patterns' in rule:\n                        for ex_pat in rule['exclude_patterns']:\n                            ex_mol = Chem.MolFromSmarts(ex_pat)\n                            if mol.HasSubstructMatch(ex_mol):\n                                exclude = True\n                                break\n                    if exclude:\n                        row.append(0)\n                        continue\n                    # Check for matches\n                    for pat in rule['compiled_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = True\n                            break\n                    if match:\n                        row.append(rule['prediction'])\n                    else:\n                        row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}