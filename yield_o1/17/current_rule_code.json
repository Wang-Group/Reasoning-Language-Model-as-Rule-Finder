{
    "prefix": "This code defines a function 'rule2matrix' that processes a list of SMILES strings and generates a feature matrix where each column corresponds to a rule specified in the provided set of rules. Each rule is represented by SMARTS patterns, and the function uses RDkit to check for the presence of these patterns in each molecule. The output is a pandas DataFrame with a value of 0 if the rule does not match, 1 if the rule matches and predicts a high yield, and -1 if the rule matches and predicts a low yield.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns\n    carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1]'\n    amino_group = '[NX3;H2]'\n    hydroxyl_group = '[OX2H]'\n    aromatic_atom = '[a]'\n    nitro_group = '[NX3](=O)=O'\n    aromatic_amino = '[NX3;H2][c]'\n    thiol_group = '[SX2H]'\n    halogen = '[F,Cl,Br,I]'\n    methoxy_group = '[OX2][CH3]'\n    ether_linkage = '[#6][OX2][#6]'\n    pyridine_ring = 'n1ccccc1'\n    aldehyde_group = '[CX3H1](=O)'  # Aldehyde group\n    bromomethyl_group = '[CH2][Br]'\n    fluorinated_alkyl_chain = '[CX4][F]'\n    \n    # Initialize list of rules\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are aliphatic dicarboxylic amino acids predict a high yield.',\n            'patterns': [\n                [carboxylic_acid],\n                [amino_group]\n            ],\n            'exclude_patterns': [\n                [aromatic_atom]\n            ],\n            'count_threshold': {carboxylic_acid: 2},\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers that are short-chain aliphatic amino acids with terminal amino groups within five carbons of the carboxyl group predict a high yield.',\n            'patterns': [\n                [carboxylic_acid],\n                [amino_group]\n            ],\n            'distance': 5,\n            'exclude_patterns': [\n                [aromatic_atom]\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers that are polyhydroxy carboxylic acids predict a high yield.',\n            'patterns': [\n                [carboxylic_acid],\n                [hydroxyl_group]\n            ],\n            'count_threshold': {hydroxyl_group: 2},\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers that are aromatic carboxylic acids with para-substituted amino or nitro groups predict a high yield.',\n            'patterns': [\n                ['c1cc(ccc1[NX3;H2])C(=O)O', 'c1cc(ccc1[NX3;H1])C(=O)O', 'c1cc(ccc1[NX3](=O)=O)C(=O)O']\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers that are heteroaromatic carboxylic acids with nitrogen atoms capable of coordination predict a high yield.',\n            'patterns': [\n                [pyridine_ring],\n                [carboxylic_acid]\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers with fluorinated alkyl chains predict a low yield.',\n            'patterns': [\n                [fluorinated_alkyl_chain]\n            ],\n            'prediction': -1\n        },\n        # ... Additional rules would be defined similarly ...\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for group in rule.get('patterns', []):\n            compiled_group = [Chem.MolFromSmarts(p) for p in group]\n            compiled_patterns.append(compiled_group)\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for group in rule['exclude_patterns']:\n                compiled_group = [Chem.MolFromSmarts(p) for p in group]\n                compiled_excludes.append(compiled_group)\n            rule['compiled_exclude_patterns'] = compiled_excludes\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for group in rule['compiled_exclude_patterns']:\n                        for pat in group:\n                            if mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                        if not match:\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for idx, compiled_group in enumerate(rule['compiled_patterns']):\n                    group_match = False\n                    for pat in compiled_group:\n                        matches = mol.GetSubstructMatches(pat)\n                        if matches:\n                            # If a count threshold is specified for this pattern\n                            if 'count_threshold' in rule and pat.GetSmarts() in rule['count_threshold']:\n                                threshold = rule['count_threshold'][pat.GetSmarts()]\n                                if len(matches) >= threshold:\n                                    group_match = True\n                                    break\n                            else:\n                                group_match = True\n                                break\n                    if not group_match:\n                        match = False\n                        break\n                # Check distance if specified\n                if match and 'distance' in rule:\n                    # Get indices of amino groups and carboxylic acids\n                    amino_pat = Chem.MolFromSmarts(amino_group)\n                    carboxy_pat = Chem.MolFromSmarts(carboxylic_acid)\n                    amino_atoms = mol.GetSubstructMatches(amino_pat)\n                    carboxy_atoms = mol.GetSubstructMatches(carboxy_pat)\n                    distance_match = False\n                    for a in amino_atoms:\n                        for c in carboxy_atoms:\n                            path = Chem.GetShortestPath(mol, a[0], c[0])\n                            if len(path) - 1 <= rule['distance']:\n                                distance_match = True\n                                break\n                        if distance_match:\n                            break\n                    if not distance_match:\n                        match = False\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}