{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit, following the specified natural language rules. Each rule corresponds to a column in the matrix, and each SMILES string corresponds to a row. The code utilizes SMARTS patterns and, where necessary, computes distances within the molecular graph to identify the presence of specific substructures and functional groups as per the rules. Error handling is included to manage cases where molecules cannot be parsed or where substructure searches may raise exceptions.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns and compile them\n    carboxyl_group = Chem.MolFromSmarts('[CX3](=O)[O-]')\n    carboxylic_acid = Chem.MolFromSmarts('[CX3](=O)[OX1H0]')\n    amino_group = Chem.MolFromSmarts('[NX3;H2]')\n    hydroxyl_group = Chem.MolFromSmarts('[OX2H]')\n    thiol_group = Chem.MolFromSmarts('[SX2H]')\n    thioether_group = Chem.MolFromSmarts('[SX2][#6]')\n    ether_linkage = Chem.MolFromSmarts('[#6][OX2][#6]')\n    aldehyde_group = Chem.MolFromSmarts('[CX3H1](=O)')\n    ketone_group = Chem.MolFromSmarts('[#6][CX3](=O)[#6]')\n    aromatic_ring = Chem.MolFromSmarts('a1aaaaa1')\n    para_substituted_aromatic = Chem.MolFromSmarts('c1ccc([*:1])cc1')\n    electron_withdrawing_groups = [\n        Chem.MolFromSmarts('[NX3+](=O)[O-]'),  # Nitro group\n        Chem.MolFromSmarts('[NX3][CX3](=O)[OX1]'),  # Amide group\n        Chem.MolFromSmarts('[CX3](=O)[OX1H0]'),  # Carboxylic acid\n        Chem.MolFromSmarts('[F,Cl,Br,I]'),  # Halogens\n    ]\n    electron_donating_groups = [\n        Chem.MolFromSmarts('[OX2H]'),  # Hydroxyl group\n        Chem.MolFromSmarts('[OX2][#6]'),  # Methoxy group\n        Chem.MolFromSmarts('[NX3;H2,H1][#6]'),  # Amino group\n        Chem.MolFromSmarts('[CX4H3]'),  # Methyl group\n    ]\n    perfluorinated_chain = Chem.MolFromSmarts('[CX4](F)(F)(F)')\n    heteroaromatic_nitrogen = Chem.MolFromSmarts('[n]')\n    additional_aromatic_ring = Chem.MolFromSmarts('c1ccc(cc1)-c2ccccc2')\n    aliphatic_chain_five_or_more = Chem.MolFromSmarts('[CH2][CH2][CH2][CH2][CH2]')\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*10)\n            continue\n        row = [0]*10  # Initialize the row with zeros for 10 rules\n        try:\n            # Rule 1: Amino acids or amino acid derivatives with side-chain coordinating groups within three carbons from the alpha carbon result in high yield; those with hydrophobic side chains extending beyond four carbons result in low yield.\n            rule1_high = False\n            rule1_low = False\n            # Identify alpha carbon: carbon attached to both amino group and carboxyl group\n            matches = mol.GetSubstructMatches(Chem.MolFromSmarts('[NX3;H2][CHX4][CX3](=O)[OX1H0,-1]'))\n            if matches:\n                for match in matches:\n                    alpha_c_idx = match[1]\n                    alpha_c_atom = mol.GetAtomWithIdx(alpha_c_idx)\n                    # Search for coordinating groups within 3 bonds from alpha carbon\n                    coordinating_group_found = False\n                    for neighbor in Chem.IterateNeighbors(mol, alpha_c_atom):\n                        path = Chem.GetShortestPath(mol, alpha_c_idx, neighbor.GetIdx())\n                        if len(path) > 3:\n                            continue\n                        neighbor_atom = neighbor\n                        if neighbor_atom.HasSubstructMatch(carboxyl_group) or neighbor_atom.HasSubstructMatch(amino_group) or neighbor_atom.HasSubstructMatch(hydroxyl_group):\n                            coordinating_group_found = True\n                            break\n                    if coordinating_group_found:\n                        rule1_high = True\n                        break\n                    # Check for hydrophobic side chains extending beyond four carbons\n                    for neighbor in Chem.IterateNeighbors(mol, alpha_c_atom):\n                        if neighbor.GetAtomicNum() == 6 and not neighbor.IsInRing():\n                            chain_length = 1\n                            current_idx = neighbor.GetIdx()\n                            visited = set([alpha_c_idx])\n                            stack = [(current_idx, chain_length)]\n                            while stack:\n                                curr_idx, curr_length = stack.pop()\n                                if curr_length > 4:\n                                    rule1_low = True\n                                    break\n                                visited.add(curr_idx)\n                                curr_atom = mol.GetAtomWithIdx(curr_idx)\n                                for nbr in curr_atom.GetNeighbors():\n                                    nbr_idx = nbr.GetIdx()\n                                    if nbr_idx not in visited and nbr.GetAtomicNum() == 6 and not nbr.IsInRing():\n                                        stack.append((nbr_idx, curr_length+1))\n                            if rule1_low:\n                                break\n                if rule1_high:\n                    row[0] = 1\n                elif rule1_low:\n                    row[0] = -1\n        except Exception:\n            row[0] = 0\n        try:\n            # Rule 2: Aromatic carboxylic acids with para-substituted coordinating electron-withdrawing groups result in high yield; those with electron-donating groups result in low yield.\n            rule2_high = False\n            rule2_low = False\n            # Check for para-substituted aromatic carboxylic acid\n            for match in mol.GetSubstructMatches(para_substituted_aromatic):\n                substituent_atom = mol.GetAtomWithIdx(match[1])\n                # Check for electron-withdrawing groups\n                for ewg in electron_withdrawing_groups:\n                    if substituent_atom.HasSubstructMatch(ewg):\n                        rule2_high = True\n                        break\n                # Check for electron-donating groups\n                for edg in electron_donating_groups:\n                    if substituent_atom.HasSubstructMatch(edg):\n                        rule2_low = True\n                        break\n                if rule2_high or rule2_low:\n                    break\n            if rule2_high:\n                row[1] = 1\n            elif rule2_low:\n                row[1] = -1\n        except Exception:\n            row[1] = 0\n        try:\n            # Rule 3: Aliphatic carboxylic acids with hydroxyl or thiol groups within three carbons of the carboxyl group result in high yield; if such groups are further than four carbons away, they result in low yield.\n            rule3_high = False\n            rule3_low = False\n            carboxylic_acid_atoms = mol.GetSubstructMatches(carboxylic_acid)\n            if carboxylic_acid_atoms:\n                for match in carboxylic_acid_atoms:\n                    ca_idx = match[0]\n                    ca_atom = mol.GetAtomWithIdx(ca_idx)\n                    # Search for hydroxyl or thiol groups within 3 bonds\n                    bfs = Chem.FindAtomEnvironmentOfRadiusN(mol, 3, ca_idx)\n                    amap = {}\n                    submol = Chem.PathToSubmol(mol, bfs, atomMap=amap)\n                    for atom in submol.GetAtoms():\n                        if atom.HasSubstructMatch(hydroxyl_group) or atom.HasSubstructMatch(thiol_group):\n                            rule3_high = True\n                            break\n                    # Check if hydroxyl or thiol groups are further than 4 bonds away\n                    if not rule3_high:\n                        dfs_visited = set()\n                        stack = [(ca_idx, 0)]\n                        while stack:\n                            current_idx, depth = stack.pop()\n                            if depth > 4:\n                                break\n                            dfs_visited.add(current_idx)\n                            current_atom = mol.GetAtomWithIdx(current_idx)\n                            if current_atom.HasSubstructMatch(hydroxyl_group) or current_atom.HasSubstructMatch(thiol_group):\n                                if depth <= 3:\n                                    rule3_high = True\n                                else:\n                                    rule3_low = True\n                                break\n                            for neighbor in current_atom.GetNeighbors():\n                                nbr_idx = neighbor.GetIdx()\n                                if nbr_idx not in dfs_visited:\n                                    stack.append((nbr_idx, depth+1))\n                    if rule3_high or rule3_low:\n                        break\n            if rule3_high:\n                row[2] = 1\n            elif rule3_low:\n                row[2] = -1\n        except Exception:\n            row[2] = 0\n        try:\n            # Rule 4: Modifiers containing heteroaromatic rings with nitrogen atoms capable of coordination result in high yield; those with additional aromatic rings directly attached result in low yield.\n            rule4_high = False\n            rule4_low = False\n            if mol.HasSubstructMatch(heteroaromatic_nitrogen):\n                rule4_high = True\n                if mol.HasSubstructMatch(additional_aromatic_ring):\n                    rule4_low = True\n                    rule4_high = False\n            if rule4_high:\n                row[3] = 1\n            elif rule4_low:\n                row[3] = -1\n        except Exception:\n            row[3] = 0\n        try:\n            # Rule 5: Modifiers that are aliphatic carboxylic acids with ether linkages in the chain result in low yield.\n            if mol.HasSubstructMatch(carboxylic_acid) and mol.HasSubstructMatch(ether_linkage):\n                row[4] = -1\n        except Exception:\n            row[4] = 0\n        try:\n            # Rule 6: Modifiers with aldehyde or ketone groups adjacent to the carboxyl group or aromatic ring result in low yield.\n            if mol.HasSubstructMatch(aliphatic_chain_five_or_more) and (mol.HasSubstructMatch(aldehyde_group) or mol.HasSubstructMatch(ketone_group)):\n                row[5] = -1\n        except Exception:\n            row[5] = 0\n        try:\n            # Rule 7: Aromatic carboxylic acids linked by aliphatic chains (three or more carbons) to additional aromatic rings with coordinating substituents result in high yield; those without such linkers result in low yield.\n            rule7_high = False\n            rule7_low = False\n            if mol.HasSubstructMatch(aromatic_ring) and mol.HasSubstructMatch(carboxylic_acid):\n                # Check for aliphatic chain linker of three or more carbons to another aromatic ring with coordinating substituents\n                linker = Chem.MolFromSmarts('c1aaaaa1CCCc2aaaaa2')\n                if mol.HasSubstructMatch(linker):\n                    rule7_high = True\n                else:\n                    rule7_low = True\n            if rule7_high:\n                row[6] = 1\n            elif rule7_low:\n                row[6] = -1\n        except Exception:\n            row[6] = 0\n        try:\n            # Rule 8: Modifiers that are perfluorinated carboxylic acids result in low yield.\n            if mol.HasSubstructMatch(perfluorinated_chain) and mol.HasSubstructMatch(carboxylic_acid):\n                row[7] = -1\n        except Exception:\n            row[7] = 0\n        try:\n            # Rule 9: Modifiers that are simple aliphatic carboxylic acids without additional functional groups and with chain lengths of eight carbons or less result in high yield.\n            rule9_high = False\n            aliphatic_chain = Chem.MolFromSmarts('[CX4H2][CX4H2][CX4H2][CX4H2][CX4H2][CX4H2][CX4H2][CX4H2][CX3](=O)[OX1H0]')\n            if mol.HasSubstructMatch(aliphatic_chain):\n                num_atoms = mol.GetNumAtoms()\n                if num_atoms <= 50:  # Adjust maximum number of atoms as needed\n                    rule9_high = True\n            if rule9_high:\n                row[8] = 1\n        except Exception:\n            row[8] = 0\n        try:\n            # Rule 10: Modifiers containing sulfur in coordinating functional groups (e.g., thiol) result in high yield, but those with sulfur in non-coordinating groups (e.g., thioether) result in low yield.\n            if mol.HasSubstructMatch(thiol_group):\n                row[9] = 1\n            elif mol.HasSubstructMatch(thioether_group):\n                row[9] = -1\n        except Exception:\n            row[9] = 0\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {i+1}' for i in range(10)])\n    return df\n"
}