{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit, applying substructure matching rules to assign values based on the presence of specific functional groups and structural motifs. The code defines SMARTS patterns for each rule, incorporating corrections from suggestions to improve accuracy. Each rule corresponds to a column in the resulting DataFrame, with values of 1, -1, or 0 based on whether the rule predicts a high yield, a low yield, or does not match.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for the rules, applying corrections from suggestions\n    \n    # Rule 1: \u03b1-amino dicarboxylic acids (aspartic acid, glutamic acid) lead to a high yield\n    # Suggestion 1: Remove stereochemistry constraints and generalize the pattern\n    # Define pattern for \u03b1-amino acids with a side-chain carboxyl group\n    alpha_amino_dicarboxylic_acid = Chem.MolFromSmarts('[NX3;H2,H1][CX4;H]([CX4])[CX3](=O)[O;H1,-]')\n    \n    # Rule 2: Aromatic carboxylic acids with EWGs or EDGs at the para position\n    # Suggestion 2: Use general patterns to represent EWGs and EDGs, ensure positional specificity\n    # General aromatic carboxylic acid\n    aromatic_carboxylic_acid = Chem.MolFromSmarts('c1ccccc1C(=O)[O;H1,-]')\n    # EWGs at para position\n    ewg_para = Chem.MolFromSmarts('c1cc([C](=O)[O;H1,-])ccc1[!#6;!H0]')  # Non-carbon heavy atom at para position\n    # EDGs at para position\n    edg_para = Chem.MolFromSmarts('c1cc([C](=O)[O;H1,-])ccc1[C,N,O]')  # Carbon, nitrogen, or oxygen atom at para position\n    \n    # Rule 3: Aliphatic carboxylic acids with amino or hydroxyl groups within two carbons lead to high yield\n    # Those with these groups more than four carbons away lead to low yield\n    # Suggestion 3: Update patterns to reflect exact carbon counts\n    amino_within_two_carbons = Chem.MolFromSmarts('[NX3;H2,H1][CX4][CX3](=O)[O;H1,-]')\n    hydroxyl_within_two_carbons = Chem.MolFromSmarts('[OX2H][CX4][CX3](=O)[O;H1,-]')\n    amino_beyond_four_carbons = Chem.MolFromSmarts('[CX4][CX4][CX4][CX4][NX3;H2,H1]')\n    hydroxyl_beyond_four_carbons = Chem.MolFromSmarts('[CX4][CX4][CX4][CX4][OX2H]')\n    \n    # Rule 4: Aromatic heterocyclic carboxylic acids with nitrogen atoms in the ring directly attached\n    # Suggestion 4: Modify pattern to ensure nitrogen is part of the ring and directly bonded to carboxyl group\n    aromatic_heterocycle_carboxylic_acid = Chem.MolFromSmarts('[nH0,r5,r6][c,r5,r6](=O)[O;H1,-]')\n    heterocycle_via_linker = Chem.MolFromSmarts('[nH0,r5,r6][CX4][c,r5,r6](=O)[O;H1,-]')\n    \n    # Rule 5: Perfluorinated alkyl chains or highly fluorinated groups lead to low yield\n    # Suggestion 5: Update pattern to detect perfluoroalkyl chains of any length\n    perfluorinated_alkyl_chain = Chem.MolFromSmarts('[CX4](F)(F)(F)[CX4](F)(F)F')  # Matches longer perfluoroalkyl chains\n    \n    # Rule 6: Aliphatic carboxylic acids without additional functional groups lead to high yield\n    # Suggestion 6: Refine exclusion pattern\n    aliphatic_carboxylic_acid_simple = Chem.MolFromSmarts('[CX4][CX3](=O)[O;H1,-]')\n    exclude_functional_groups = Chem.MolFromSmarts('[CX4;!$(C(=O)[O;H1,-])][!#6;!H0]')  # Exclude atoms other than carbon and hydrogen attached to the chain\n    \n    # Rule 7: Modifiers containing multiple ether linkages or polyether chains lead to low yield\n    # Suggestion 7: Use recursive pattern to match multiple ether linkages\n    polyether_chain = Chem.MolFromSmarts('[CX4;!$(C=O)]([OX2][CX4;!$(C=O)]){2,}')  # Two or more consecutive ether bonds\n    \n    # Rule 8: Bulky substituents near the carboxyl group lead to low yield; if bulky groups are distant, they have less impact\n    # Suggestion 8: Adjust patterns for bulky groups near and distant from carboxylate\n    bulky_near_carboxyl = Chem.MolFromSmarts('[CX3](=O)[O;H1,-][CX4][C](c1ccccc1)')\n    bulky_distant = Chem.MolFromSmarts('[CX3](=O)[O;H1,-][CX4][CX4][CX4][CX4][C](c1ccccc1)')\n    \n    # Rule 9: N-acylated amino acids or peptides lead to low yield\n    # Suggestion 9: Refine pattern to match N-acylated amino acids or peptides\n    n_acylated_amino_acid = Chem.MolFromSmarts('C(=O)N[CX4][CX3](=O)[O;H1,-]')\n    \n    # Rule 10: Aromatic carboxylic acids fused with oxygen-containing heterocycles lead to high yield\n    # Suggestion 10: Generalize pattern for oxygen heterocycles fused to aromatic systems\n    fused_oxygen_heterocycle = Chem.MolFromSmarts('[cH]1[cH][cH][cH][o][c]1C(=O)[O;H1,-]')\n    \n    # Rule 11: Electron-rich aromatic systems connected via flexible aliphatic linkers\n    # Suggestion 11: Differentiate between short and long aliphatic linkers\n    electron_rich_aromatic = Chem.MolFromSmarts('c[O,N,S]')  # Aromatic ring with O, N, or S attached\n    flexible_linker_short = Chem.MolFromSmarts('c[CX4][CX4][CX3](=O)[O;H1,-]')  # Short linker (less than 4 carbons)\n    flexible_linker_long = Chem.MolFromSmarts('c[CX4][CX4][CX4][CX4][CX3](=O)[O;H1,-]')  # Long linker (4 or more carbons)\n    \n    # Rule 12: Thiol groups proximal to carboxyl group lead to high yield; aromatic thiols lead to low yield\n    # Suggestion 12: Distinguish between aliphatic and aromatic thiols\n    thiol_proximal = Chem.MolFromSmarts('[SX2H][CX4][CX3](=O)[O;H1,-]')\n    aromatic_thiol = Chem.MolFromSmarts('c[SX2H]')\n    \n    # Rule 13: Modifiers containing aldehyde groups lead to low yield\n    # Suggestion 13: Modify pattern to match aldehydes attached to aromatic rings\n    aldehyde_group = Chem.MolFromSmarts('c[CX3H1](=O)')\n    \n    # Rule 14: Modifiers with multiple hydroxyl groups proximal to the carboxyl group lead to high yield\n    # Suggestion 14: Adjust pattern to detect multiple proximal hydroxyl groups\n    multiple_hydroxyls_proximal = Chem.MolFromSmarts('[OX2H][CX4][OX2H][CX4][CX3](=O)[O;H1,-]')\n    \n    # Initialize the feature matrix\n    feature_matrix = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            feature_matrix.append([0]*14)\n            continue\n        row = []\n        \n        # Rule 1\n        try:\n            if mol.HasSubstructMatch(alpha_amino_dicarboxylic_acid):\n                row.append(1)\n            else:\n                row.append(0)\n        except:\n            row.append(0)\n        \n        # Rule 2\n        try:\n            if mol.HasSubstructMatch(ewg_para):\n                row.append(1)\n            elif mol.HasSubstructMatch(edg_para):\n                row.append(-1)\n            else:\n                row.append(0)\n        except:\n            row.append(0)\n        \n        # Rule 3\n        try:\n            if mol.HasSubstructMatch(amino_within_two_carbons) or mol.HasSubstructMatch(hydroxyl_within_two_carbons):\n                row.append(1)\n            elif mol.HasSubstructMatch(amino_beyond_four_carbons) or mol.HasSubstructMatch(hydroxyl_beyond_four_carbons):\n                row.append(-1)\n            else:\n                row.append(0)\n        except:\n            row.append(0)\n        \n        # Rule 4\n        try:\n            if mol.HasSubstructMatch(aromatic_heterocycle_carboxylic_acid):\n                row.append(1)\n            elif mol.HasSubstructMatch(heterocycle_via_linker):\n                row.append(-1)\n            else:\n                row.append(0)\n        except:\n            row.append(0)\n        \n        # Rule 5\n        try:\n            if mol.HasSubstructMatch(perfluorinated_alkyl_chain):\n                row.append(-1)\n            else:\n                row.append(0)\n        except:\n            row.append(0)\n        \n        # Rule 6\n        try:\n            if mol.HasSubstructMatch(aliphatic_carboxylic_acid_simple):\n                if not mol.HasSubstructMatch(exclude_functional_groups):\n                    row.append(1)\n                else:\n                    row.append(0)\n            else:\n                row.append(0)\n        except:\n            row.append(0)\n        \n        # Rule 7\n        try:\n            if mol.HasSubstructMatch(polyether_chain):\n                row.append(-1)\n            else:\n                row.append(0)\n        except:\n            row.append(0)\n        \n        # Rule 8\n        try:\n            if mol.HasSubstructMatch(bulky_near_carboxyl):\n                row.append(-1)\n            elif mol.HasSubstructMatch(bulky_distant):\n                row.append(1)\n            else:\n                row.append(0)\n        except:\n            row.append(0)\n        \n        # Rule 9\n        try:\n            if mol.HasSubstructMatch(n_acylated_amino_acid):\n                row.append(-1)\n            else:\n                row.append(0)\n        except:\n            row.append(0)\n        \n        # Rule 10\n        try:\n            if mol.HasSubstructMatch(fused_oxygen_heterocycle):\n                row.append(1)\n            else:\n                row.append(0)\n        except:\n            row.append(0)\n        \n        # Rule 11\n        try:\n            if mol.HasSubstructMatch(electron_rich_aromatic):\n                if mol.HasSubstructMatch(flexible_linker_long):\n                    row.append(1)\n                elif mol.HasSubstructMatch(flexible_linker_short):\n                    row.append(-1)\n                else:\n                    row.append(0)\n            else:\n                row.append(0)\n        except:\n            row.append(0)\n        \n        # Rule 12\n        try:\n            if mol.HasSubstructMatch(thiol_proximal):\n                row.append(1)\n            elif mol.HasSubstructMatch(aromatic_thiol):\n                row.append(-1)\n            else:\n                row.append(0)\n        except:\n            row.append(0)\n        \n        # Rule 13\n        try:\n            if mol.HasSubstructMatch(aldehyde_group):\n                row.append(-1)\n            else:\n                row.append(0)\n        except:\n            row.append(0)\n        \n        # Rule 14\n        try:\n            # For multiple hydroxyl groups proximal to carboxyl group, we need to check for matches\n            hydroxyl_matches = mol.GetSubstructMatches(multiple_hydroxyls_proximal)\n            if hydroxyl_matches:\n                row.append(1)\n            else:\n                row.append(0)\n        except:\n            row.append(0)\n        \n        # Append the row to the feature matrix\n        feature_matrix.append(row)\n    \n    # Create DataFrame with results\n    df = pd.DataFrame(feature_matrix, columns=[f'Rule {i}' for i in range(1, 15)])\n    return df"
}