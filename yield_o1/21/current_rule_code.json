{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. For each SMILES string, it applies 15 structural rules to determine if the molecule matches each rule, and assigns a value according to the rule's prediction (1 for high yield, -1 for low yield, 0 for no match). The output is a pandas DataFrame where each row corresponds to a SMILES string and each column corresponds to a rule.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    patterns = {}\n    \n    # Common SMARTS patterns\n    patterns['carboxylic_acid'] = '[CX3](=O)[OX2H1]'\n    patterns['primary_amine'] = '[NX3;H2][#6]'\n    patterns['secondary_amine'] = '[NX3;H1][#6][#6]'\n    patterns['amide'] = '[CX3](=O)[NX3H1,H0]'\n    patterns['ether'] = '[#6][OX2][#6]'\n    patterns['thiol'] = '[#16X2H]'  # -SH group\n    patterns['aliphatic_chain'] = '[C;X4H2][C;X4H2][C;X4H2][C;X4H2][C;X4H2]'\n    patterns['long_aliphatic_chain'] = '[C;X4H2][C;X4H2][C;X4H2][C;X4H2][C;X4H2][C;X4H2]'  # 6 or more carbons\n    patterns['aromatic_ring'] = '[a]'\n    patterns['para_substituted_benzoic_acid'] = 'c1ccc(cc1)C(=O)O'\n    patterns['para_amino_group'] = 'c1ccc(N)cc1'\n    patterns['para_hydroxy_group'] = 'c1ccc(O)cc1'\n    patterns['para_methyl_group'] = 'c1ccc(C)cc1'\n    patterns['para_nitro_group'] = 'c1ccc([N+](=O)[O-])cc1'\n    patterns['pyridine_carboxylic_acid'] = 'n1cccc1C(=O)O'\n    patterns['pyrazole_carboxylic_acid'] = 'n1nccc1C(=O)O'\n    patterns['thiol_aliphatic_chain'] = '[#16X2H][C;X4H2][C;X4H2][C;X4H2][C;X4H2]'\n    patterns['ether_linkage_aliphatic'] = '[C;X4][OX2][C;X4]'\n    patterns['amide_bond'] = '[CX3](=O)[NX3][C]'\n    patterns['perfluoroalkyl'] = '[CX4](F)(F)F'\n    patterns['trifluoroacetyl'] = 'CC(=O)C(F)(F)F'\n    patterns['ketone_adjacent_carboxylic'] = '[CX3](=O)[CX3](=O)'\n    patterns['aldehyde_adjacent_carboxylic'] = '[CX3H1](=O)[CX3](=O)'\n    patterns['multiple_hydroxyl'] = '[OX2H][CX4][OX2H]'\n    patterns['heteroaromatic_para_substituent'] = 'c1ccc([a])cc1'\n    patterns['phenolic_propanoic_acid'] = 'OCc1ccc(CC(=O)O)cc1'\n    patterns['bulky_hydrophobic_side_chain'] = '[CX3](C)[CX3](C)[CX3](C)'\n    \n    # Compile the patterns\n    compiled_patterns = {}\n    for key, smarts in patterns.items():\n        compiled_patterns[key] = Chem.MolFromSmarts(smarts)\n    \n    # Define the rules\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are amino acids with an additional carboxylic acid group (amino dicarboxylic acids) result in high yield.',\n            'smarts': [patterns['carboxylic_acid'], patterns['primary_amine'], patterns['carboxylic_acid']],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers with a carboxylic acid group and a primary amino group located on a short aliphatic chain of five carbons or fewer result in high yield. Similar amino acids with longer aliphatic chains (more than five carbons) result in low yield.',\n            'smarts': [patterns['carboxylic_acid'], patterns['primary_amine'], patterns['aliphatic_chain']],\n            'exclude_smarts': [patterns['long_aliphatic_chain']],\n            'prediction': 1,\n            'inverse_prediction': -1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers that are para-substituted aromatic carboxylic acids with electron-donating coordinating groups such as amino (-NH2) or hydroxy (-OH) groups at the para position result in high yield. Substituents that are non-coordinating groups result in low yield.',\n            'smarts': [patterns['para_substituted_benzoic_acid'], [patterns['para_amino_group'], patterns['para_hydroxy_group']]],\n            'exclude_smarts': [patterns['para_methyl_group']],\n            'prediction': 1,\n            'inverse_prediction': -1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers that are para-substituted aromatic carboxylic acids with electron-withdrawing groups such as nitro (-NO2) at the para position result in high yield.',\n            'smarts': [patterns['para_substituted_benzoic_acid'], patterns['para_nitro_group']],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers that are heterocyclic carboxylic acids containing nitrogen heteroatoms adjacent to the carboxyl group result in high yield.',\n            'smarts': [[patterns['pyridine_carboxylic_acid'], patterns['pyrazole_carboxylic_acid']]],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers containing both a carboxylic acid group and a thiol (-SH) group on a short aliphatic chain (three carbons or fewer) result in high yield.',\n            'smarts': [patterns['carboxylic_acid'], patterns['thiol_aliphatic_chain']],\n            'prediction': 1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers that are long-chain aliphatic carboxylic acids without additional functional groups result in high yield.',\n            'smarts': [patterns['carboxylic_acid'], patterns['long_aliphatic_chain']],\n            'exclude_smarts': [patterns['primary_amine'], patterns['secondary_amine'], patterns['amide'], patterns['thiol'], patterns['ether']],\n            'prediction': 1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers containing ether linkages, especially polyether chains extending from the carboxylic acid, result in low yield.',\n            'smarts': [patterns['carboxylic_acid'], patterns['ether_linkage_aliphatic']],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers with amide bonds linking functional groups or amino acids (containing amide linkages) result in low yield.',\n            'smarts': [patterns['carboxylic_acid'], patterns['amide_bond']],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers containing highly electron-withdrawing groups attached to the carboxylic acid, such as perfluoroalkyl or trifluoroacetyl groups result in low yield.',\n            'smarts': [patterns['carboxylic_acid'], [patterns['perfluoroalkyl'], patterns['trifluoroacetyl']]],\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers with additional carbonyl groups (ketone or aldehyde) adjacent to the carboxylic acid group result in low yield.',\n            'smarts': [patterns['carboxylic_acid'], [patterns['ketone_adjacent_carboxylic'], patterns['aldehyde_adjacent_carboxylic']]],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers with multiple hydroxyl (-OH) groups along with a carboxylic acid group on an aliphatic chain result in high yield.',\n            'smarts': [patterns['carboxylic_acid'], patterns['multiple_hydroxyl']],\n            'prediction': 1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers that are aromatic carboxylic acids with heteroaromatic substituents at the para position result in low yield.',\n            'smarts': [patterns['para_substituted_benzoic_acid'], patterns['heteroaromatic_para_substituent']],\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers with phenolic groups attached to a propanoic acid chain result in low yield.',\n            'smarts': [patterns['carboxylic_acid'], patterns['phenolic_propanoic_acid']],\n            'prediction': -1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers that are amino acids with bulky hydrophobic side chains (aromatic rings) result in low yield.',\n            'smarts': [patterns['carboxylic_acid'], patterns['bulky_hydrophobic_side_chain']],\n            'prediction': -1\n        }\n    ]\n    \n    # Initialize the result list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_smarts' in rule:\n                    for ex_smarts in rule['exclude_smarts']:\n                        ex_pattern = compiled_patterns[ex_smarts]\n                        if mol.HasSubstructMatch(ex_pattern):\n                            match = False\n                            break\n                    if not match:\n                        if 'inverse_prediction' in rule:\n                            row.append(rule['inverse_prediction'])\n                        else:\n                            row.append(0)\n                        continue\n                # Check required patterns\n                for smarts in rule['smarts']:\n                    if isinstance(smarts, list):\n                        sub_match = False\n                        for s in smarts:\n                            pattern = compiled_patterns[s]\n                            if mol.HasSubstructMatch(pattern):\n                                sub_match = True\n                                break\n                        if not sub_match:\n                            match = False\n                            break\n                    else:\n                        pattern = compiled_patterns[smarts]\n                        if not mol.HasSubstructMatch(pattern):\n                            match = False\n                            break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    \n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df\n"
}