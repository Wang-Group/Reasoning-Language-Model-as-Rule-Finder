{
    "prefix": "This code takes a list of SMILES strings and converts them into a feature matrix using RDKit by applying the provided natural language rules. Each rule is translated into SMARTS patterns, and for each SMILES string, the code checks whether it matches the conditions of each rule, assigning a value of 1, -1, or 0 accordingly. The output is a pandas DataFrame where each column corresponds to a rule, and each row corresponds to a SMILES string from the input list.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    import pandas as pd\n    from rdkit import Chem\n    from rdkit.Chem import AllChem\n    \n    # Define SMARTS patterns for common functional groups\n    \n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    \n    # Primary amine (-NH2)\n    primary_amine = '[NX3;H2]'\n    \n    # Aliphatic chain (up to five carbons, unbranched)\n    aliphatic_chain = '[C;!R]([C;!R])[C;!R]([C;!R])[C;!R]'\n    \n    # Aromatic rings\n    aromatic_ring = '[a]'\n    \n    # Electron-donating groups (EDGs)\n    hydroxyl_group = '[OX2H]'\n    amino_group = '[NX3;H2,H1]'  # Includes primary and secondary amines\n    methoxy_group = '[OX2][CH3]'\n    \n    # Electron-withdrawing groups (EWGs)\n    nitro_group = '[NX3](=O)=O'\n    formyl_group = '[CX3H1](=O)'\n    halogens = '[F,Cl,Br,I]'\n    fluoroalkyl_group = '[CX4]([F])[F]'  # Simplified pattern for trifluoromethyl\n    \n    # Thiol group (-SH)\n    thiol_group = '[SX2H]'\n    \n    # Nitrogen heterocycles\n    pyridine_ring = 'n1ccccc1'\n    pyrazole_ring = 'c1cnc[nH]1'\n    \n    # Conjugated ring systems with heteroatoms\n    conjugated_heterocycles = ['[O,n]=[C,c]-[C,c]=[C,c]-[C,c]=[C,c]']\n    \n    # Polyhydroxy groups (multiple hydroxyl groups)\n    polyhydroxy_group = '[OX2H][CX4H][OX2H]'\n    \n    # Rules\n    rules = [\n        {   # Rule 1\n            'number': 1,\n            'description': 'Modifiers that are amino acids with free amino (-NH2) and carboxyl (-COOH) groups directly attached to short aliphatic chains (up to five carbons) without bulky side chains or blocking groups result in a high yield.',\n            'patterns': [\n                primary_amine,\n                carboxylic_acid,\n            ],\n            'conditions': {\n                'max_chain_length': 5,\n                'no_aromatic_rings': True,\n                'no_bulky_side_chains': True,\n            },\n            'prediction': 1\n        },\n        {   # Rule 2\n            'number': 2,\n            'description': 'Modifiers that are aromatic carboxylic acids with electron-donating substituents such as amino (-NH2) or hydroxyl (-OH) groups at the para position relative to the carboxyl group result in a high yield.',\n            'patterns': [\n                carboxylic_acid,\n                aromatic_ring,\n                amino_group,  # EDG\n            ],\n            'substructure_conditions': 'para_EDG_to_COOH',\n            'prediction': 1\n        },\n        {   # Rule 3\n            'number': 3,\n            'description': 'Modifiers containing nitrogen heterocycles (e.g., pyridine or pyrazole rings) directly attached to the carboxyl group result in a high yield.',\n            'patterns': [\n                carboxylic_acid,\n                pyridine_ring,\n            ],\n            'conditions': {\n                'direct_connection': True,\n            },\n            'prediction': 1\n        },\n        {   # Rule 4\n            'number': 4,\n            'description': 'Modifiers with thiol (-SH) groups attached to short aliphatic chains near the carboxyl group result in a high yield.',\n            'patterns': [\n                carboxylic_acid,\n                thiol_group,\n            ],\n            'conditions': {\n                'short_chain_length': True,\n            },\n            'prediction': 1\n        },\n        {   # Rule 5\n            'number': 5,\n            'description': 'Modifiers that are straight-chain aliphatic carboxylic acids with moderate chain lengths (up to eight carbons) and without additional functional groups result in a high yield.',\n            'patterns': [\n                carboxylic_acid,\n            ],\n            'conditions': {\n                'max_chain_length': 8,\n                'no_additional_functional_groups': True,\n                'straight_chain': True,\n            },\n            'prediction': 1\n        },\n        {   # Rule 6\n            'number': 6,\n            'description': 'Modifiers with multiple hydroxyl (-OH) groups near the carboxyl group, such as sugar acids or polyhydroxy acids, result in a high yield.',\n            'patterns': [\n                carboxylic_acid,\n                hydroxyl_group,\n            ],\n            'conditions': {\n                'multiple_hydroxyls': True,\n            },\n            'prediction': 1\n        },\n        {   # Rule 7\n            'number': 7,\n            'description': 'Modifiers with electron-withdrawing groups (e.g., formyl (-CHO), fluoroalkyl groups) near the carboxyl group result in a low yield.',\n            'patterns': [\n                carboxylic_acid,\n                '[CX3H1](=O)',  # Formyl group\n                halogens,\n                fluoroalkyl_group,\n            ],\n            'prediction': -1\n        },\n        {   # Rule 8\n            'number': 8,\n            'description': 'Modifiers with bulky side chains, blocked amino groups (e.g., acylated amino groups), or multiple rings between functional groups and the carboxyl group result in a low yield.',\n            'patterns': [\n                carboxylic_acid,\n            ],\n            'conditions': {\n                'bulky_side_chains': True,\n                'blocked_amino_groups': True,\n                'multiple_rings': True,\n            },\n            'prediction': -1\n        },\n        {   # Rule 9\n            'number': 9,\n            'description': 'Modifiers with flexible polyether chains lacking strong coordinating groups result in a low yield.',\n            'patterns': [\n                carboxylic_acid,\n                '[OX2][CX4][CX4][OX2]',  # Ether chains\n            ],\n            'prediction': -1\n        },\n        {   # Rule 10\n            'number': 10,\n            'description': 'Modifiers with conjugated ring systems containing multiple coordinating heteroatoms (e.g., oxygen, nitrogen) result in a high yield.',\n            'patterns': [\n                carboxylic_acid,\n                conjugated_heterocycles,\n            ],\n            'prediction': 1\n        },\n        {   # Rule 11\n            'number': 11,\n            'description': 'Modifiers that are aliphatic carboxylic acids with hydroxyl (-OH) or amino (-NH2) groups distant from the carboxyl group (more than three carbons away) result in a low yield.',\n            'patterns': [\n                carboxylic_acid,\n                hydroxyl_group,\n                amino_group,\n            ],\n            'conditions': {\n                'distant_from_COOH': True,\n            },\n            'prediction': -1\n        },\n        {   # Rule 12\n            'number': 12,\n            'description': 'Modifiers with polycyclic or highly conjugated systems without effective coordinating groups result in a low yield.',\n            'patterns': [\n                carboxylic_acid,\n            ],\n            'conditions': {\n                'polycyclic_systems': True,\n                'no_coordinating_groups': True,\n            },\n            'prediction': -1\n        },\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for pattern in rule['patterns']:\n            if isinstance(pattern, list):\n                compiled_patterns.extend([Chem.MolFromSmarts(p) for p in pattern])\n            else:\n                compiled_patterns.append(Chem.MolFromSmarts(pattern))\n        rule['compiled_patterns'] = compiled_patterns\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check required patterns\n                for pat in rule['compiled_patterns']:\n                    if not mol.HasSubstructMatch(pat):\n                        match = False\n                        break\n                if not match:\n                    row.append(0)\n                    continue\n                # Additional conditions\n                conditions_met = True\n                conditions = rule.get('conditions', {})\n                # Check for aromatic rings\n                if conditions.get('no_aromatic_rings'):\n                    if mol.GetRingInfo().NumAromaticRings() > 0:\n                        conditions_met = False\n                # Check chain length\n                if 'max_chain_length' in conditions:\n                    max_chain_length = conditions['max_chain_length']\n                    chains = Chem.GetSymmSSSR(mol)\n                    longest_chain = 0\n                    for bond in mol.GetBonds():\n                        if bond.IsInRing():\n                            continue\n                        path = Chem.FindAllPathsOfLengthN(mol, max_chain_length, useBonds=True)\n                        if path:\n                            longest_chain = max(longest_chain, len(path))\n                    if longest_chain > max_chain_length:\n                        conditions_met = False\n                if not conditions_met:\n                    row.append(0)\n                    continue\n                # If all patterns match and conditions are met, append prediction\n                row.append(rule['prediction'])\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}