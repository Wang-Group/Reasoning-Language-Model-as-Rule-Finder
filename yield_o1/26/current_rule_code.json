{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. It applies defined rules based on molecular substructure patterns to predict if a molecule will result in a high yield (1), a low yield (-1), or if the rule does not apply (0). The rules are based on specific functional groups and their positions in the molecule. Each rule is represented by SMARTS patterns, and logical operations are used to combine these patterns as per the rules' descriptions.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    \n    # Primary amine group (-NH2)\n    primary_amine = '[NX3H2]'\n    \n    # Alpha carbon attached to carboxylic acid\n    alpha_amino_acid = '[NX3H2][CX4H][CX3](=O)[OX2H1]'\n    \n    # Beta carbon attached to carboxylic acid\n    beta_amino_acid = '[NX3H2][CX4H][CX4][CX3](=O)[OX2H1]'\n    \n    # Aromatic carboxylic acid with EWG or coordinating group at para position\n    aromatic_carboxylic_acid = '[c][c](=O)[OX2H1]'\n    para_substituted_aromatic = '[c]1[c][c][c][c][c]1[CX3](=O)[OX2H1]'\n    ewg_para = '[c]1[c][c][c]([$(c[F,Cl,Br,I]),$(c[NX3](=O)=O),$(c[OX2H]),$(c[NX3H2])])[c][c]1[CX3](=O)[OX2H1]'\n    \n    # Heterocyclic carboxylic acid containing nitrogen\n    heterocyclic_carboxylic_acid = '[n][c][c](=O)[OX2H1]'\n    \n    # Polyol near carboxylic acid\n    polyol = '[CX4][OX2H][CX4][OX2H][CX3](=O)[OX2H1]'\n    \n    # Thiol group (-SH) adjacent to carboxylic acid\n    thiol_adjacent = '[SX2H][CX4][CX3](=O)[OX2H1]'\n    \n    # Thiol group attached to aromatic ring\n    aromatic_thiol = '[SX2H][c]'\n    \n    # Medium-chain aliphatic carboxylic acids (6 to 8 carbons)\n    medium_chain_acid = '[CX3](=O)[OX2H1][CX4][CX4][CX4][CX4][CX4][CX4][CX4]'\n    \n    # Para-substituted EDG on aromatic carboxylic acid\n    edg_para = '[c]1[c][c][c]([$(c[CH3]),$(c[OX2][CH3]),$(c[OX2H])])[c][c]1[CX3](=O)[OX2H1]'\n    \n    # Functional groups distant from carboxyl group\n    distant_functional_group = '[CX3](=O)[OX2H1][CX4][CX4][CX4][NX3H2,OX2H]'\n    \n    # Bulky substituents near carboxyl group\n    bulky_substituent = '[CX3](=O)[OX2H1][CX4]([CX4][OX2][CX4])[CX4]'\n    \n    # Carbonyl groups adjacent to carboxylic acid\n    adjacent_carbonyl = '[CX3](=O)[CX3](=O)[OX2H1]'\n    \n    # Perfluorinated carboxylic acid\n    perfluorinated_acid = '[CX3](=O)[OX2H1][CX4]([F])[CX4]([F])[CX4]([F])'\n    \n    # Amino acids with non-coordinating side chains\n    non_coordinating_amino_acid = '[NX3H2][CX4][CX3](=O)[OX2H1]'\n    \n    # Amide linkage near carboxyl group\n    amide_near_carboxyl = '[NX3][CX3](=O)[CX3](=O)[OX2H1]'\n    \n    # Highly conjugated aromatic systems\n    conjugated_system = '[c]=[c]-[c]=[c][CX3](=O)[OX2H1]'\n    \n    # Electron-withdrawing groups with coordinating groups\n    ewg_coordinating = '[c]1[c][c][c]([$(c[F,Cl,Br,I]),$(c[NX3](=O)=O),$(c[NX3H2])])[c][c]1[CX3](=O)[OX2H1]'\n    \n    # Compile SMARTS patterns\n    patterns = {\n        'Rule 1': [alpha_amino_acid, beta_amino_acid],\n        'Rule 2': [ewg_para],\n        'Rule 3': [heterocyclic_carboxylic_acid],\n        'Rule 4': [polyol],\n        'Rule 5 High': [thiol_adjacent],\n        'Rule 5 Low': [aromatic_thiol],\n        'Rule 6': [medium_chain_acid],\n        'Rule 7': [edg_para],\n        'Rule 8': [distant_functional_group],\n        'Rule 9': [bulky_substituent],\n        'Rule 10': [adjacent_carbonyl],\n        'Rule 11': [perfluorinated_acid],\n        'Rule 12': [non_coordinating_amino_acid],\n        'Rule 13': [amide_near_carboxyl],\n        'Rule 14': [conjugated_system],\n        'Rule 15': [ewg_coordinating]\n    }\n    \n    # Predictions for each rule\n    predictions = {\n        'Rule 1': 1,\n        'Rule 2': 1,\n        'Rule 3': 1,\n        'Rule 4': 1,\n        'Rule 5 High': 1,\n        'Rule 5 Low': -1,\n        'Rule 6': 1,\n        'Rule 7': -1,\n        'Rule 8': -1,\n        'Rule 9': -1,\n        'Rule 10': -1,\n        'Rule 11': -1,\n        'Rule 12': -1,\n        'Rule 13': -1,\n        'Rule 14': -1,\n        'Rule 15': 1\n    }\n    \n    # Compile SMARTS patterns into RDKit mol objects\n    compiled_patterns = {}\n    for key, smarts_list in patterns.items():\n        compiled_patterns[key] = [Chem.MolFromSmarts(s) for s in smarts_list]\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(patterns))\n            continue\n        row = []\n        for key in patterns.keys():\n            try:\n                match = False\n                for pat in compiled_patterns[key]:\n                    if mol.HasSubstructMatch(pat):\n                        match = True\n                        break\n                if match:\n                    row.append(predictions[key])\n                else:\n                    row.append(0)\n            except Exception:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    \n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=patterns.keys())\n    return df\n"
}