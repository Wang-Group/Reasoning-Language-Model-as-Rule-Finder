{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. It processes each molecule against a set of 15 rules defined with SMARTS patterns. Each rule corresponds to a structural descriptor, and the code determines if the molecule matches the rule and whether it predicts a high or low target value. The output is a DataFrame where each column corresponds to a rule, and each row corresponds to a SMILES string from the list.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define the rules with their associated SMARTS patterns and predictions\n    # Incorporate corrections from the suggestions\n    rules = [\n        {\n            'number': 1,\n            'description': 'Rule 1: Unbranched aliphatic monocarboxylic acids with medium-length hydrocarbon chains (6\u20138 carbons) and no additional functional groups result in high yield.',\n            'prediction': 1,\n            'patterns': {\n                'must_have': ['[CX3](=O)[OX1H0]'],  # Carboxylic acid group (both protonated and deprotonated)\n                'must_not_have': ['a'],  # Must not be aromatic\n            },\n            'conditions': {\n                'chain_length': (6, 8),\n                'unbranched': True,\n                'acyclic': True,\n                'no_other_functional_groups': True,\n            },\n        },\n        {\n            'number': 2,\n            'description': 'Rule 2: Aromatic carboxylic acids with electron-withdrawing substituents at the para position typically result in high yield.',\n            'prediction': 1,\n            'patterns': {\n                'must_have': ['[cX3]1[cH][cH][cH][cH][c]1[CX3](=O)[OX1H0]'],  # Aromatic carboxylic acid\n                'ewg_para': True,\n            },\n        },\n        {\n            'number': 3,\n            'description': 'Rule 3: Heteroaromatic carboxylic acids containing accessible coordinating nitrogen atoms result in high yield.',\n            'prediction': 1,\n            'patterns': {\n                'must_have': ['[nX2]1cccc1[CX3](=O)[OX1H0]',  # Pyridine-like\n                              '[nX2]1ccccc1[CX3](=O)[OX1H0]',  # Pyridine with one N\n                              '[nX2]1cc[nX2]cc1[CX3](=O)[OX1H0]',  # Pyrazine-like\n                             ],\n            },\n        },\n        {\n            'number': 4,\n            'description': 'Rule 4: Modifiers with flexible ether chains result in low yield.',\n            'prediction': -1,\n            'patterns': {\n                'must_have': ['[OX2][CX4][CX4][OX2][CX4][CX4][OX2]'],  # Flexible ether chain\n            },\n        },\n        {\n            'number': 5,\n            'description': 'Rule 5: Amino acids with side chains capable of chelation result in high yield; those with hydrophobic side chains lacking coordinating groups result in low yield.',\n            'prediction': 1,\n            'patterns': {\n                'must_have': ['N[C@@H](C(=O)[O-])[CX4][C,N,O,S]'],  # Amino acid with chelating side chain\n            },\n        },\n        {\n            'number': 6,\n            'description': 'Rule 6: Modifiers with multiple adjacent hydroxyl groups on an aliphatic chain (polyhydroxylated acids) result in high yield.',\n            'prediction': 1,\n            'patterns': {\n                'must_have': ['[CX4H1,R0][OX2H][CX4H1,R0][OX2H][CX4H1,R0][OX2H][CX4H1,R0][OX2H][CX4H1,R0][OX2H][CX3](=O)[O-]'],  # Polyhydroxylated aliphatic chain with carboxylic acid\n            },\n        },\n        {\n            'number': 7,\n            'description': 'Rule 7: Aliphatic \u03c9-amino acids with a chain length of five carbons result in high yield; longer chain lengths result in low yield.',\n            'prediction': 1,\n            'patterns': {\n                'must_have': ['NCCCCC(=O)[O-]'],  # 5-aminopentanoic acid\n            },\n            'conditions': {\n                'chain_length': 5,\n                'omega_amino': True,\n            },\n        },\n        {\n            'number': 8,\n            'description': 'Rule 8: Modifiers that are aromatic carboxylic acids with aldehyde groups result in low yield due to potential catalyst deactivation or side reactions.',\n            'prediction': -1,\n            'patterns': {\n                'must_have': ['[c][CX3H](=O)[CX3](=O)[O-]'],  # Aromatic aldehyde carboxylic acid\n            },\n        },\n        {\n            'number': 9,\n            'description': 'Rule 9: Modifiers containing fluorinated alkyl chains result in low yield due to decreased coordination ability.',\n            'prediction': -1,\n            'patterns': {\n                'must_have': ['[CX4](F)(F)[CX4](F)(F)C(=O)[O-]'],  # Fluorinated chain with carboxylic acid\n            },\n        },\n        {\n            'number': 10,\n            'description': 'Rule 10: Modifiers that are aromatic carboxylic acids with thiol groups result in low yield; aliphatic thiol-containing modifiers may result in high yield.',\n            'prediction': -1,  # For aromatic thiols\n            'patterns': {\n                'must_have': ['[c][SX2H][CX3](=O)[O-]'],  # Aromatic thiol carboxylic acid\n            },\n        },\n        {\n            'number': 11,\n            'description': 'Rule 11: Substituted phenylalkanoic acids with a chain length of five carbons and additional coordinating groups result in high yield; shorter chain lengths or lack of coordinating groups result in low yield.',\n            'prediction': 1,\n            'patterns': {\n                'must_have': ['c1ccccc1CCCCC(=O)[O-]'],  # Phenylpentanoic acid\n            },\n        },\n        {\n            'number': 12,\n            'description': 'Rule 12: Modifiers with acylated amino groups bearing strong electron-withdrawing substituents result in low yield.',\n            'prediction': -1,\n            'patterns': {\n                'must_have': ['[NX3][CX3](=O)[CX4](F)(F)F'],  # Acylated amino with trifluoroacetyl\n            },\n        },\n        {\n            'number': 13,\n            'description': 'Rule 13: Modifiers that are \u03b1-amino acids with carboxylate side chains result in high yield due to enhanced chelation with the catalyst.',\n            'prediction': 1,\n            'patterns': {\n                'must_have': ['N[C@@H](C(=O)[O-])CC(=O)[O-]'],  # Aspartic acid\n            },\n        },\n        {\n            'number': 14,\n            'description': 'Rule 14: Modifiers containing heteroaromatic systems capable of chelation result in high yield due to enhanced interaction with the catalyst.',\n            'prediction': 1,\n            'patterns': {\n                'must_have': ['O=C1OC(=O)c2ccccc12'],  # Example of heteroaromatic system\n            },\n        },\n        {\n            'number': 15,\n            'description': 'Rule 15: Modifiers with long aliphatic chains and additional functional groups result in low yield due to steric hindrance or unfavorable interactions.',\n            'prediction': -1,\n            'patterns': {\n                'must_have': ['C(CCCCC(=O)[O-])C(=O)[O-]'],  # Long chain with additional groups\n            },\n        },\n    ]\n\n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = {}\n        for key, patterns in rule.get('patterns', {}).items():\n            if isinstance(patterns, bool):\n                compiled_patterns[key] = patterns  # For special conditions like 'ewg_para'\n            else:\n                compiled_patterns[key] = [Chem.MolFromSmarts(pat) for pat in patterns]\n        rule['patterns'] = compiled_patterns\n\n    results = []\n\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # Molecule could not be parsed\n            results.append([0]*len(rules))\n            continue\n        Chem.Kekulize(mol, clearAromaticFlags=True)\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check must-have patterns\n                for key, pats in rule['patterns'].items():\n                    if key == 'ewg_para' and pats:\n                        # Special handling for electron-withdrawing groups at para position (Rule 2)\n                        ewg_patterns = ['[F,Cl,Br,I]', '[N+](=O)[O-]', '[C](=O)[O-,OH]']  # Common EWGs\n                        para_positions = ['[cH]1ccc([a])cc1[CX3](=O)[O-,OH]', '[c]1ccc([a])cc1[CX3](=O)[O-,OH]']\n                        ewg_found = False\n                        for ewg in ewg_patterns:\n                            for para_pat in para_positions:\n                                ewg_pat = Chem.MolFromSmarts(para_pat.replace('[a]', ewg))\n                                if mol.HasSubstructMatch(ewg_pat):\n                                    ewg_found = True\n                                    break\n                            if ewg_found:\n                                break\n                        if not ewg_found:\n                            match = False\n                            break\n                    elif key == 'must_have':\n                        for pat in pats:\n                            if not mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                        if not match:\n                            break\n                    elif key == 'must_not_have':\n                        for pat in pats:\n                            if mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                        if not match:\n                            break\n                if not match:\n                    row.append(0)\n                    continue\n                # Additional conditions\n                conditions = rule.get('conditions', {})\n                # Chain length condition (Rule 1 and 7)\n                if 'chain_length' in conditions:\n                    min_length = max_length = conditions['chain_length']\n                    if isinstance(conditions['chain_length'], tuple):\n                        min_length, max_length = conditions['chain_length']\n                    longest_chain = 0\n                    for atom in mol.GetAtoms():\n                        if atom.GetAtomicNum() == 6 and atom.GetDegree() <= 4:\n                            paths = Chem.FindAtomEnvironmentOfRadiusN(mol, max_length, atom.GetIdx())\n                            chain_atoms = set()\n                            for bond_idx in paths:\n                                bond = mol.GetBondWithIdx(bond_idx)\n                                chain_atoms.update([bond.GetBeginAtomIdx(), bond.GetEndAtomIdx()])\n                            chain_length = len(chain_atoms)\n                            if chain_length > longest_chain:\n                                longest_chain = chain_length\n                    if not (min_length <= longest_chain <= max_length):\n                        match = False\n                        row.append(0)\n                        continue\n                # Unbranched condition (Rule 1)\n                if conditions.get('unbranched', False):\n                    branching = False\n                    for atom in mol.GetAtoms():\n                        if atom.GetAtomicNum() == 6 and atom.GetDegree() > 2:\n                            branching = True\n                            break\n                    if branching:\n                        match = False\n                        row.append(0)\n                        continue\n                # Acyclic condition (Rule 1)\n                if conditions.get('acyclic', False):\n                    if mol.GetRingInfo().NumRings() > 0:\n                        match = False\n                        row.append(0)\n                        continue\n                # No other functional groups condition (Rule 1)\n                if conditions.get('no_other_functional_groups', False):\n                    # Define functional groups to exclude\n                    fgs = [\n                        '[!#6;!#1]',  # Heteroatoms other than C and H\n                        '[CX3](=O)[OX2H1,O-]',  # Ester or other carboxylic acid derivatives\n                        '[#6]=[O,N,S]',  # Carbonyl, imine, thiocarbonyl\n                        '[OX2H]',  # Alcohols\n                        '[NX3;!$(N-C=O)]',  # Amines not amides\n                        '[SX2H]',  # Thiols\n                    ]\n                    for fg in fgs:\n                        fg_pat = Chem.MolFromSmarts(fg)\n                        if mol.HasSubstructMatch(fg_pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Omega amino condition (Rule 7)\n                if conditions.get('omega_amino', False):\n                    pattern = Chem.MolFromSmarts('NCCCC[CX3](=O)[O-,OH]')\n                    if not mol.HasSubstructMatch(pattern):\n                        match = False\n                        row.append(0)\n                        continue\n                # If all conditions are met\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    df = pd.DataFrame(results, columns=[f\"Rule {rule['number']}\" for rule in rules])\n    return df\n"
}