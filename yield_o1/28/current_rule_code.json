{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit. It applies a set of 15 rules defined in natural language, which are translated into SMARTS patterns for substructure matching. Each rule corresponds to a column in the output DataFrame, with values of 1, 0, or -1 depending on whether the rule matches and predicts a high or low target value.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and features\n    primary_amino_group = '[NX3;H2]'\n    carboxylic_acid_group = '[CX3](=O)[OX1H0-,OX2H1]'\n    amino_acid = '[NX3;H2][CX4](C(=O)[OX1H0-,OX2H1])[#6]'\n    dicarboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1][CX4][CX3](=O)[OX1H0-,OX2H1]'\n    aromatic_carboxylic_acid = 'c[C](=O)[OX1H0-,OX2H1]'\n    electron_donating_groups = ['[NX3;H2,H1][c]', '[OX2H][c]', '[c][CH2][Br]']\n    aliphatic_chain = '[CH2]' * 5\n    thiol_group = '[SX2H]'\n    hydroxyl_group = '[OX2H]'\n    polyhydroxylated_chain = 'C(' + 'O)C('.join(['O'] * 3) + 'O)'  # Chain with multiple hydroxyls\n    heterocyclic_nitrogen = '[n][c][c][c][c][c]'\n    heteroaromatic_amino_acid = '[NX3;H2][CX4][CX3](=O)[OX1H0-,OX2H1][CX4][c][n]'\n    electron_withdrawing_groups = ['[C](=O)[OX1H0-,OX2H1]', '[NX3+](=O)[O-]', '[F]', '[Cl]', '[Br]', '[I]', '[CX4][F][F][F]']\n    blocked_amino_group = '[NX3][C](=O)'\n    internal_carbonyl = '[#6][CX3](=O)[#6]'\n    ortho_substitution = 'c1cc([#6])[c]([#6])cc1C(=O)[OX1H0-,OX2H1]'\n    bulky_group = '[c][C](C)C'\n    # Define the rules\n    rules = [\n        {\n            'number': 1,\n            'description': 'High Yield: Modifiers that are \u03b1-amino dicarboxylic acids (having an amino group and two carboxylic acid groups on adjacent carbons).',\n            'patterns': [\n                [amino_acid],\n                [dicarboxylic_acid]\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'High Yield: Modifiers that are aromatic carboxylic acids substituted at the para position with electron-donating groups capable of metal coordination.',\n            'patterns': [\n                [aromatic_carboxylic_acid],\n                electron_donating_groups\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'High Yield: Modifiers that are aliphatic carboxylic acids with unbranched chains of medium length (5-8 carbons) and lacking additional polar substituents.',\n            'patterns': [\n                [carboxylic_acid_group],\n                [aliphatic_chain]\n            ],\n            'exclude_patterns': [\n                [hydroxyl_group, thiol_group, primary_amino_group]\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'High Yield: Modifiers containing both a thiol (-SH) group and a carboxylic acid on a short aliphatic chain.',\n            'patterns': [\n                [thiol_group],\n                [carboxylic_acid_group]\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'High Yield: Modifiers that are polyhydroxylated carboxylic acids.',\n            'patterns': [\n                [polyhydroxylated_chain],\n                [carboxylic_acid_group]\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'High Yield: Modifiers that are heterocyclic carboxylic acids containing nitrogen atoms in the ring adjacent to the carboxylate group.',\n            'patterns': [\n                [heterocyclic_nitrogen],\n                [carboxylic_acid_group]\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 7,\n            'description': 'High Yield: Modifiers that are amino acids with heteroaromatic side chains capable of metal coordination.',\n            'patterns': [\n                [heteroaromatic_amino_acid]\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 8,\n            'description': 'Low Yield: Modifiers with electron-withdrawing groups near the carboxylate.',\n            'patterns': [\n                electron_withdrawing_groups,\n                [carboxylic_acid_group]\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'High Yield: Modifiers that are aromatic carboxylic acids linked via flexible aliphatic chains to additional coordinating groups with optimal chain length.',\n            'patterns': [\n                [aromatic_carboxylic_acid],\n                [aliphatic_chain],\n                electron_donating_groups\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 10,\n            'description': 'Low Yield: Modifiers that are N-acylated amino acids or have blocked amino groups.',\n            'patterns': [\n                [blocked_amino_group],\n                [carboxylic_acid_group]\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Low Yield: Modifiers with long, flexible ether chains adjacent to the carboxylate group.',\n            'patterns': [\n                ['[CX4][OX2][CX4][OX2][CX4][OX2][CX4]'],  # Long ether chain\n                [carboxylic_acid_group]\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Low Yield: Modifiers containing carbonyl groups within the aliphatic chain near the carboxylate.',\n            'patterns': [\n                [internal_carbonyl],\n                [carboxylic_acid_group]\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Low Yield: Modifiers with polar substituents on long aliphatic chains.',\n            'patterns': [\n                [hydroxyl_group, primary_amino_group],\n                [aliphatic_chain],\n                [carboxylic_acid_group]\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 14,\n            'description': 'Low Yield: Modifiers that are aromatic carboxylic acids substituted at positions that hinder coordination (e.g., ortho-substitution).',\n            'patterns': [\n                [ortho_substitution]\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 15,\n            'description': 'Low Yield: Modifiers with bulky electron-donating groups that do not effectively participate in coordination.',\n            'patterns': [\n                [bulky_group],\n                [carboxylic_acid_group]\n            ],\n            'prediction': -1\n        }\n    ]\n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for group in rule.get('patterns', []):\n            compiled_group = [Chem.MolFromSmarts(p) for p in group]\n            compiled_patterns.append(compiled_group)\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for group in rule['exclude_patterns']:\n                compiled_group = [Chem.MolFromSmarts(p) for p in group]\n                compiled_excludes.append(compiled_group)\n            rule['compiled_exclude_patterns'] = compiled_excludes\n    # Initialize results list\n    results = []\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for group in rule['compiled_exclude_patterns']:\n                        for pat in group:\n                            if mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                        if not match:\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for compiled_group in rule['compiled_patterns']:\n                    group_match = False\n                    for pat in compiled_group:\n                        matches = mol.GetSubstructMatches(pat)\n                        if matches:\n                            # If a count threshold is specified for this pattern\n                            if 'count_thresholds' in rule and pat.GetSmarts() in rule['count_thresholds']:\n                                threshold = rule['count_thresholds'][pat.GetSmarts()]\n                                if len(matches) >= threshold:\n                                    group_match = True\n                                    break\n                            else:\n                                group_match = True\n                                break\n                    if not group_match:\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}