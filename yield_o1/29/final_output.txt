
    Target Name: yield
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    Based on the analysis of the provided dataset and considering the underlying physico-chemical properties of the modifiers, the following rules have been generated to describe the relationship between molecular modifiers and the yield of the reaction:

**Start of Rules**

- **Rule 1**: Modifiers that are **amino acids with additional carboxylic acid side chains**, such as **L-aspartic acid** and **L-glutamic acid**, result in a **high yield**. The extra carboxyl groups enhance coordination with the metal centers, improving catalyst performance.

- **Rule 2**: Modifiers that are **aliphatic carboxylic acids without polar substituents** (e.g., **octanoic acid**) yield a **high yield**. These nonpolar chains favor hydrophobic interactions with the catalyst. In contrast, similar aliphatic acids with **polar substituents** like hydroxyl or amino groups (e.g., **7-hydroxyheptanoic acid**, **7-aminoheptanoic acid**) result in a **low yield** due to potential interference with catalyst interactions.

- **Rule 3**: Modifiers containing **heteroaromatic carboxylic acids** with nitrogen heteroatoms (e.g., **pyridine-3-carboxylic acid**, **1H-pyrazole-4-carboxylic acid**, **2-oxo-1H-pyridine-4-carboxylic acid**) result in a **high yield**. The nitrogen atoms facilitate coordination with metal centers, enhancing catalyst stability.

- **Rule 4**: Modifiers that are **para-substituted benzoic acids** with **electron-donating amino groups** or **electron-withdrawing nitro or bromomethyl groups** (e.g., **4-aminobenzoic acid**, **4-nitrobenzoic acid**, **4-(bromomethyl)benzoic acid**) result in a **high yield**. These substituents modify the electronic properties of the aromatic ring to favor effective catalyst interaction.

- **Rule 5**: Modifiers that are **para-substituted benzoic acids** with **small alkyl groups** like methyl or with **aldehyde groups** (e.g., **4-methylbenzoic acid**, **4-formylbenzoic acid**) result in a **low yield**. Such substituents do not contribute to enhanced coordination with the catalyst and may hinder catalytic efficiency.

- **Rule 6**: Modifiers containing **aldehyde functional groups** (e.g., **4-formylbenzoic acid**, **5-formyl-2-hydroxybenzoic acid**) result in a **low yield**. Aldehyde groups can form irreversible bonds with metal centers, potentially deactivating the catalyst.

- **Rule 7**: Modifiers with **perfluorinated alkyl chains** (e.g., **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**) result in a **low yield**. The strong electron-withdrawing effect of fluorine atoms reduces the ligand's ability to donate electron density, weakening coordination with the metal center.

- **Rule 8**: Modifiers featuring **aliphatic thiol groups** (e.g., **3-sulfanylpropanoic acid**) result in a **high yield**, while those with **aromatic thiol groups** (e.g., **4-sulfanylbenzoic acid**) result in a **low yield**. Aliphatic thiols can effectively coordinate with metal centers, whereas aromatic thiols may form less favorable interactions.

- **Rule 9**: Modifiers containing **long ether chains** or **polyethylene glycol (PEG) moieties** (e.g., **2-[2-(2-methoxyethoxy)ethoxy]acetic acid**) result in a **low yield**. The flexible ether linkages may hinder effective interaction with the catalyst due to steric hindrance and reduced coordination ability.

- **Rule 10**: Modifiers that are **amino acids with hydrophobic aromatic side chains** such as **L-phenylalanine** result in a **low yield**, whereas those with **heteroaromatic side chains** like **L-tryptophan** (containing an indole ring) result in a **high yield**. The presence of heteroatoms in the side chain enhances coordination with metal centers, improving catalytic performance.

**End of Rules**---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 8.1,Rule 9,Rule 10,Rule 10.1
0,1,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0
0,0,1,0,0,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,-1,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0
0,0,1,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,-1,0
0,1,0,0,0,0,-1,0,0,0,0,0
0,0,1,0,0,0,0,0,0,0,0,0
0,0,1,0,0,0,0,0,0,0,0,0
0,0,0,0,-1,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,0,0,0,0
0,0,0,0,-1,-1,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0
0,0,1,0,0,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0
0,0,1,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0
0,1,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.7714285714285715; Test Accuracy: 0.0
    Train Support: 0.07755102040816327; Test Support: 0.0
    Train Confidence: 0.8476190476190476; Test Confidence: 0.42857142857142855
    Train Lift: 1.7053376906318083; Test Lift: NONE
    Train Leverage: 0.02588921282798834; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    # Define SMARTS patterns for functional groups and substructures
    carboxylic_acid = '[CX3](=O)[OX2H1]'
    carboxylate_anion = '[CX3](=O)[O-]'
    amine_primary = '[NX3;H2]'  # Primary amine
    amine_secondary = '[NX3;H1][#6]'  # Secondary amine
    amine_tertiary = '[NX3;H0]([#6])[#6]'  # Tertiary amine
    thiol_aliphatic = '[SX2H][!#6;!a]'
    thiol_aromatic = '[SX2H][c]'
    ether_linkage = '[#6][OX2][#6]'
    heteroaromatic_nitrogen = '[n]'
    aromatic_ring = 'c1ccccc1'
    para_substituted_benzoic_acid = 'c1cc(ccc1C(=O)O)'  # Placeholder for para-substitution
    aldehyde_group = '[CX3H1](=O)[#6]'
    perfluoro_alkyl_chain = '[CX4]([F])[F]'
    long_ether_chain = '[OX2][CX4][OX2][CX4][OX2][CX4]'  # PEG-like structure
    amino_acid_backbone = '[NX3;H2][CX4H]([#6])[CX3](=O)[OX1,H1]'
    aromatic_thiol = '[SX2H][c]'
    indole_ring = 'c1cc2c(c1)cc[nH]2'  # Indole structure
    # Compile patterns
    patterns = {
        'carboxylic_acid': Chem.MolFromSmarts(carboxylic_acid),
        'carboxylate_anion': Chem.MolFromSmarts(carboxylate_anion),
        'amine_primary': Chem.MolFromSmarts(amine_primary),
        'amine_secondary': Chem.MolFromSmarts(amine_secondary),
        'thiol_aliphatic': Chem.MolFromSmarts(thiol_aliphatic),
        'thiol_aromatic': Chem.MolFromSmarts(thiol_aromatic),
        'ether_linkage': Chem.MolFromSmarts(ether_linkage),
        'heteroaromatic_nitrogen': Chem.MolFromSmarts(heteroaromatic_nitrogen),
        'aromatic_ring': Chem.MolFromSmarts(aromatic_ring),
        'aldehyde_group': Chem.MolFromSmarts(aldehyde_group),
        'perfluoro_alkyl_chain': Chem.MolFromSmarts(perfluoro_alkyl_chain),
        'long_ether_chain': Chem.MolFromSmarts(long_ether_chain),
        'amino_acid_backbone': Chem.MolFromSmarts(amino_acid_backbone),
        'aromatic_thiol': Chem.MolFromSmarts(aromatic_thiol),
        'indole_ring': Chem.MolFromSmarts(indole_ring)
    }
    # Define the rules with their associated patterns and predictions
    rules = [
        {
            'number': 1,
            'description': 'High yield: Amino acids with additional carboxylic acid side chains.',
            'patterns': [
                patterns['amino_acid_backbone'],  # Amino acid backbone
                patterns['carboxylic_acid']  # Additional carboxylic acid
            ],
            'count_threshold': {'carboxylic_acid': 2},  # At least two carboxylic acids
            'prediction': 1
        },
        {
            'number': 2,
            'description': 'High yield: Aliphatic carboxylic acids without polar substituents.',
            'patterns': [
                patterns['carboxylic_acid']
            ],
            'exclude_patterns': [
                patterns['amine_primary'],
                patterns['amine_secondary'],
                patterns['ether_linkage'],
                patterns['thiol_aliphatic'],
                patterns['thiol_aromatic'],
                patterns['heteroaromatic_nitrogen'],
                patterns['aldehyde_group']
            ],
            'prediction': 1
        },
        {
            'number': 3,
            'description': 'High yield: Heteroaromatic carboxylic acids with nitrogen heteroatoms.',
            'patterns': [
                patterns['heteroaromatic_nitrogen'],
                patterns['carboxylic_acid']
            ],
            'prediction': 1
        },
        {
            'number': 4,
            'description': 'High yield: Para-substituted benzoic acids with amino, nitro, or bromomethyl groups.',
            'patterns': [
                Chem.MolFromSmarts('c1cc(ccc1C(=O)O)[NX3;H2]'),  # Para-amino
                Chem.MolFromSmarts('c1cc(ccc1C(=O)O)[NX3](=O)=O'),  # Para-nitro
                Chem.MolFromSmarts('c1cc(ccc1C(=O)O)CBr')  # Para-bromomethyl
            ],
            'prediction': 1
        },
        {
            'number': 5,
            'description': 'Low yield: Para-substituted benzoic acids with small alkyl or aldehyde groups.',
            'patterns': [
                Chem.MolFromSmarts('c1cc(ccc1C(=O)O)C'),  # Para-methyl
                Chem.MolFromSmarts('c1cc(ccc1C(=O)O)C=O')  # Para-aldehyde
            ],
            'prediction': -1
        },
        {
            'number': 6,
            'description': 'Low yield: Modifiers containing aldehyde functional groups.',
            'patterns': [
                patterns['aldehyde_group']
            ],
            'prediction': -1
        },
        {
            'number': 7,
            'description': 'Low yield: Modifiers with perfluorinated alkyl chains.',
            'patterns': [
                patterns['perfluoro_alkyl_chain']
            ],
            'prediction': -1
        },
        {
            'number': 8,
            'description': 'High or Low yield based on thiol group location.',
            'patterns': [
                patterns['thiol_aliphatic']
            ],
            'prediction': 1
        },
        {
            'number': 8.1,
            'description': 'Low yield: Modifiers with aromatic thiol groups.',
            'patterns': [
                patterns['thiol_aromatic']
            ],
            'prediction': -1
        },
        {
            'number': 9,
            'description': 'Low yield: Modifiers containing long ether chains or PEG moieties.',
            'patterns': [
                patterns['long_ether_chain']
            ],
            'prediction': -1
        },
        {
            'number': 10,
            'description': 'Yield based on amino acid side chains.',
            'patterns': [
                patterns['amino_acid_backbone'],
                patterns['aromatic_ring']
            ],
            'exclude_patterns': [
                patterns['heteroaromatic_nitrogen'],
                patterns['indole_ring']
            ],
            'prediction': -1
        },
        {
            'number': 10.1,
            'description': 'High yield: Amino acids with heteroaromatic side chains like tryptophan.',
            'patterns': [
                patterns['amino_acid_backbone'],
                patterns['indole_ring']
            ],
            'prediction': 1
        }
    ]
    # Initialize results list
    results = []
    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*len(rules))
            continue
        row = []
        for rule in rules:
            try:
                match = True
                # Check exclude patterns if any
                if 'exclude_patterns' in rule:
                    for pat in rule['exclude_patterns']:
                        if mol.HasSubstructMatch(pat):
                            match = False
                            break
                    if not match:
                        row.append(0)
                        continue
                # Check required patterns
                for pat in rule['patterns']:
                    if not mol.HasSubstructMatch(pat):
                        match = False
                        break
                # Check count thresholds if any
                if match and 'count_threshold' in rule:
                    for key, threshold in rule['count_threshold'].items():
                        pattern = patterns[key]
                        matches = mol.GetSubstructMatches(pattern)
                        if len(matches) < threshold:
                            match = False
                            break
                if match:
                    row.append(rule['prediction'])
                else:
                    row.append(0)
            except Exception:
                # In case of any error, append 0
                row.append(0)
        results.append(row)
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])
    return df

--------------------------------------------------
    Target Name: yield
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

1. **Rule 1**: **Amino acids with acidic side chains** containing additional carboxylic acid groups (e.g., **L-aspartic acid**, **L-glutamic acid**) result in a **high yield**. The extra carboxylate groups enhance coordination with metal centers, improving catalyst performance.

2. **Rule 2**: **Aromatic carboxylic acids** with **strong electron-withdrawing groups** such as **nitro** or **bromomethyl** substituents (e.g., **4-nitrobenzoic acid**, **4-(bromomethyl)benzoic acid**) result in a **high yield**. These substituents increase the acidity of the carboxylic acid, enhancing coordination with the catalyst.

3. **Rule 3**: **Aromatic carboxylic acids** with **electron-donating amino groups** (e.g., **4-aminobenzoic acid**) result in a **high yield**. The amino group can coordinate with metal centers, strengthening the interaction with the catalyst.

4. **Rule 4**: **Aromatic carboxylic acids** with **aldehyde (formyl) substituents** (e.g., **4-formylbenzoic acid**, **5-formyl-2-hydroxybenzoic acid**) result in a **low yield**. The aldehyde group can bind to metal centers, potentially deactivating the catalyst.

5. **Rule 5**: **Aliphatic carboxylic acids** with **long hydrocarbon chains without polar substituents** (e.g., **octanoic acid**) result in a **high yield**. Nonpolar chains may favor hydrophobic interactions with the catalyst, enhancing performance.

6. **Rule 6**: **Aliphatic carboxylic acids** with **polar substituents** such as **hydroxyl** or **amino groups** on the chain (e.g., **7-hydroxyheptanoic acid**, **7-aminoheptanoic acid**, **8-aminooctanoic acid**) result in a **low yield**. These polar groups may interfere with catalyst interactions or introduce steric hindrance.

7. **Rule 7**: **Modifiers containing nitrogen heteroaromatic rings**, such as **pyridine carboxylic acids** (e.g., **pyridine-3-carboxylic acid**, **2-oxo-1H-pyridine-4-carboxylic acid**, **1H-pyrazole-4-carboxylic acid**), result in a **high yield**. The nitrogen atoms enhance coordination with metal centers, improving catalyst stability.

8. **Rule 8**: **Amino acids with heteroaromatic side chains** (e.g., **L-tryptophan**) result in a **high yield**. The heterocyclic side chain can coordinate with metal centers, enhancing catalyst performance.

9. **Rule 9**: **Amino acids with hydrophobic aromatic side chains lacking heteroatoms** (e.g., **L-phenylalanine**) result in a **low yield**. The absence of coordinating heteroatoms reduces effective interaction with the catalyst.

10. **Rule 10**: **Modifiers with aliphatic thiol groups** (e.g., **3-sulfanylpropanoic acid**) result in a **high yield**. The thiol group effectively coordinates with metal centers due to the high nucleophilicity of sulfur.

11. **Rule 11**: **Modifiers with aromatic thiol groups** (e.g., **4-sulfanylbenzoic acid**) result in a **low yield**. The aromatic environment delocalizes the sulfur's lone pair, reducing its ability to coordinate with the metal center.

12. **Rule 12**: **Modifiers with perfluorinated alkyl chains** or **fluorinated functional groups** (e.g., **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**) result in a **low yield**. The strong electron-withdrawing effect of fluorine reduces the ligand's ability to donate electron density, weakening coordination with the metal center.

13. **Rule 13**: **Modifiers containing long ether chains** or **polyethylene glycol (PEG) moieties** (e.g., **2-[2-(2-methoxyethoxy)ethoxy]acetic acid**) result in a **low yield**. The flexible ether linkages introduce steric hindrance and reduce the overall coordination ability of the ligand.

14. **Rule 14**: **Modifiers with ketone functional groups adjacent to aromatic rings** (e.g., **4-(3,4-dimethoxyphenyl)-4-oxobutanoic acid**) result in a **high yield**. The ketone group can participate in coordination, enhancing catalyst activity.

15. **Rule 15**: **Modifiers with hydroxyl groups attached to aromatic rings** (e.g., **5-(4-hydroxyphenyl)pentanoic acid**) result in a **high yield**. The hydroxyl group can enhance coordination with the catalyst. In contrast, **hydroxyl groups on aliphatic chains** (e.g., **7-hydroxyheptanoic acid**) result in a **low yield**, possibly due to decreased coordination efficiency.

**End of Rules**---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10,Rule 11,Rule 12,Rule 13,Rule 14,Rule 15,Rule 16
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0
0,0,1,0,0,-1,0,1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,-1
0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,-1
0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0
0,0,0,0,0,-1,1,1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
0,0,0,-1,0,0,0,0,0,0,0,0,0,0,1,0
0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,0
0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,-1
0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.7714285714285715; Test Accuracy: 0.0
    Train Support: 0.05194805194805195; Test Support: 0.0
    Train Confidence: 0.7954545454545454; Test Confidence: 0.5
    Train Lift: 1.586576549811844; Test Lift: NONE
    Train Leverage: 0.009499072356215211; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    # Define SMARTS patterns for functional groups and substructures
    # Carboxylic acid group (-COOH)
    carboxylic_acid = '[CX3](=O)[OX2H1,O-]'
    
    # Amino group (-NH2)
    amino_group = '[NX3H2]'
    
    # Aldehyde group (-CHO)
    aldehyde_group = '[CX3H1](=O)'
    
    # Aromatic ring
    aromatic_ring = '[a]'
    
    # Nitro group
    nitro_group = '[NX3+(=O)[O-]]'
    
    # Bromomethyl group attached to aromatic ring
    bromomethyl_group = '[c][CH2Br]'
    
    # Amino group attached to aromatic ring
    aromatic_amino_group = '[c][NX3H2]'
    
    # Thiol group (-SH)
    thiol_group = '[SX2H]'
    
    # Aliphatic thiol group
    aliphatic_thiol_group = '[CX4][SX2H]'
    
    # Aromatic thiol group
    aromatic_thiol_group = '[c][SX2H]'
    
    # Hydroxyl group (-OH)
    hydroxyl_group = '[OX2H]'
    
    # Hydroxyl group attached to aromatic ring
    aromatic_hydroxyl_group = '[c][OX2H]'
    
    # Hydroxyl group on aliphatic chain
    aliphatic_hydroxyl_group = '[CX4][OX2H]'
    
    # Ketone group adjacent to aromatic ring
    aromatic_ketone_group = '[c][CX3](=O)[#6]'
    
    # Nitrogen heteroaromatic rings
    nitrogen_heteroaromatic_ring = '[n]1cccc1'
    
    # Heteroaromatic rings
    heteroaromatic_ring = '[a;!C]'
    
    # Aliphatic chain of at least 5 carbons
    long_aliphatic_chain = '[C][C][C][C][C]'
    
    # Fluorinated carbons
    fluorinated_carbon = '[CX4;H0](F)(F)(F)'
    
    # Ether linkage
    ether_linkage = '[#6][OX2][#6]'
    
    # PEG chain (multiple ether linkages)
    peg_chain = '([#6][OX2])3'  # At least three repeats
    
    # Define the rules with their associated patterns and predictions
    rules = [
        {
            'number': 1,
            'description': 'Rule 1: Amino acids with acidic side chains containing additional carboxylic acid groups result in high yield.',
            'patterns': [
                [carboxylic_acid],  # Carboxylic acid group
                [amino_group],       # Amino group
            ],
            'count_threshold': {carboxylic_acid: 2},  # At least 2 carboxylic acid groups
            'prediction': 1
        },
        {
            'number': 2,
            'description': 'Rule 2: Aromatic carboxylic acids with strong electron-withdrawing groups such as nitro or bromomethyl substituents result in high yield.',
            'patterns': [
                [carboxylic_acid],
                [aromatic_ring],
                [nitro_group, bromomethyl_group],  # EWG substituents
            ],
            'prediction': 1
        },
        {
            'number': 3,
            'description': 'Rule 3: Aromatic carboxylic acids with electron-donating amino groups result in high yield.',
            'patterns': [
                [carboxylic_acid],
                [aromatic_amino_group],
            ],
            'prediction': 1
        },
        {
            'number': 4,
            'description': 'Rule 4: Aromatic carboxylic acids with aldehyde substituents result in low yield.',
            'patterns': [
                [carboxylic_acid],
                [aldehyde_group],
            ],
            'prediction': -1
        },
        {
            'number': 5,
            'description': 'Rule 5: Aliphatic carboxylic acids with long hydrocarbon chains without polar substituents result in high yield.',
            'patterns': [
                [carboxylic_acid],
                [long_aliphatic_chain],
            ],
            'exclude_patterns': [
                [hydroxyl_group, amino_group, thiol_group, ether_linkage],  # Polar substituents
            ],
            'prediction': 1
        },
        {
            'number': 6,
            'description': 'Rule 6: Aliphatic carboxylic acids with polar substituents such as hydroxyl or amino groups on the chain result in low yield.',
            'patterns': [
                [carboxylic_acid],
                [aliphatic_hydroxyl_group, amino_group],
            ],
            'prediction': -1
        },
        {
            'number': 7,
            'description': 'Rule 7: Modifiers containing nitrogen heteroaromatic rings, such as pyridine carboxylic acids, result in high yield.',
            'patterns': [
                [nitrogen_heteroaromatic_ring],
                [carboxylic_acid],
            ],
            'prediction': 1
        },
        {
            'number':8,
            'description':'Rule 8: Amino acids with heteroaromatic side chains result in high yield.',
            'patterns':[
                [carboxylic_acid],
                [amino_group],
                [heteroaromatic_ring],
            ],
            'prediction':1
        },
        {
            'number':9,
            'description':'Rule 9: Amino acids with hydrophobic aromatic side chains lacking heteroatoms result in low yield.',
            'patterns':[
                [carboxylic_acid],
                [amino_group],
                ['c1ccccc1'],  # Benzene ring
            ],
            'exclude_patterns':[
                [heteroaromatic_ring],
            ],
            'prediction':-1
        },
        {
            'number':10,
            'description':'Rule 10: Modifiers with aliphatic thiol groups result in high yield.',
            'patterns':[
                [aliphatic_thiol_group],
                [carboxylic_acid],
            ],
            'exclude_patterns':[
                [aromatic_ring],
            ],
            'prediction':1
        },
        {
            'number':11,
            'description':'Rule 11: Modifiers with aromatic thiol groups result in low yield.',
            'patterns':[
                [aromatic_thiol_group],
                [carboxylic_acid],
            ],
            'prediction':-1
        },
        {
            'number':12,
            'description':'Rule 12: Modifiers with perfluorinated alkyl chains or fluorinated functional groups result in low yield.',
            'patterns':[
                [fluorinated_carbon],
            ],
            'prediction':-1
        },
        {
            'number':13,
            'description':'Rule 13: Modifiers containing long ether chains or polyethylene glycol (PEG) moieties result in low yield.',
            'patterns':[
                [peg_chain],
            ],
            'prediction':-1
        },
        {
            'number':14,
            'description':'Rule 14: Modifiers with ketone functional groups adjacent to aromatic rings result in high yield.',
            'patterns':[
                [aromatic_ketone_group],
                [carboxylic_acid],
            ],
            'prediction':1
        },
        {
            'number':15,
            'description':'Rule 15: Modifiers with hydroxyl groups attached to aromatic rings result in high yield.',
            'patterns':[
                [aromatic_hydroxyl_group],
                [carboxylic_acid],
            ],
            'prediction':1
        },
        {
            'number':16,
            'description':'Rule 15b: Modifiers with hydroxyl groups on aliphatic chains result in low yield.',
            'patterns':[
                [aliphatic_hydroxyl_group],
                [carboxylic_acid],
            ],
            'exclude_patterns':[
                [aromatic_ring],
            ],
            'prediction':-1
        },
    ]
    
    # Compile SMARTS patterns
    for rule in rules:
        compiled_patterns = []
        for group in rule.get('patterns', []):
            compiled_group = [Chem.MolFromSmarts(p) for p in group]
            compiled_patterns.append(compiled_group)
        rule['compiled_patterns'] = compiled_patterns
        # Compile exclude patterns if any
        if 'exclude_patterns' in rule:
            compiled_excludes = []
            for group in rule['exclude_patterns']:
                compiled_group = [Chem.MolFromSmarts(p) for p in group]
                compiled_excludes.append(compiled_group)
            rule['compiled_exclude_patterns'] = compiled_excludes
    
    # Initialize results list
    results = []
    
    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*len(rules))
            continue
        row = []
        for rule in rules:
            try:
                match = True
                # Check exclude patterns if any
                if 'exclude_patterns' in rule:
                    for group in rule['compiled_exclude_patterns']:
                        for pat in group:
                            if mol.HasSubstructMatch(pat):
                                match = False
                                break
                        if not match:
                            break
                    if not match:
                        row.append(0)
                        continue
                # Check required patterns
                for compiled_group in rule['compiled_patterns']:
                    group_match = False
                    for pat in compiled_group:
                        matches = mol.GetSubstructMatches(pat)
                        if matches:
                            # If a count threshold is specified for this pattern
                            if 'count_threshold' in rule and pat.GetSmarts() in rule['count_threshold']:
                                threshold = rule['count_threshold'][pat.GetSmarts()]
                                if len(matches) >= threshold:
                                    group_match = True
                                    break
                            else:
                                group_match = True
                                break
                    if not group_match:
                        match = False
                        break
                if match:
                    row.append(rule['prediction'])
                else:
                    row.append(0)
            except Exception as e:
                # In case of any error, append 0 and optionally log the error
                # print(f"Error processing rule {rule['number']} for SMILES {smi}: {e}")
                row.append(0)
        results.append(row)
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])
    return df

--------------------------------------------------
    Target Name: yield
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

1. **Rule 1**: **Modifiers that are amino acids with acidic side chains**, specifically those containing **additional carboxylic acid groups** adjacent to the amino group (e.g., **(2S)-2-aminobutanedioic acid** (aspartic acid), **(2S)-2-aminopentanedioic acid** (glutamic acid)), result in a **high yield**. The extra carboxylate enhances coordination with the metal center through bidentate chelation, improving catalyst activity.

2. **Rule 2**: **Aromatic carboxylic acids with strong electron-withdrawing substituents** on the ring, such as **nitro**, **bromo**, or **carbonyl** groups (e.g., **4-nitrobenzoic acid**, **4-(bromomethyl)benzoic acid**, **1,3-dioxo-2-benzofuran-5-carboxylic acid**), result in a **high yield**. Electron-withdrawing groups increase the acidity of the carboxyl group, enhancing its ability to coordinate with the metal catalyst.

3. **Rule 3**: **Aromatic carboxylic acids with electron-donating substituents**, such as **methyl**, **hydroxyl**, or **methoxy** groups (e.g., **4-methylbenzoic acid**, **3-(4-hydroxyphenyl)propanoic acid**, **4-(3,4-dimethoxyphenyl)-4-oxobutanoic acid**), result in a **low yield**. Electron-donating groups decrease carboxyl acidity and hinder effective coordination with the metal center.

4. **Rule 4**: **Modifiers containing heteroaromatic rings with nitrogen atoms capable of chelation**, such as **pyridine** or **pyrazole** carboxylic acids (e.g., **pyridine-3-carboxylic acid**, **1H-pyrazole-4-carboxylic acid**), result in a **high yield**. Nitrogen atoms act as additional coordination sites, stabilizing the metal center and enhancing catalysis.

5. **Rule 5**: **Aliphatic carboxylic acids with an amino group on a short carbon chain**, specifically within three to five carbons (e.g., **5-aminopentanoic acid**, **4-aminobenzoic acid**), result in a **high yield**. The proximity of amino and carboxyl groups allows for effective bidentate coordination with the catalyst.

6. **Rule 6**: **Modifiers that are aliphatic carboxylic acids with long hydrocarbon chains lacking polar substituents**, such as **octanoic acid**, result in a **high yield**. The hydrophobic chains may promote favorable interactions with the catalyst surface, enhancing reactivity.

7. **Rule 7**: **Aliphatic carboxylic acids with polar substituents distant from the carboxyl group**, including **hydroxyl** or **amino** groups on chains longer than five carbons (e.g., **7-hydroxyheptanoic acid**, **7-aminoheptanoic acid**), result in a **low yield**. The distant polar groups may introduce steric hindrance or disrupt optimal binding to the metal center.

8. **Rule 8**: **Modifiers containing aliphatic thiol groups adjacent to the carboxyl group**, such as **3-sulfanylpropanoic acid**, result in a **high yield**. The thiol group provides strong coordination with the metal due to the high nucleophilicity of sulfur, enhancing catalyst performance.

9. **Rule 9**: **Aromatic carboxylic acids with aldehyde (formyl) substituents on the ring**, like **4-formylbenzoic acid** and **5-formyl-2-hydroxybenzoic acid**, result in a **low yield**. Aldehyde groups may interfere with metal coordination or participate in side reactions, reducing catalyst efficiency.

10. **Rule 10**: **Modifiers with perfluorinated alkyl chains** or multiple **fluorine atoms** on the alkyl side chain (e.g., **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**), result in a **low yield**. The strong electron-withdrawing effect of fluorines decreases electron density on coordinating atoms, weakening interaction with the metal center.

11. **Rule 11**: **Amino acids with non-coordinating, hydrophobic side chains lacking additional heteroatoms**, such as **(2S)-2-amino-3-phenylpropanoic acid** (phenylalanine), result in a **low yield**. The absence of side-chain coordinating groups reduces ligand-metal interactions necessary for effective catalysis.

12. **Rule 12**: **Modifiers containing long polyether chains** or **polyethylene glycol (PEG) moieties**, such as **2-[2-(2-methoxyethoxy)ethoxy]acetic acid**, result in a **low yield**. The flexible ether linkages and increased steric bulk hinder proper coordination with the metal catalyst.

13. **Rule 13**: **Modifiers with multiple hydroxyl groups on short aliphatic chains**, like **(2R,3S,4R,5R)-2,3,4,5,6-pentahydroxyhexanoic acid** (gluconic acid), result in a **high yield**. Multiple hydroxyl groups increase solubility and offer additional coordination sites, enhancing interaction with the catalyst.

14. **Rule 14**: **Aromatic carboxylic acids with hydroxyl groups capable of intramolecular hydrogen bonding**, such as **2-[(4-hydroxybenzoyl)amino]acetic acid**, result in a **low yield**. Intramolecular hydrogen bonding may reduce the availability of coordinating sites, diminishing catalyst interaction.

15. **Rule 15**: **Modifiers containing aromatic thiol groups**, for example, **4-sulfanylbenzoic acid**, result in a **low yield**. The aromatic system delocalizes the sulfur's lone pair electrons, decreasing its nucleophilicity and effectiveness in coordinating with the metal center.

**End of Rules**---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10,Rule 11,Rule 12,Rule 13,Rule 14,Rule 15
0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,-1,0,0,0,0,0,0,0,0
0,1,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,-1,0,0,0,0,0,0,0,0
0,1,0,0,1,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,1,0,1,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,1,0,0,0,0,-1,0,0,0,0,0,0,0,-1
0,0,0,0,0,0,-1,0,0,0,0,-1,0,0,0
0,1,0,1,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,-1,0,0,0,0,0
0,0,0,1,1,0,-1,0,0,0,0,0,0,0,0
0,1,0,1,0,0,-1,0,0,0,0,0,0,0,0
0,1,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,1,-1,0,0,0,-1,0,-1,0,0,0,0,-1,0
0,1,0,0,0,0,-1,0,-1,0,0,0,0,0,0
0,1,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,1,0,1,0,0,-1,0,0,0,0,0,0,0,0
0,1,-1,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,-1,0,0,0,0,0,0,0,0
0,0,0,1,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,-1,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,1,0,-1,0,0,0,0,0,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.8; Test Accuracy: 0.0
    Train Support: 0.08928571428571429; Test Support: 0.0
    Train Confidence: 0.8589015151515151; Test Confidence: 0.5
    Train Lift: 1.7415732075658545; Test Lift: NONE
    Train Leverage: 0.022142857142857148; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    # Define SMARTS patterns
    amino_group = '[NX3;H2]'
    carboxylic_acid = '[CX3](=O)[OX2H1]'
    carboxylate_anion = '[CX3](=O)[O-]'
    carboxylic_acid_any = '[CX3](=O)[OX1H0-,OX2H1]'
    
    # Electron-withdrawing groups (EWGs)
    nitro_group = '[NX3+](=O)[O-]'
    bromo_substituent = '[Br]'
    carbonyl_group = '[CX3](=O)[#6]'
    halogens = '[F,Cl,Br,I]'
    halogen_on_aromatic = '[c][F,Cl,Br,I]'
    
    # Electron-donating groups (EDGs)
    methyl_group = '[CH3]'
    hydroxyl_group = '[OX2H]'
    methoxy_group = '[OX2][CH3]'
    hydroxyl_on_aromatic = '[c][OX2H]'
    methoxy_on_aromatic = '[c][OX2][CH3]'
    
    # Aromatic carboxylic acids
    aromatic_carboxylic_acid = '[c][CX3](=O)[OX1H0-,OX2H1]'
    
    # Long hydrocarbon chain (aliphatic chain of six or more carbons)
    long_hydrocarbon_chain = '[CH2][CH2][CH2][CH2][CH2][CH2,CH3]'
    
    # Thiol group adjacent to carboxyl group
    thiol_adjacent_to_carboxyl = '[SX2H][CH2][CX3](=O)[OX1H0-,OX2H1]'
    
    # Heteroaromatic nitrogen ring
    heteroaromatic_nitrogen = '[n]'
    
    # Perfluorinated alkyl chain
    perfluorinated_alkyl_chain = '[CX4](F)(F)(F)'
    
    # Polyether chain (simplified for PEG-like chains)
    polyether_chain = '[OX2][CX4][CX4][OX2][CX4][CX4][OX2]'
    
    # Aromatic thiol
    aromatic_thiol = '[c][SX2H]'
    
    # Aldehyde group on aromatic ring
    aldehyde_on_aromatic = '[c][CX3H]=O'
    
    # Define rules with patterns and predictions
    rules = [
        {
            'number': 1,
            'description': 'Modifiers that are amino acids with acidic side chains, containing additional carboxylic acid groups adjacent to the amino group',
            'patterns': [
                [amino_group],
                [carboxylic_acid_any]
            ],
            'count_threshold': {carboxylic_acid_any: 2},
            'prediction': 1
        },
        {
            'number': 2,
            'description': 'Aromatic carboxylic acids with strong electron-withdrawing substituents on the ring, such as nitro, bromo, or carbonyl groups',
            'patterns': [
                [aromatic_carboxylic_acid],
                [nitro_group, bromo_substituent, carbonyl_group, halogen_on_aromatic]
            ],
            'prediction': 1
        },
        {
            'number': 3,
            'description': 'Aromatic carboxylic acids with electron-donating substituents, such as methyl, hydroxyl, or methoxy groups',
            'patterns': [
                [aromatic_carboxylic_acid],
                [hydroxyl_on_aromatic, methoxy_on_aromatic, methyl_group]
            ],
            'prediction': -1
        },
        {
            'number': 4,
            'description': 'Modifiers containing heteroaromatic rings with nitrogen atoms capable of chelation, such as pyridine or pyrazole carboxylic acids',
            'patterns': [
                [heteroaromatic_nitrogen],
                [carboxylic_acid_any]
            ],
            'prediction': 1
        },
        {
            'number': 5,
            'description': 'Aliphatic carboxylic acids with an amino group on a short carbon chain, specifically within three to five carbons',
            'patterns': [
                [amino_group],
                [carboxylic_acid_any]
            ],
            'chain_length_range': (3, 5),
            'prediction': 1
        },
        {
            'number': 6,
            'description': 'Modifiers that are aliphatic carboxylic acids with long hydrocarbon chains lacking polar substituents',
            'patterns': [
                [carboxylic_acid_any],
                [long_hydrocarbon_chain]
            ],
            'exclude_patterns': [
                [hydroxyl_group],
                [amino_group],
                [heteroaromatic_nitrogen],
                [halogens]
            ],
            'prediction': 1
        },
        {
            'number': 7,
            'description': 'Aliphatic carboxylic acids with polar substituents distant from the carboxyl group, including hydroxyl or amino groups on chains longer than five carbons',
            'patterns': [
                [carboxylic_acid_any],
                [hydroxyl_group, amino_group]
            ],
            'chain_length_range': (6, None),
            'prediction': -1
        },
        {
            'number': 8,
            'description': 'Modifiers containing aliphatic thiol groups adjacent to the carboxyl group',
            'patterns': [
                [thiol_adjacent_to_carboxyl]
            ],
            'prediction': 1
        },
        {
            'number': 9,
            'description': 'Aromatic carboxylic acids with aldehyde (formyl) substituents on the ring',
            'patterns': [
                [aromatic_carboxylic_acid],
                [aldehyde_on_aromatic]
            ],
            'prediction': -1
        },
        {
            'number': 10,
            'description': 'Modifiers with perfluorinated alkyl chains or multiple fluorine atoms on the alkyl side chain',
            'patterns': [
                [carboxylic_acid_any],
                [perfluorinated_alkyl_chain]
            ],
            'prediction': -1
        },
        {
            'number': 11,
            'description': 'Amino acids with non-coordinating, hydrophobic side chains lacking additional heteroatoms',
            'patterns': [
                [amino_group],
                [carboxylic_acid_any]
            ],
            'exclude_patterns': [
                [hydroxyl_group],
                [heteroaromatic_nitrogen]
            ],
            'prediction': -1
        },
        {
            'number': 12,
            'description': 'Modifiers containing long polyether chains or polyethylene glycol (PEG) moieties',
            'patterns': [
                [carboxylic_acid_any],
                [polyether_chain]
            ],
            'prediction': -1
        },
        {
            'number': 13,
            'description': 'Modifiers with multiple hydroxyl groups on short aliphatic chains',
            'patterns': [
                [carboxylic_acid_any],
                [hydroxyl_group]
            ],
            'count_threshold': {hydroxyl_group: 2},
            'prediction': 1
        },
        {
            'number': 14,
            'description': 'Aromatic carboxylic acids with hydroxyl groups capable of intramolecular hydrogen bonding',
            'patterns': [
                [aromatic_carboxylic_acid],
                [hydroxyl_on_aromatic]
            ],
            'ortho_substituent': True,
            'prediction': -1
        },
        {
            'number': 15,
            'description': 'Modifiers containing aromatic thiol groups',
            'patterns': [
                [aromatic_carboxylic_acid],
                [aromatic_thiol]
            ],
            'prediction': -1
        }
    ]
    
    # Compile SMARTS patterns for each rule
    for rule in rules:
        # Compile required patterns
        compiled_patterns = []
        for group in rule.get('patterns', []):
            compiled_group = [Chem.MolFromSmarts(p) for p in group]
            compiled_patterns.append(compiled_group)
        rule['compiled_patterns'] = compiled_patterns

        # Compile exclude patterns if any
        if 'exclude_patterns' in rule:
            compiled_excludes = []
            for group in rule['exclude_patterns']:
                compiled_group = [Chem.MolFromSmarts(p) for p in group]
                compiled_excludes.append(compiled_group)
            rule['compiled_exclude_patterns'] = compiled_excludes
    
    # Initialize results list
    results = []
    
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*len(rules))
            continue
        row = []
        for rule in rules:
            try:
                match = True
                # Check exclude patterns if any
                if 'exclude_patterns' in rule:
                    for group in rule['compiled_exclude_patterns']:
                        for pat in group:
                            if mol.HasSubstructMatch(pat):
                                match = False
                                break
                        if not match:
                            break
                    if not match:
                        row.append(0)
                        continue
                # Check required patterns
                for compiled_group in rule['compiled_patterns']:
                    group_match = False
                    for pat in compiled_group:
                        matches = mol.GetSubstructMatches(pat)
                        if matches:
                            # If a count threshold is specified for this pattern
                            if 'count_threshold' in rule and pat.GetSmarts() in rule['count_threshold']:
                                threshold = rule['count_threshold'][pat.GetSmarts()]
                                if len(matches) >= threshold:
                                    group_match = True
                                    break
                            else:
                                group_match = True
                                break
                    if not group_match:
                        match = False
                        break
                # Handle additional constraints
                # Note: Implement chain length and ortho-substituent checks as needed
                if match:
                    row.append(rule['prediction'])
                else:
                    row.append(0)
            except Exception as e:
                # In case of any error, append 0
                row.append(0)
        results.append(row)
    # Create DataFrame
    df = pd.DataFrame(results, columns=[f'Rule {rule["number"]}' for rule in rules])
    return df

--------------------------------------------------
    Target Name: yield
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

1. **Rule 1**: Modifiers that are **carboxylic acids with additional coordinating groups (e.g., amino, hydroxyl, or thiol) within three carbons of the carboxyl group** result in a **high yield**. Proximal coordinating groups enhance binding to the metal center by chelation, increasing catalyst efficiency. Examples include:
   - **(2S)-2-aminobutanedioic acid** (aspartic acid) – has an amino group at the α-position and a side-chain carboxyl group.
   - **3-sulfanylpropanoic acid** – contains a thiol group three carbons from the carboxyl group.
   - **5-aminopentanoic acid** – has an amino group within three carbons of the carboxyl group.

2. **Rule 2**: Modifiers that are **alpha-amino acids with side chains containing acidic or coordinating functional groups**, such as **carboxyl**, **hydroxyl**, or **heterocycles**, result in a **high yield**. These groups facilitate strong coordination with the metal center. Examples include:
   - **(2S)-2-aminopentanedioic acid** (glutamic acid) – possesses a side-chain carboxyl group.
   - **(2R)-2-amino-3-(1H-indol-3-yl)propanoic acid** (tryptophan) – contains an indole ring capable of coordination.
   - **(2R,3S,4R,5R)-2,3,4,5,6-pentahydroxyhexanoic acid** (gluconic acid) – features multiple hydroxyl groups.

3. **Rule 3**: Modifiers that are **aromatic carboxylic acids with strong electron-withdrawing groups at the para position**, such as **nitro**, **halomethyl**, or **cyano** groups, result in a **high yield**. Electron-withdrawing groups increase the acidity of the carboxylate, enhancing metal coordination. Examples include:
   - **4-nitrobenzoic acid** – contains a strong electron-withdrawing nitro group.
   - **4-(bromomethyl)benzoic acid** – has a halomethyl group at the para position.

4. **Rule 4**: Modifiers that are **aromatic carboxylic acids with electron-donating groups at the para position**, such as **methyl**, **methoxy**, or **hydroxyl** groups, result in a **low yield**. Electron-donating groups decrease the acidity of the carboxylate, weakening metal coordination. Examples include:
   - **4-methylbenzoic acid** – features a methyl group at the para position.
   - **3-(4-hydroxyphenyl)propanoic acid** – possesses a para-hydroxyl group on the aromatic ring.

5. **Rule 5**: Modifiers that are **carboxylic acids with amino or hydroxyl groups more than three carbons away from the carboxyl group** result in a **low yield**. Distant functional groups fail to participate effectively in coordination due to the increased chain length. Examples include:
   - **7-aminoheptanoic acid** – amino group is four carbons away from the carboxyl group.
   - **8-aminooctanoic acid** – amino group is five carbons away from the carboxyl group.
   - **7-hydroxyheptanoic acid** – hydroxyl group is four carbons away from the carboxyl group.

6. **Rule 6**: Modifiers that are **heterocyclic carboxylic acids with nitrogen-containing rings capable of metal coordination**, such as **pyridine** or **pyrazole**, result in a **high yield**. The lone pair electrons on nitrogen enhance coordination with the metal center. Examples include:
   - **Pyridine-3-carboxylic acid** (nicotinic acid) – a pyridine ring with a carboxyl group at the 3-position.
   - **1H-pyrazole-4-carboxylic acid** – contains a pyrazole ring with coordinating nitrogen atoms.

7. **Rule 7**: Modifiers that are **aromatic carboxylic acids with aldehyde (formyl) groups at the para position** result in a **low yield**. Aldehyde groups can undergo side reactions or hinder metal coordination through steric or electronic effects. Examples include:
   - **4-formylbenzoic acid** – aldehyde group at the para position.
   - **5-formyl-2-hydroxybenzoic acid** – aldehyde group adjacent to the carboxyl group.

8. **Rule 8**: Modifiers that are **aromatic carboxylic acids with amino groups at the para position** result in a **high yield**. The amino group can act as an additional coordinating site, enhancing metal binding. Example:
   - **4-aminobenzoic acid** – amino group at the para position.

9. **Rule 9**: Modifiers that are **aliphatic carboxylic acids with extended alkyl chains (six or more carbons) without additional functional groups** result in a **high yield**. The long hydrophobic chains may favor catalyst-substrate interactions without hindering coordination. Example:
   - **Octanoic acid** – eight-carbon saturated fatty acid.

10. **Rule 10**: Modifiers containing **long flexible chains with multiple ether linkages**, such as **polyether carboxylic acids**, result in a **low yield**. The flexibility and steric hindrance of ether chains reduce effective coordination with the metal center. Examples include:
    - **2-[2-(2-methoxyethoxy)ethoxy]acetic acid** – triethylene glycol monomethyl ether with a carboxylate end.
    - **3-[2-(2-aminoethoxy)ethoxy]propanoic acid** – contains multiple ether linkages and an amino group distant from the carboxyl group.

11. **Rule 11**: Modifiers that are **perfluorinated carboxylic acids or those with multiple fluorine atoms** result in a **low yield**. Fluorine's strong electron-withdrawing effect reduces electron density on the carboxylate oxygen, weakening coordination. Example:
    - **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid** – heavily fluorinated pentanoic acid.

12. **Rule 12**: Modifiers that are **aromatic carboxylic acids connected to another aromatic ring through a short aliphatic linker (three or four carbons)** result in a **high yield**. The aliphatic linker reduces steric hindrance and allows for flexible coordination. Examples include:
    - **5-(4-hydroxyphenyl)pentanoic acid** – aromatic ring connected via a pentanoic chain.
    - **4-pyridin-4-ylbutanoic acid** – pyridine ring linked through a butanoic acid chain.

13. **Rule 13**: Modifiers that are **aromatic carboxylic acids directly connected to another aromatic ring without an aliphatic linker** result in a **low yield**. Direct conjugation can cause steric hindrance or electronic interference with metal coordination. Example:
    - **4-pyridin-4-ylbenzoic acid** – two aromatic rings directly connected.

14. **Rule 14**: Modifiers with **thiol groups at the para position of aromatic carboxylic acids** result in a **low yield**. Thiol groups may form disulfide bonds or interact unfavorably with the metal center. Example:
    - **4-sulfanylbenzoic acid** – thiol group at the para position.

15. **Rule 15**: Modifiers that are **carboxylic acids with multiple hydroxyl groups attached to the carbon chain**, capable of forming chelate rings with metals, result in a **high yield**. Multiple hydroxyls enhance coordination and stability of the metal complex. Examples include:
    - **(2R,3S,4R,5R)-2,3,4,5,6-pentahydroxyhexanoic acid** (gluconic acid) – multiple hydroxyl groups along the chain.
    - **2-[[1,3-dihydroxy-2-(hydroxymethyl)propan-2-yl]oxy]acetic acid** – features several hydroxyl groups and an ether linkage near the carboxyl group.

**End of Rules**

These rules capture the relationships between the structural features of molecular modifiers and the resulting high or low yields in the reaction. They consider the proximity and type of functional groups that can coordinate with the metal center, the electronic effects of substituents on aromatic rings, and the impact of steric hindrance on metal coordination. By applying these rules, one can predict the expected yield outcome for new modifiers based on their structural attributes.---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,1,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,1,0,0
1,0,0,0
1,0,0,0
1,1,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0
1,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.5428571428571428; Test Accuracy: 0.0
    Train Support: 0.02857142857142857; Test Support: 0.0
    Train Confidence: 0.3333333333333333; Test Confidence: 0.5
    Train Lift: 0.6481481481481481; Test Lift: NONE
    Train Leverage: -0.015510204081632648; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    # Define SMARTS patterns for functional groups and substructures
    from rdkit import Chem
    from rdkit.Chem import AllChem
    
    # Common SMARTS patterns
    carboxylic_acid_sma = '[CX3](=O)[OX2H1]'
    carboxylate_anion_sma = '[CX3](=O)[O-]'
    amino_group_sma = '[NX3;H2,H1;!$(N-*=[O,N,S])]'  # Exclude N connected to multiple bonds to O, N, or S
    hydroxyl_group_sma = '[OX2H]'
    thiol_group_sma = '[SX2H]'
    
    # Compile SMARTS patterns
    carboxylic_acid = Chem.MolFromSmarts(carboxylic_acid_sma)
    carboxylate_anion = Chem.MolFromSmarts(carboxylate_anion_sma)
    amino_group = Chem.MolFromSmarts(amino_group_sma)
    hydroxyl_group = Chem.MolFromSmarts(hydroxyl_group_sma)
    thiol_group = Chem.MolFromSmarts(thiol_group_sma)
    
    # Electron-withdrawing groups (EWGs)
    nitro_group_sma = '[NX3](=O)=O'
    halomethyl_group_sma = '[CX4][F,Cl,Br,I]'
    cyano_group_sma = '[C]#[N]'
    
    nitro_group = Chem.MolFromSmarts(nitro_group_sma)
    halomethyl_group = Chem.MolFromSmarts(halomethyl_group_sma)
    cyano_group = Chem.MolFromSmarts(cyano_group_sma)
    
    # Electron-donating groups (EDGs)
    methyl_group_sma = '[CH3]'
    methoxy_group_sma = '[OX2][CH3]'
    hydroxyl_on_ring_sma = '[c][OX2H]'
    
    methyl_group = Chem.MolFromSmarts(methyl_group_sma)
    methoxy_group = Chem.MolFromSmarts(methoxy_group_sma)
    hydroxyl_on_ring = Chem.MolFromSmarts(hydroxyl_on_ring_sma)
    
    # Aldehyde group
    aldehyde_group_sma = '[CX3H1](=O)[#6]'
    aldehyde_group = Chem.MolFromSmarts(aldehyde_group_sma)
    
    # Aromatic carboxylic acid
    aromatic_carboxylic_acid_sma = 'c[C](=O)[O,H]'
    aromatic_carboxylic_acid = Chem.MolFromSmarts(aromatic_carboxylic_acid_sma)
    
    # Alpha-amino acid
    alpha_amino_acid_sma = '[NX3;H2,H1][CH2][CX3](=O)[OX2H1]'
    alpha_amino_acid = Chem.MolFromSmarts(alpha_amino_acid_sma)
    
    # Heterocyclic rings with nitrogen
    pyridine_ring_sma = '[n][c][c][c][c][c]'
    pyrazole_ring_sma = '[n][n][c][c][c]'
    
    pyridine_ring = Chem.MolFromSmarts(pyridine_ring_sma)
    pyrazole_ring = Chem.MolFromSmarts(pyrazole_ring_sma)
    
    # Long aliphatic chain (6 or more carbons)
    long_aliphatic_chain_sma = '[CH2][CH2][CH2][CH2][CH2][CH2]'
    long_aliphatic_chain = Chem.MolFromSmarts(long_aliphatic_chain_sma)
    
    # Polyether chain
    polyether_chain_sma = '([OX2][CX4])*'
    polyether_chain = Chem.MolFromSmarts(polyether_chain_sma)
    
    # Perfluorinated chain
    perfluoro_chain_sma = '([CF2][CF2])*'
    perfluoro_chain = Chem.MolFromSmarts(perfluoro_chain_sma)
    
    # Define the rules with their associated patterns and predictions
    rules = [
        {
            'number': 1,
            'description': 'Modifiers that are carboxylic acids with additional coordinating groups (amino, hydroxyl, or thiol) within three carbons of the carboxyl group result in a high yield.',
            'prediction': 1,
            'func': lambda mol: rule1_func(mol, carboxylic_acid, carboxylate_anion, [amino_group, hydroxyl_group, thiol_group])
        },
        {
            'number': 2,
            'description': 'Modifiers that are alpha-amino acids with side chains containing acidic or coordinating functional groups, such as carboxyl, hydroxyl, or heterocycles, result in a high yield.',
            'prediction': 1,
            'func': lambda mol: rule2_func(mol, alpha_amino_acid, [carboxylic_acid, hydroxyl_group], [pyridine_ring, pyrazole_ring])
        },
        {
            'number': 3,
            'description': 'Modifiers that are aromatic carboxylic acids with strong electron-withdrawing groups at the para position, such as nitro, halomethyl, or cyano groups, result in a high yield.',
            'prediction': 1,
            'func': lambda mol: rule3_func(mol, aromatic_carboxylic_acid, [nitro_group, halomethyl_group, cyano_group])
        },
        {
            'number': 4,
            'description': 'Modifiers that are aromatic carboxylic acids with electron-donating groups at the para position, such as methyl, methoxy, or hydroxyl groups, result in a low yield.',
            'prediction': -1,
            'func': lambda mol: rule4_func(mol, aromatic_carboxylic_acid, [methyl_group, methoxy_group, hydroxyl_on_ring])
        },
        # Additional rules (5 to 15) to be defined similarly...
    ]
    
    # Define functions for each rule
    def rule1_func(mol, carboxylic_acid, carboxylate_anion, coordinating_groups):
        # Find carboxylic acid groups
        carboxy_matches = mol.GetSubstructMatches(carboxylic_acid)
        carboxylate_matches = mol.GetSubstructMatches(carboxylate_anion)
        carboxylic_acid_matches = carboxy_matches + carboxylate_matches
        if not carboxylic_acid_matches:
            return 0
        # Find coordinating groups
        coord_matches = []
        for group in coordinating_groups:
            matches = mol.GetSubstructMatches(group)
            coord_matches.extend(matches)
        if not coord_matches:
            return 0
        # Check distances between carboxylic acid and coordinating groups
        for ca_match in carboxylic_acid_matches:
            ca_atom_idx = ca_match[0]  # Carbon of the carboxylic acid
            for coord_match in coord_matches:
                coord_atom_idx = coord_match[0]
                path = Chem.rdmolops.GetShortestPath(mol, ca_atom_idx, coord_atom_idx)
                num_carbons = sum(1 for idx in path if mol.GetAtomWithIdx(idx).GetAtomicNum() == 6)
                if num_carbons <= 3:
                    return 1
        return 0
    
    def rule2_func(mol, alpha_amino_acid, side_chain_groups, heterocycles):
        # Check for alpha-amino acid core
        matches = mol.GetSubstructMatches(alpha_amino_acid)
        if not matches:
            return 0
        # Check for side chain functional groups
        for group in side_chain_groups:
            if mol.HasSubstructMatch(group):
                return 1
        # Check for heterocycles
        for heterocycle in heterocycles:
            if mol.HasSubstructMatch(heterocycle):
                return 1
        return 0
    
    def rule3_func(mol, aromatic_carboxylic_acid, ewg_groups):
        # Find aromatic carboxylic acid
        matches = mol.GetSubstructMatches(aromatic_carboxylic_acid)
        if not matches:
            return 0
        # Check for EWG at para position
        for match in matches:
            ring_atoms = match[:2]  # Assume ring atoms are first in the match
            for bond in mol.GetAtomWithIdx(ring_atoms[0]).GetBonds():
                neighbor = bond.GetOtherAtomIdx(ring_atoms[0])
                if neighbor in ring_atoms:
                    continue
                neighbor_atom = mol.GetAtomWithIdx(neighbor)
                for ewg in ewg_groups:
                    if mol.HasSubstructMatch(ewg, useChirality=False, atoms=neighbor_atom.GetIdx()):
                        return 1
        return 0
    
    def rule4_func(mol, aromatic_carboxylic_acid, edg_groups):
        # Find aromatic carboxylic acid
        matches = mol.GetSubstructMatches(aromatic_carboxylic_acid)
        if not matches:
            return 0
        # Check for EDG at para position
        for match in matches:
            ring_atoms = match[:2]  # Assume ring atoms are first in the match
            for bond in mol.GetAtomWithIdx(ring_atoms[0]).GetBonds():
                neighbor = bond.GetOtherAtomIdx(ring_atoms[0])
                if neighbor in ring_atoms:
                    continue
                neighbor_atom = mol.GetAtomWithIdx(neighbor)
                for edg in edg_groups:
                    if mol.HasSubstructMatch(edg, useChirality=False, atoms=neighbor_atom.GetIdx()):
                        return -1
        return 0
    
    # Initialize results list
    results = []
    
    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*len(rules))
            continue
        row = []
        for rule in rules:
            try:
                value = rule['func'](mol)
                if value not in [-1, 0, 1]:
                    value = 0
                row.append(value)
            except Exception as e:
                # In case of any error, append 0
                row.append(0)
        results.append(row)
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])
    return df

--------------------------------------------------
    Target Name: yield
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

1. **Rule 1**: Modifiers that are **aliphatic carboxylic acids with an amino or thiol group on the alpha carbon** result in a **high yield**. The proximal amino or thiol group can effectively chelate the metal center, enhancing catalyst activity. Examples include:
   - **(2S)-2-aminobutanedioic acid** (aspartic acid) – amino group at the α-position.
   - **(2S)-2-aminopentanedioic acid** (glutamic acid) – amino group at the α-position.
   - **3-sulfanylpropanoic acid** – thiol group at the α-position.

2. **Rule 2**: Modifiers that are **aromatic carboxylic acids with strong electron-withdrawing groups at the para position**, such as **nitro**, **halomethyl**, or **amino** groups, result in a **high yield**. These groups increase carboxylate acidity, enhancing metal coordination. Examples include:
   - **4-nitrobenzoic acid** – nitro group at the para position.
   - **4-(bromomethyl)benzoic acid** – bromomethyl group at the para position.
   - **4-aminobenzoic acid** – amino group at the para position.

3. **Rule 3**: Modifiers that are **heterocyclic carboxylic acids containing nitrogen atoms capable of coordinating with metals** result in a **high yield**. Nitrogen atoms provide additional coordination sites, strengthening metal-ligand interactions. Examples include:
   - **Pyridine-3-carboxylic acid** (nicotinic acid) – pyridine nitrogen coordinates with metal.
   - **1H-pyrazole-4-carboxylic acid** – pyrazole ring contains coordinating nitrogen atoms.

4. **Rule 4**: Modifiers that are **aliphatic carboxylic acids with long unbranched hydrocarbon chains (five or more carbons)** result in a **high yield**. The hydrophobic chains may enhance substrate-catalyst interactions without hindering metal coordination. Examples include:
   - **Octanoic acid** – eight-carbon saturated fatty acid.
   - **5-aminopentanoic acid** – five-carbon chain with an amino group.

5. **Rule 5**: Modifiers with **multiple hydroxyl groups adjacent to the carboxylate** result in a **high yield**. Hydroxyl groups can chelate the metal center, increasing catalyst stability. Examples include:
   - **(2R,3S,4R,5R)-2,3,4,5,6-pentahydroxyhexanoic acid** (gluconic acid) – several hydroxyl groups near carboxylate.
   - **2-oxo-1H-pyridine-4-carboxylic acid** – ketone and hydroxyl functionalities adjacent to carboxylate.

6. **Rule 6**: Modifiers that are **aromatic carboxylic acids with electron-donating groups at the para position**, such as **methyl**, **methoxy**, or **hydroxyl** groups, result in a **low yield**. These groups decrease carboxylate acidity, weakening metal coordination. Examples include:
   - **4-methylbenzoic acid** – methyl group at the para position.
   - **3-(4-hydroxyphenyl)propanoic acid** – para-hydroxyl group on the aromatic ring.

7. **Rule 7**: Modifiers with **flexible chains containing multiple ether linkages**, such as **polyether carboxylic acids**, result in a **low yield**. The flexibility and size of ether chains reduce effective coordination due to entropic factors. Example:
   - **2-[2-(2-methoxyethoxy)ethoxy]acetic acid** – triethylene glycol chain with terminal carboxylate.

8. **Rule 8**: Modifiers containing **multiple fluorine atoms on the carbon chain** result in a **low yield**. Fluorine's strong electronegativity lowers the basicity of the carboxylate oxygen, weakening metal coordination. Example:
   - **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid** – heavily fluorinated pentanoic acid.

9. **Rule 9**: Modifiers with **amino or hydroxyl groups located three or more carbons away from the carboxylate group** result in a **low yield**. Distant functional groups are less effective in coordinating with the metal center. Examples include:
   - **7-aminoheptanoic acid** – amino group four carbons away from carboxylate.
   - **8-aminooctanoic acid** – amino group five carbons away.
   - **7-hydroxyheptanoic acid** – hydroxyl group four carbons away.

10. **Rule 10**: Modifiers that are **aromatic carboxylic acids with aldehyde (formyl) groups at the para position** result in a **low yield**. Aldehyde groups can engage in side reactions or alter electronic distribution, hindering metal coordination. Examples include:
    - **4-formylbenzoic acid** – formyl group at the para position.
    - **5-formyl-2-hydroxybenzoic acid** – formyl group near carboxylate.

11. **Rule 11**: Modifiers with **bulky substituents adjacent to the carboxylate group** result in a **low yield**. Steric hindrance interferes with effective coordination between the modifier and the metal center. Example:
    - **4-pyridin-4-ylbenzoic acid** – directly connected aromatic rings create steric hindrance.

12. **Rule 12**: Modifiers that are **amino acids with aromatic side chains lacking additional coordinating groups** result in a **low yield**. Without effective chelation sites, metal coordination is weaker. Example:
    - **(2S)-2-amino-3-phenylpropanoic acid** (phenylalanine) – lacks functional groups for chelation.

13. **Rule 13**: Modifiers with **thiol groups on an aromatic ring adjacent to the carboxylate** result in a **low yield**. Aromatic thiol groups may not coordinate effectively due to delocalization of electron density. Example:
    - **4-sulfanylbenzoic acid** – thiol group on aromatic ring near carboxylate.

14. **Rule 14**: Modifiers that have **amide or acetamido groups distant from the carboxylate** result in a **low yield**. The separation reduces the likelihood of chelation with the metal center. Example:
    - **(2S)-6-acetamido-2-aminohexanoic acid** – acetamido group distant from carboxylate.

15. **Rule 15**: Modifiers that are **aromatic carboxylic acids with extended conjugation and ketone groups adjacent to the carboxylate** result in a **high yield**. Ketone groups can participate in chelation, and conjugation stabilizes the coordination complex. Example:
    - **1,3-dioxo-2-benzofuran-5-carboxylic acid** – ketone and lactone groups adjacent to carboxylate.

**End of Rules**---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10,Rule 11,Rule 12,Rule 13,Rule 14,Rule 15
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,1,0,0,0,-1,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,1,0,0,0,-1,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,-1,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,1,0,0,0,-1,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,1,0,0,0,-1,0,0,0,0,-1,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,-1,0,0,0
1,0,0,0,0,0,0,-1,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,-1,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,1,0,0,0,-1,0,0,0,-1,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,1,0,0,0,-1,0,0,0,-1,0,0,0,0,0
1,1,0,0,0,-1,0,0,0,0,0,0,0,0,0
1,1,0,0,0,-1,0,0,0,0,0,0,0,0,0
1,0,1,0,0,0,0,0,0,0,0,0,0,0,0
1,1,0,0,0,-1,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,-1,0,0,0,0,0,0,0,0,0
1,1,0,0,0,-1,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,-1,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.6; Test Accuracy: 0.0
    Train Support: 0.05; Test Support: 0.0
    Train Confidence: 0.85; Test Confidence: 0.5
    Train Lift: 1.7099673202614378; Test Lift: NONE
    Train Leverage: 0.0026530612244897974; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    # Define SMARTS patterns for functional groups and structures
    from rdkit import Chem

    # Rule 1: Aliphatic carboxylic acids with amino or thiol group on alpha carbon
    rule1_patterns = [
        '[CX3](=O)[OX1H0-,OX2H1]',  # Carboxylic acid
        '[NX3H2][CX4H]([*])[CX3](=O)[OX1H0-,OX2H1]',  # Amino group on alpha carbon
        '[SX2H][CX4H]([*])[CX3](=O)[OX1H0-,OX2H1]'   # Thiol group on alpha carbon
    ]

    # Rule 2: Aromatic carboxylic acids with strong electron-withdrawing groups at the para position
    rule2_patterns = [
        '[c][c](C(=O)[O,H])[c][c][c][c]',  # Aromatic carboxylic acid
        '[c]-[NX3+](=O)[O-]',  # Nitro group
        '[c]-[CH2][F,Cl,Br,I]',  # Halomethyl group
        '[c]-[NH2]'  # Amino group
    ]

    # Rule 3: Heterocyclic carboxylic acids containing coordinating nitrogen atoms
    rule3_patterns = [
        '[n][c][c](C(=O)[O,H])[c][c]',  # Pyridine carboxylic acid
        '[n]1[c][n][c][c]1C(=O)[O,H]'  # Pyrazole carboxylic acid
    ]

    # Rule 4: Aliphatic carboxylic acids with long unbranched hydrocarbon chains (five or more carbons)
    rule4_patterns = [
        '[CX3](=O)[OX1H0-,OX2H1][CX4H2][CX4H2][CX4H2][CX4H2][CX4H3]',  # At least five carbons
        '[CX3](=O)[OX1H0-,OX2H1][CX4H2][CX4H2][CX4H2][CX4H2][NX3H2]'   # With amino group at the end
    ]

    # Rule 5: Modifiers with multiple hydroxyl groups adjacent to the carboxylate
    rule5_patterns = [
        '[OX2H][CX4H]([OX2H])[CX4H]([OX2H])[CX4H](C(=O)[O,H])[OX2H]',  # Multiple hydroxyls near carboxylate
        '[c][c](=O)[c](=O)[c][c]C(=O)[O,H]'  # Ketone and hydroxyl functionalities adjacent to carboxylate
    ]

    # Rule 6: Aromatic carboxylic acids with electron-donating groups at the para position
    rule6_patterns = [
        '[c][c](C(=O)[O,H])[c][c][c][c]',  # Aromatic carboxylic acid
        '[c]-[CH3]',  # Methyl group
        '[c]-[OX2H]',  # Hydroxyl group
        '[c]-[OX2][CH3]'  # Methoxy group
    ]

    # Rule 7: Modifiers with flexible chains containing multiple ether linkages
    rule7_patterns = [
        '[OX2][CX4H2][OX2][CX4H2][OX2][CX4H2]C(=O)[O,H]',  # Polyether chain with terminal carboxylate
    ]

    # Rule 8: Modifiers containing multiple fluorine atoms on the carbon chain
    rule8_patterns = [
        '[CX4]([F])(C([F])(C([F])(C([F])(C(=O)[O,H])[F])[F])[F])[F]',  # Heavily fluorinated pentanoic acid
    ]

    # Rule 9: Amino or hydroxyl groups located three or more carbons away from the carboxylate group
    rule9_patterns = [
        '[CX3](=O)[OX1H0-,OX2H1][CX4H2][CX4H2][CX4H2][CX4H2][NX3H2]',  # Amino group four carbons away
        '[CX3](=O)[OX1H0-,OX2H1][CX4H2][CX4H2][CX4H2][CX4H2][CX4H2][OX2H]',  # Hydroxyl group five carbons away
    ]

    # Rule 10: Aromatic carboxylic acids with aldehyde (formyl) groups at the para position
    rule10_patterns = [
        '[c][c](C(=O)[O,H])[c][c][c][c](C=O)',  # Formyl group at para position
    ]

    # Rule 11: Modifiers with bulky substituents adjacent to the carboxylate group
    rule11_patterns = [
        '[c][c](C(=O)[O,H])[c][c][c][c][c]',  # Directly connected aromatic rings
    ]

    # Rule 12: Amino acids with aromatic side chains lacking additional coordinating groups
    rule12_patterns = [
        '[NX3H2][CX4H](C(=O)[O,H])[CX4H2][c]',  # Phenylalanine-like structure
    ]

    # Rule 13: Thiol groups on an aromatic ring adjacent to the carboxylate
    rule13_patterns = [
        '[c][c](C(=O)[O,H])[c][c][c][c][SX2H]',  # Thiol group on aromatic ring
    ]

    # Rule 14: Amide or acetamido groups distant from the carboxylate
    rule14_patterns = [
        '[NX3H2][CX4H](C(=O)[O,H])[CX4H2][CX4H2][NX3][CX3](=O)[CX4H3]',  # Acetamido group distant
    ]

    # Rule 15: Aromatic carboxylic acids with extended conjugation and ketone groups adjacent to the carboxylate
    rule15_patterns = [
        '[c]1[c](=O)[o][c][c](C(=O)[O,H])[c]1',  # Ketone and lactone groups adjacent to carboxylate
    ]

    # Compile all patterns
    compiled_rules = []
    for patterns in [
        rule1_patterns,
        rule2_patterns,
        rule3_patterns,
        rule4_patterns,
        rule5_patterns,
        rule6_patterns,
        rule7_patterns,
        rule8_patterns,
        rule9_patterns,
        rule10_patterns,
        rule11_patterns,
        rule12_patterns,
        rule13_patterns,
        rule14_patterns,
        rule15_patterns
    ]:
        compiled_patterns = [Chem.MolFromSmarts(pat) for pat in patterns]
        compiled_rules.append(compiled_patterns)

    # List to store results
    results = []

    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*15)
            continue
        row = []
        # Apply each rule
        for idx, rule_patterns in enumerate(compiled_rules):
            try:
                match = False
                for pat in rule_patterns:
                    if mol.HasSubstructMatch(pat):
                        match = True
                        break
                if match:
                    # Determine the prediction based on the rule number
                    if idx + 1 in [1, 2, 3, 4, 5, 15]:
                        row.append(1)  # High yield
                    else:
                        row.append(-1)  # Low yield
                else:
                    row.append(0)  # Does not match
            except Exception:
                row.append(0)
        results.append(row)

    # Create DataFrame with results
    df = pd.DataFrame(
        results,
        columns=[f'Rule {i+1}' for i in range(15)]
    )
    return df

--------------------------------------------------
    Target Name: yield
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    After analyzing the dataset and considering the chemical properties of the modifiers, here are the rules that describe the relationship between molecular modifiers and the yield of the reaction:

**Start of Rules**

1. **Rule 1**: Modifiers that are **amino acids with carboxylic acid side chains**, such as **aspartic acid** and **glutamic acid**, result in a **high yield**. The presence of multiple carboxylate groups adjacent to an amino group enhances coordination with the metal center through bidentate chelation.

   - Examples:
     - **(2S)-2-aminobutanedioic acid** (Aspartic acid)
     - **(2S)-2-aminopentanedioic acid** (Glutamic acid)

2. **Rule 2**: Modifiers that are **aromatic carboxylic acids with electron-withdrawing groups at the para position**, such as **nitro** or **bromomethyl** groups, result in a **high yield**. Electron-withdrawing substituents increase the acidity of the carboxylate, enhancing metal coordination by stabilizing the negative charge.

   - Examples:
     - **4-nitrobenzoic acid**
     - **4-(bromomethyl)benzoic acid**

3. **Rule 3**: Modifiers that are **aromatic carboxylic acids with amino groups at the para position** result in a **high yield**. The amino group can act as an additional coordination site, forming stronger complexes with the metal center.

   - Example:
     - **4-aminobenzoic acid**

4. **Rule 4**: Modifiers that are **heterocyclic carboxylic acids containing nitrogen atoms within the ring** result in a **high yield**. The nitrogen atoms serve as additional coordination sites, enhancing metal-ligand interactions.

   - Examples:
     - **Pyridine-3-carboxylic acid** (Nicotinic acid)
     - **1H-pyrazole-4-carboxylic acid**
     - **2-oxo-1H-pyridine-4-carboxylic acid**

5. **Rule 5**: Modifiers that are **aliphatic carboxylic acids with proximal functional groups (amino, hydroxyl, or thiol) within three carbons of the carboxylate** result in a **high yield**. These functional groups enhance chelation with the metal center by forming stable bidentate ligands.

   - Examples:
     - **5-aminopentanoic acid**
     - **3-sulfanylpropanoic acid**

6. **Rule 6**: Modifiers that are **carboxylic acids with adjacent hydroxyl or carbonyl groups capable of chelation** result in a **high yield**. The adjacent functional groups facilitate the formation of stable chelate rings with the metal center.

   - Examples:
     - **(2R,3S,4R,5R)-2,3,4,5,6-pentahydroxyhexanoic acid** (Gluconic acid)
     - **1,3-dioxo-2-benzofuran-5-carboxylic acid**

7. **Rule 7**: Modifiers that are **aromatic carboxylic acids with aldehyde (formyl) groups at the ortho or para position** result in a **low yield**. The aldehyde groups may participate in side reactions or hinder metal coordination due to steric effects.

   - Examples:
     - **4-formylbenzoic acid**
     - **5-formyl-2-hydroxybenzoic acid**

8. **Rule 8**: Modifiers that are **aliphatic carboxylic acids with distal functional groups (more than three carbons away from the carboxylate)** result in a **low yield**. The increased flexibility and distance reduce effective chelation with the metal center.

   - Examples:
     - **7-aminoheptanoic acid**
     - **8-aminooctanoic acid**
     - **7-hydroxyheptanoic acid**

9. **Rule 9**: Modifiers that are **aromatic carboxylic acids with electron-donating groups at the para position** (excluding amino groups) result in a **low yield**. Electron-donating groups decrease the acidity of the carboxylate, weakening coordination with the metal center.

   - Examples:
     - **4-methylbenzoic acid**
     - **3-(4-hydroxyphenyl)propanoic acid**

10. **Rule 10**: Modifiers that are **carboxylic acids with bulky, sterically hindering groups adjacent to the carboxylate and lack additional coordinating sites** result in a **low yield**. Steric hindrance interferes with effective metal coordination.

    - Examples:
      - **(2S)-2-amino-3-phenylpropanoic acid** (Phenylalanine)
      - **4-pyridin-4-ylbenzoic acid**

11. **Rule 11**: Modifiers that are **carboxylic acids with perfluorinated alkyl chains** result in a **low yield**. The strong electron-withdrawing effect of fluorine atoms decreases the basicity of the carboxylate oxygen, weakening metal coordination.

    - Example:
      - **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**

12. **Rule 12**: Modifiers with **long polyether chains attached to the carboxylate group** result in a **low yield**. The flexibility and steric bulk of the ether chains reduce effective coordination due to entropic factors and steric hindrance.

    - Example:
      - **2-[2-(2-methoxyethoxy)ethoxy]acetic acid**

13. **Rule 13**: Modifiers that are **aliphatic carboxylic acids with medium-length (6-8 carbons) unbranched hydrocarbon chains without interfering functional groups** result in a **high yield**. The hydrophobic chains may enhance interactions with the catalyst framework.

    - Example:
      - **Octanoic acid**

14. **Rule 14**: Modifiers that are **amino acids with bulky side chains lacking additional coordinating groups**, such as aromatic rings without coordinating heteroatoms, result in a **low yield** due to steric hindrance.

    - Examples:
      - **(2S)-2-amino-3-phenylpropanoic acid** (Phenylalanine)
      - **(2R)-2-amino-3-(1H-indol-3-yl)propanoic acid** (Tryptophan)

15. **Rule 15**: Modifiers that are **thiol-containing aromatic carboxylic acids** result in a **high yield**. Thiol groups form strong bonds with metals, enhancing catalyst stability.

    - Example:
      - **4-sulfanylbenzoic acid**

**End of Rules**---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10,Rule 11,Rule 12,Rule 13,Rule 14,Rule 15
0,0,0,0,0,1,0,0,0,0,0,0,1,0,0
1,0,0,0,1,1,0,0,0,0,0,0,0,0,0
0,0,0,0,0,1,0,0,-1,0,0,0,0,0,0
1,0,0,0,1,1,0,0,0,0,0,0,0,0,0
0,0,0,0,0,1,0,-1,0,0,0,0,0,0,0
0,0,1,0,0,1,0,-1,-1,0,0,0,0,-1,0
0,0,0,0,0,1,0,0,0,0,0,0,1,0,0
0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
0,0,0,0,0,1,0,0,-1,0,0,0,0,0,0
0,0,0,0,0,1,0,0,0,0,0,0,1,0,0
0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1
0,0,0,0,0,1,0,0,0,0,0,-1,0,0,0
0,0,0,0,0,1,0,0,-1,0,0,0,0,0,0
0,0,0,0,1,1,0,0,0,0,0,0,0,-1,0
0,0,0,0,0,1,0,0,0,0,-1,0,0,0,0
0,0,0,1,1,1,0,0,0,0,0,0,0,-1,0
0,0,0,0,0,1,0,0,-1,0,0,0,0,0,0
0,0,0,0,0,1,0,0,-1,0,0,0,0,0,0
0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
0,0,0,0,0,1,-1,0,-1,0,0,0,0,0,0
0,0,0,0,0,1,-1,0,-1,0,0,0,0,0,0
0,0,0,0,0,1,0,0,-1,0,0,0,0,0,0
0,0,0,0,0,1,0,0,-1,0,0,0,0,0,0
0,0,0,0,0,1,0,0,-1,0,0,0,0,0,0
0,0,0,0,0,1,0,-1,0,0,0,0,0,0,0
0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
0,0,0,0,0,1,0,0,0,0,-1,0,0,0,0
0,0,0,0,0,1,0,0,0,0,0,0,1,0,0
0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
0,0,0,0,0,1,0,-1,0,0,0,0,1,0,0
0,0,0,0,0,1,0,-1,0,0,0,0,0,0,0
0,0,0,0,1,1,0,0,0,0,0,0,1,0,0
0,0,0,0,0,1,0,-1,0,0,0,0,1,0,0

---------------------------------------------------------------


    Train Accuracy: 0.8285714285714286; Test Accuracy: 0.0
    Train Support: 0.05142857142857143; Test Support: 0.0
    Train Confidence: 0.6933333333333332; Test Confidence: 0.45
    Train Lift: 1.3938997821350763; Test Lift: NONE
    Train Leverage: 0.009959183673469384; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    import pandas as pd
    from rdkit import Chem
    
    # Define SMARTS patterns for functional groups and substructures
    # General patterns
    carboxylic_acid = '[CX3](=O)[OX2H1]'
    carboxylate_anion = '[CX3](=O)[O-]'
    amino_group = '[NX3;H2]'
    aromatic_ring = '[$([a])]'
    nitro_group = '[NX3](=O)=O'
    halogens = '[F,Cl,Br,I]'
    nitro_aromatic = '[c][NX3](=O)=O'
    amino_aromatic = '[c][NX3;H2]'
    electron_withdrawing_groups = '[N+](=O)[O-],[CX3](=O)[OX1H0-,OX2H0-],[CX3](=O)[F,Cl,Br,I],[C#N],[S](=O)(=O)[O-],[S](=O)(=O)[OH],[P](=O)([OH])[OH]'
    electron_donating_groups = '[OX2H],[OX2][#6],[NX3;H2,H1][#6],[SX2H]'
    thiol_group = '[SX2H]'
    hydroxyl_group = '[OX2H]'
    aldehyde_group = '[CX3H1](=O)'
    ketone_group = '[CX3](=O)[#6]'
    ether_linkage = '[#6][OX2][#6]'
    pyridine_ring = '[n]1cccc1'
    aromatic_carboxylic_acid = '[c][CX3](=O)[OX1H0-,OX2H1]'
    aromatic_carboxylic_acid_para_sub = 'c1cc([#8]-[H])cc([CX3](=O)[OX1H0-,OX2H1])c1'

    # Compile SMARTS patterns
    smarts_patterns = {
        'carboxylic_acid': Chem.MolFromSmarts(carboxylic_acid),
        'carboxylate_anion': Chem.MolFromSmarts(carboxylate_anion),
        'amino_group': Chem.MolFromSmarts(amino_group),
        'aromatic_ring': Chem.MolFromSmarts(aromatic_ring),
        'nitro_group': Chem.MolFromSmarts(nitro_group),
        'halogens': Chem.MolFromSmarts(halogens),
        'nitro_aromatic': Chem.MolFromSmarts(nitro_aromatic),
        'amino_aromatic': Chem.MolFromSmarts(amino_aromatic),
        'thiol_group': Chem.MolFromSmarts(thiol_group),
        'hydroxyl_group': Chem.MolFromSmarts(hydroxyl_group),
        'aldehyde_group': Chem.MolFromSmarts(aldehyde_group),
        'ketone_group': Chem.MolFromSmarts(ketone_group),
        'ether_linkage': Chem.MolFromSmarts(ether_linkage),
        'pyridine_ring': Chem.MolFromSmarts(pyridine_ring),
        'aromatic_carboxylic_acid': Chem.MolFromSmarts(aromatic_carboxylic_acid),
        'aromatic_carboxylic_acid_para_sub': Chem.MolFromSmarts(aromatic_carboxylic_acid_para_sub),
    }
    
    # Define the rules with their associated patterns and predictions
    rules = [
        {
            'number': 1,
            'description': 'High yield: Amino acids with carboxylic acid side chains (e.g., aspartic acid, glutamic acid).',
            'patterns': [
                smarts_patterns['amino_group'],
                smarts_patterns['carboxylic_acid'],
            ],
            'count': {'carboxylic_acid': 2},  # At least two carboxylic acid groups
            'prediction': 1
        },
        {
            'number': 2,
            'description': 'High yield: Aromatic carboxylic acids with electron-withdrawing groups at the para position.',
            'patterns': [
                smarts_patterns['aromatic_carboxylic_acid'],
                smarts_patterns['nitro_aromatic'],
            ],
            'prediction': 1
        },
        {
            'number': 3,
            'description': 'High yield: Aromatic carboxylic acids with amino groups at the para position.',
            'patterns': [
                smarts_patterns['aromatic_carboxylic_acid'],
                smarts_patterns['amino_aromatic'],
            ],
            'prediction': 1
        },
        {
            'number': 4,
            'description': 'High yield: Heterocyclic carboxylic acids containing nitrogen atoms within the ring.',
            'patterns': [
                smarts_patterns['pyridine_ring'],
                smarts_patterns['carboxylic_acid'],
            ],
            'prediction': 1
        },
        {
            'number': 5,
            'description': 'High yield: Aliphatic carboxylic acids with proximal functional groups (amino, hydroxyl, or thiol) within three carbons of the carboxylate.',
            'patterns': [
                smarts_patterns['carboxylic_acid'],
                smarts_patterns['amino_group']
            ],
            'max_distance': 3,
            'prediction': 1
        },
        {
            'number': 6,
            'description': 'High yield: Carboxylic acids with adjacent hydroxyl or carbonyl groups capable of chelation.',
            'patterns': [
                smarts_patterns['carboxylic_acid'],
                smarts_patterns['hydroxyl_group'],
                smarts_patterns['ketone_group'],
            ],
            'adjacent': True,
            'prediction': 1
        },
        {
            'number': 7,
            'description': 'Low yield: Aromatic carboxylic acids with aldehyde (formyl) groups at the ortho or para position.',
            'patterns': [
                smarts_patterns['aromatic_carboxylic_acid'],
                smarts_patterns['aldehyde_group'],
            ],
            'prediction': -1
        },
        {
            'number': 8,
            'description': 'Low yield: Aliphatic carboxylic acids with distal functional groups (more than three carbons away from the carboxylate).',
            'patterns': [
                smarts_patterns['carboxylic_acid'],
                smarts_patterns['amino_group'],
            ],
            'min_distance': 4,
            'prediction': -1
        },
        {
            'number': 9,
            'description': 'Low yield: Aromatic carboxylic acids with electron-donating groups at the para position (excluding amino groups).',
            'patterns': [
                smarts_patterns['aromatic_carboxylic_acid'],
                smarts_patterns['hydroxyl_group'],
            ],
            'prediction': -1
        },
        {
            'number': 10,
            'description': 'Low yield: Carboxylic acids with bulky, sterically hindering groups adjacent to the carboxylate.',
            'patterns': [
                smarts_patterns['carboxylic_acid'],
                ],
            'bulky_groups': True,
            'prediction': -1
        },
        {
            'number': 11,
            'description': 'Low yield: Carboxylic acids with perfluorinated alkyl chains.',
            'patterns': [
                smarts_patterns['carboxylic_acid'],
            ],
            'perfluorinated_chain': True,
            'prediction': -1
        },
        {
            'number': 12,
            'description': 'Low yield: Modifiers with long polyether chains attached to the carboxylate group.',
            'patterns': [
                smarts_patterns['carboxylic_acid'],
                smarts_patterns['ether_linkage'],
            ],
            'long_chain': True,
            'prediction': -1
        },
        {
            'number': 13,
            'description': 'High yield: Aliphatic carboxylic acids with medium-length (6-8 carbons) unbranched hydrocarbon chains without interfering functional groups.',
            'patterns': [
                smarts_patterns['carboxylic_acid'],
            ],
            'chain_length': (6, 8),
            'prediction': 1
        },
        {
            'number': 14,
            'description': 'Low yield: Amino acids with bulky side chains lacking additional coordinating groups.',
            'patterns': [
                smarts_patterns['amino_group'],
                smarts_patterns['carboxylic_acid'],
            ],
            'bulky_side_chain': True,
            'prediction': -1
        },
        {
            'number': 15,
            'description': 'High yield: Thiol-containing aromatic carboxylic acids.',
            'patterns': [
                smarts_patterns['aromatic_carboxylic_acid'],
                smarts_patterns['thiol_group'],
            ],
            'prediction': 1
        },
    ]
    
    # Initialize results list
    results = []
    
    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*len(rules))
            continue
        row = []
        for rule in rules:
            try:
                match = True
                # Check for patterns
                for pattern in rule.get('patterns', []):
                    if not mol.HasSubstructMatch(pattern):
                        match = False
                        break
                if not match:
                    row.append(0)
                    continue
                # Additional checks
                if 'count' in rule:
                    for substruct_name, count in rule['count'].items():
                        substruct = smarts_patterns[substruct_name]
                        matches = mol.GetSubstructMatches(substruct)
                        if len(matches) < count:
                            match = False
                            break
                    if not match:
                        row.append(0)
                        continue
                if 'max_distance' in rule:
                    # Find shortest distance between carboxylic acid and functional group
                    ca_matches = mol.GetSubstructMatches(smarts_patterns['carboxylic_acid'])
                    fg_matches = mol.GetSubstructMatches(smarts_patterns['amino_group'])
                    distances = []
                    for ca in ca_matches:
                        for fg in fg_matches:
                            path_length = Chem.rdmolops.GetShortestPath(mol, ca[0], fg[0])
                            distances.append(len(path_length)-1)
                    if not distances or min(distances) > rule['max_distance']:
                        match = False
                if 'min_distance' in rule:
                    ca_matches = mol.GetSubstructMatches(smarts_patterns['carboxylic_acid'])
                    fg_matches = mol.GetSubstructMatches(smarts_patterns['amino_group'])
                    distances = []
                    for ca in ca_matches:
                        for fg in fg_matches:
                            path_length = Chem.rdmolops.GetShortestPath(mol, ca[0], fg[0])
                            distances.append(len(path_length)-1)
                    if not distances or min(distances) < rule['min_distance']:
                        match = False
                if 'adjacent' in rule and rule['adjacent']:
                    # Check if carboxylic acid is adjacent to hydroxyl or ketone group
                    ca_matches = mol.GetSubstructMatches(smarts_patterns['carboxylic_acid'])
                    adj_patterns = [smarts_patterns['hydroxyl_group'], smarts_patterns['ketone_group']]
                    adjacent = False
                    for ca in ca_matches:
                        for adj in adj_patterns:
                            adj_matches = mol.GetSubstructMatches(adj)
                            for am in adj_matches:
                                path_length = Chem.rdmolops.GetShortestPath(mol, ca[0], am[0])
                                if len(path_length)-1 == 1:
                                    adjacent = True
                                    break
                            if adjacent:
                                break
                        if adjacent:
                            break
                    if not adjacent:
                        match = False
                if 'bulky_groups' in rule and rule['bulky_groups']:
                    # Check for bulky groups adjacent to carboxylic acid
                    bulky_groups = ['[CX3](C)(C)C']  # Tertiary butyl group as example
                    bulky_match = False
                    for bg in bulky_groups:
                        bg_pat = Chem.MolFromSmarts(bg)
                        if mol.HasSubstructMatch(bg_pat):
                            bg_matches = mol.GetSubstructMatches(bg_pat)
                            ca_matches = mol.GetSubstructMatches(smarts_patterns['carboxylic_acid'])
                            for ca in ca_matches:
                                for bgm in bg_matches:
                                    path_length = Chem.rdmolops.GetShortestPath(mol, ca[0], bgm[0])
                                    if len(path_length)-1 == 1:
                                        bulky_match = True
                                        break
                                if bulky_match:
                                    break
                            if bulky_match:
                                break
                    if not bulky_match:
                        match = False
                if 'perfluorinated_chain' in rule and rule['perfluorinated_chain']:
                    # Check for perfluorinated alkyl chains
                    perfluoro_pat = Chem.MolFromSmarts('[CX4]([F])([F])[F]')
                    if not mol.HasSubstructMatch(perfluoro_pat):
                        match = False
                if 'long_chain' in rule and rule['long_chain']:
                    # Check for long polyether chains
                    polyether_pat = Chem.MolFromSmarts('OCCOCCO')
                    if not mol.HasSubstructMatch(polyether_pat):
                        match = False
                if 'chain_length' in rule:
                    # Check for unbranched hydrocarbon chains of specific length
                    chain_length_pat = Chem.MolFromSmarts('[C]' + ('[C]'*(rule['chain_length'][0]-1)))
                    if not mol.HasSubstructMatch(chain_length_pat):
                        match = False
                if 'bulky_side_chain' in rule and rule['bulky_side_chain']:
                    # Check for bulky side chains lacking additional coordinating groups
                    bulky_side_chains = ['c1ccccc1', 'c1ccncc1']  # Phenyl and pyridine rings
                    bulky_match = False
                    for bsc in bulky_side_chains:
                        bsc_pat = Chem.MolFromSmarts(bsc)
                        if mol.HasSubstructMatch(bsc_pat):
                            bulky_match = True
                            break
                    if not bulky_match:
                        match = False
                if match:
                    row.append(rule['prediction'])
                else:
                    row.append(0)
            except Exception as e:
                # In case of any error, append 0
                row.append(0)
        results.append(row)
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f'Rule {rule["number"]}' for rule in rules])
    return df

--------------------------------------------------
    Target Name: yield
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    After analyzing the dataset and considering the chemical properties of the molecular modifiers, here are refined rules that describe the relationship between the modifiers and the relative high or low yield of the reaction. These rules focus on combinations of functional groups and underlying physico-chemical properties to predict the yield outcome.

**Start of Rules**

1. **Rule 1**: Modifiers that are **short-chain aliphatic carboxylic acids** (five carbons or fewer) with an **amino group (-NH₂) or thiol group (-SH) within three carbons** of the carboxylic acid result in a **high yield**. These proximal functional groups enhance metal coordination through chelation.

   - Examples (**High Yield**):
     - **5-aminopentanoic acid**
     - **3-sulfanylpropanoic acid**

   - Non-examples (**Low Yield**):
     - **7-aminoheptanoic acid**
     - **8-aminooctanoic acid**
     - **7-hydroxyheptanoic acid**

2. **Rule 2**: Modifiers that are **amino acids containing both an amino group (-NH₂) and additional carboxylic acid groups (-COOH)**, such as **aspartic acid** and **glutamic acid**, result in a **high yield**. Multiple acidic groups enhance coordination with the metal center.

   - Examples:
     - **(2S)-2-aminobutanedioic acid** (Aspartic acid)
     - **(2S)-2-aminopentanedioic acid** (Glutamic acid)

3. **Rule 3**: Modifiers that are **aromatic carboxylic acids with electron-withdrawing groups (EWGs)**, such as **nitro (-NO₂)** or **bromoalkyl groups** at the **para position**, result in a **high yield**. EWGs increase the acidity of the carboxyl group, enhancing metal coordination.

   - Examples:
     - **4-nitrobenzoic acid**
     - **4-(bromomethyl)benzoic acid**

4. **Rule 4**: Modifiers that are **aromatic carboxylic acids with coordinating groups**, such as an **amino group (-NH₂)** at the **para position**, result in a **high yield**. These groups provide additional sites for metal binding.

   - Example:
     - **4-aminobenzoic acid**

5. **Rule 5**: Modifiers that are **medium to long-chain aliphatic carboxylic acids** (six carbons or more) **without additional functional groups** result in a **high yield**. The hydrophobic alkyl chain may enhance interactions with the catalyst's framework.

   - Example:
     - **Octanoic acid**

6. **Rule 6**: Modifiers that are **aromatic carboxylic acids with electron-donating groups (EDGs) that do not coordinate to metals**, such as **methyl (-CH₃)**, at the **para position** result in a **low yield**. EDGs decrease the acidity of the carboxyl group, weakening metal coordination.

   - Examples:
     - **4-methylbenzoic acid**
     - **3-(4-hydroxyphenyl)propanoic acid**

7. **Rule 7**: Modifiers that are **aromatic carboxylic acids with aldehyde (-CHO) groups conjugated to the ring** result in a **low yield**. Aldehyde groups can interfere with metal coordination or engage in side reactions.

   - Examples:
     - **4-formylbenzoic acid**
     - **5-formyl-2-hydroxybenzoic acid**

8. **Rule 8**: Modifiers that are **amino acids with bulky hydrophobic side chains lacking additional coordinating groups** result in a **low yield**. Steric hindrance reduces effective metal coordination.

   - Example:
     - **(2S)-2-amino-3-phenylpropanoic acid** (Phenylalanine)

9. **Rule 9**: Modifiers that are **heterocyclic carboxylic acids containing nitrogen atoms** in the ring result in a **high yield**. Nitrogen atoms act as additional coordination sites with the metal center.

   - Examples:
     - **Pyridine-3-carboxylic acid** (Nicotinic acid)
     - **1H-pyrazole-4-carboxylic acid**
     - **2-oxo-1H-pyridine-4-carboxylic acid**

10. **Rule 10**: Modifiers that are **aromatic carboxylic acids directly connected to another aromatic ring without flexible linkers** result in a **low yield**. The rigid structure may limit effective coordination due to steric hindrance.

    - Example:
      - **4-pyridin-4-ylbenzoic acid**

11. **Rule 11**: Modifiers that are **aliphatic carboxylic acids with distal functional groups** (functional groups located **more than three carbons away** from the carboxylic acid) result in a **low yield**. Distant functional groups are less effective for chelation.

    - Examples:
      - **7-aminoheptanoic acid**
      - **8-aminooctanoic acid**
      - **7-hydroxyheptanoic acid**

12. **Rule 12**: Modifiers that contain **perfluoroalkyl chains** result in a **low yield**. Strong electron-withdrawing effects decrease the basicity of the carboxylate oxygen, weakening metal coordination.

    - Example:
      - **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**

13. **Rule 13**: Modifiers that contain **amide bonds or peptide linkages** result in a **low yield**. Amide groups can compete with carboxylate groups for metal coordination, reducing binding efficiency.

    - Examples:
      - **(2S)-6-acetamido-2-aminohexanoic acid**
      - **2-[[(2S)-2-amino-4-methylsulfanylbutanoyl]amino]acetic acid**

14. **Rule 14**: Modifiers that are **aliphatic carboxylic acids with long flexible polyether chains** result in a **low yield**. The flexibility and steric bulk reduce effective coordination due to entropic factors and steric hindrance.

    - Example:
      - **2-[2-(2-methoxyethoxy)ethoxy]acetic acid**

15. **Rule 15**: Modifiers that are **aromatic carboxylic acids with hydroxyl (-OH) groups at positions enabling intramolecular hydrogen bonding** (e.g., **ortho** to the carboxyl group) result in a **low yield**. Intramolecular hydrogen bonding reduces the availability of functional groups for metal coordination.

    - Examples:
      - **5-formyl-2-hydroxybenzoic acid**
      - **2-[(4-hydroxybenzoyl)amino]acetic acid**

**End of Rules**

These rules combine multiple functional groups and consider the physico-chemical properties that influence metal coordination and catalyst activity. They aim to predict the yield outcome based on structural features of the modifiers:

- **High Yield Modifiers**:
  - Contain functional groups that enhance metal binding through chelation (e.g., proximal amino, thiol groups).
  - Have electron-withdrawing groups that increase carboxylate acidity and coordination strength.
  - Feature heteroaromatic rings with nitrogen atoms offering additional coordination sites.
  - Include medium to long-chain aliphatic carboxylic acids without interfering functional groups, potentially enhancing hydrophobic interactions.

- **Low Yield Modifiers**:
  - Possess functional groups that decrease carboxylate basicity (e.g., perfluoroalkyl chains) or compete with carboxylate coordination (amide bonds).
  - Have bulky or inflexible structures causing steric hindrance.
  - Contain functional groups positioned ineffectively for coordination (distal functional groups).
  - Feature electron-donating groups that do not coordinate with metals, weakening carboxylate coordination.

By applying these rules, one can predict whether a given SMILES structure is likely to result in a high or low yield in the reaction based on its structural features.---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10,Rule 11,Rule 12,Rule 13,Rule 14,Rule 15
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0
0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.7142857142857143; Test Accuracy: 0.0
    Train Support: 0.0761904761904762; Test Support: 0.0
    Train Confidence: 1.0; Test Confidence: 0.5
    Train Lift: 2.0588235294117645; Test Lift: NONE
    Train Leverage: 0.039183673469387746; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    from rdkit import Chem
    import pandas as pd

    # Define SMARTS patterns for functional groups
    patterns = {
        'carboxylic_acid': '[CX3](=O)[OX1H1]',
        'primary_amine': '[NX3H2]',
        'thiol': '[SX2H]',
        'aromatic': '[a]',
        'aromatic_ring': 'c1ccccc1',
        'nitro_group': '[NX3](=O)[OX1-]',
        'halogen': '[F,Cl,Br,I]',
        'amino_group': '[NX3H2,NX3H1]',
        'aromatic_amino_group': '[c][NX3H2,NX3H1]',
        'hydroxyl_group': '[OX2H]',
        'aromatic_hydroxyl': '[c][OX2H]',
        'aldehyde_group': '[CX3H1](=O)[#6]',
        'amide_bond': '[NX3][CX3](=O)[#6]',
        'nitrogen_heterocycle': '[n]',
        'perfluoroalkyl': '[CX4]([F])([F])([F])',
        'long_aliphatic_chain': '[CH2][CH2][CH2][CH2][CH2]',
        'ether_linkage': '[#6][OX2][#6]',
        # Additional patterns as needed
    }

    # Compile patterns
    compiled_patterns = {name: Chem.MolFromSmarts(s) for name, s in patterns.items()}

    num_rules = 15
    # Initialize results list
    results = []

    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If unable to parse, append zeros
            results.append([0]*num_rules)
            continue

        # Initialize list to hold the rule results for this molecule
        rule_results = []

        ##### Rule 1 #####
        # High Yield (1): Short-chain aliphatic carboxylic acids (≤5 carbons) with an amino (-NH2) or thiol (-SH) group within 3 atoms of the carboxylic acid.
        # Check if molecule is aliphatic (no aromatic atoms)
        if not mol.HasSubstructMatch(compiled_patterns['aromatic']):
            # Count number of carbons
            num_carbons = sum(1 for atom in mol.GetAtoms() if atom.GetAtomicNum() == 6)
            if num_carbons <= 5:
                # Find carboxylic acid groups
                ca_matches = mol.GetSubstructMatches(compiled_patterns['carboxylic_acid'])
                # Find amino groups
                amino_matches = mol.GetSubstructMatches(compiled_patterns['primary_amine'])
                # Find thiol groups
                thiol_matches = mol.GetSubstructMatches(compiled_patterns['thiol'])
                # For each carboxylic acid group, check if there is an amino or thiol group within 3 bonds
                found = False
                for ca_match in ca_matches:
                    ca_atom_idx = ca_match[0]  # Carbon atom of carboxylic acid
                    for group_matches in [amino_matches, thiol_matches]:
                        for group_match in group_matches:
                            group_atom_idx = group_match[0]  # Atom index of N or S
                            path = Chem.GetShortestPath(mol, ca_atom_idx, group_atom_idx)
                            if len(path) - 1 <= 3:
                                found = True
                                break
                        if found:
                            break
                    if found:
                        break
                if found:
                    rule_results.append(1)
                else:
                    rule_results.append(0)
            else:
                rule_results.append(0)
        else:
            rule_results.append(0)

        ##### Rule 2 #####
        # High Yield (1): Amino acids containing both an amino group (-NH2) and additional carboxylic acid groups (-COOH)
        ca_matches = mol.GetSubstructMatches(compiled_patterns['carboxylic_acid'])
        num_ca = len(ca_matches)
        if num_ca >= 2 and mol.HasSubstructMatch(compiled_patterns['primary_amine']):
            rule_results.append(1)
        else:
            rule_results.append(0)

        ##### Rule 3 #####
        # High Yield (1): Aromatic carboxylic acids with electron-withdrawing groups (EWGs) at the para position
        # Simplify by checking for aromatic carboxylic acid with nitro or halogen groups
        if mol.HasSubstructMatch(Chem.MolFromSmarts('c1ccc([CX3](=O)[OX1H1])cc1')):
            nitro_on_ring = mol.HasSubstructMatch(compiled_patterns['nitro_group'])
            halogen_on_ring = mol.HasSubstructMatch(compiled_patterns['halogen'])
            if nitro_on_ring or halogen_on_ring:
                rule_results.append(1)
            else:
                rule_results.append(0)
        else:
            rule_results.append(0)

        ##### Rule 4 #####
        # High Yield (1): Aromatic carboxylic acids with coordinating groups such as an amino group (-NH2) at the para position
        if mol.HasSubstructMatch(Chem.MolFromSmarts('c1ccc([CX3](=O)[OX1H1])cc1')):
            amino_on_ring = mol.HasSubstructMatch(compiled_patterns['aromatic_amino_group'])
            if amino_on_ring:
                rule_results.append(1)
            else:
                rule_results.append(0)
        else:
            rule_results.append(0)

        ##### Rule 5 #####
        # High Yield (1): Medium to long-chain aliphatic carboxylic acids (≥6 carbons) without additional functional groups
        if not mol.HasSubstructMatch(compiled_patterns['aromatic']):
            num_carbons = sum(1 for atom in mol.GetAtoms() if atom.GetAtomicNum() == 6)
            if num_carbons >= 6:
                # Exclude if molecule has other functional groups besides carboxylic acid
                non_carboxylic_functional_groups = ['primary_amine', 'thiol', 'hydroxyl_group', 'ether_linkage', 'amide_bond']
                has_other_functional_group = False
                for group in non_carboxylic_functional_groups:
                    if mol.HasSubstructMatch(compiled_patterns[group]):
                        has_other_functional_group = True
                        break
                if not has_other_functional_group:
                    rule_results.append(1)
                else:
                    rule_results.append(0)
            else:
                rule_results.append(0)
        else:
            rule_results.append(0)

        ##### Rule 6 #####
        # Low Yield (-1): Aromatic carboxylic acids with electron-donating groups (EDGs) that do not coordinate to metals at the para position
        if mol.HasSubstructMatch(Chem.MolFromSmarts('c1ccc([CX3](=O)[OX1H1])cc1')):
            # Check for methoxy or methyl groups at para position
            edg_patterns = ['c1ccc([CX3](=O)[OX1H1])cc1[CH3]', 'c1ccc([CX3](=O)[OX1H1])cc1[OX2][CH3]']
            has_edg = any(mol.HasSubstructMatch(Chem.MolFromSmarts(pat)) for pat in edg_patterns)
            if has_edg:
                rule_results.append(-1)
            else:
                rule_results.append(0)
        else:
            rule_results.append(0)

        ##### Rule 7 #####
        # Low Yield (-1): Aromatic carboxylic acids with aldehyde (-CHO) groups conjugated to the ring
        if mol.HasSubstructMatch(compiled_patterns['aldehyde_group']) and mol.HasSubstructMatch(compiled_patterns['aromatic_ring']):
            rule_results.append(-1)
        else:
            rule_results.append(0)

        ##### Rule 8 #####
        # Low Yield (-1): Amino acids with bulky hydrophobic side chains lacking additional coordinating groups
        # Simplify by checking for amino acids with aromatic side chains (e.g., phenylalanine)
        if mol.HasSubstructMatch(compiled_patterns['primary_amine']) and mol.HasSubstructMatch(compiled_patterns['carboxylic_acid']):
            if mol.HasSubstructMatch(compiled_patterns['aromatic_ring']):
                rule_results.append(-1)
            else:
                rule_results.append(0)
        else:
            rule_results.append(0)

        ##### Rule 9 #####
        # High Yield (1): Heterocyclic carboxylic acids containing nitrogen atoms in the ring
        if mol.HasSubstructMatch(compiled_patterns['nitrogen_heterocycle']) and mol.HasSubstructMatch(compiled_patterns['carboxylic_acid']):
            rule_results.append(1)
        else:
            rule_results.append(0)

        ##### Rule 10 #####
        # Low Yield (-1): Aromatic carboxylic acids directly connected to another aromatic ring without flexible linkers
        # Check for biphenyl carboxylic acids
        if mol.HasSubstructMatch(Chem.MolFromSmarts('c1ccccc1c2ccccc2[CX3](=O)[OX1H1]')):
            rule_results.append(-1)
        else:
            rule_results.append(0)

        ##### Rule 11 #####
        # Low Yield (-1): Aliphatic carboxylic acids with distal functional groups (>3 carbons away from COOH)
        if mol.HasSubstructMatch(compiled_patterns['carboxylic_acid']):
            # Find carboxylic acid carbon
            ca_matches = mol.GetSubstructMatches(compiled_patterns['carboxylic_acid'])
            ca_atom_idx = ca_matches[0][0] if ca_matches else None
            # Find functional groups
            functional_groups = ['primary_amine', 'thiol', 'hydroxyl_group']
            distant = False
            for group in functional_groups:
                group_matches = mol.GetSubstructMatches(compiled_patterns[group])
                for match in group_matches:
                    group_atom_idx = match[0]
                    path = Chem.GetShortestPath(mol, ca_atom_idx, group_atom_idx)
                    if len(path) - 1 > 3:
                        distant = True
                        break
                if distant:
                    break
            if distant:
                rule_results.append(-1)
            else:
                rule_results.append(0)
        else:
            rule_results.append(0)

        ##### Rule 12 #####
        # Low Yield (-1): Modifiers containing perfluoroalkyl chains
        if mol.HasSubstructMatch(compiled_patterns['perfluoroalkyl']):
            rule_results.append(-1)
        else:
            rule_results.append(0)

        ##### Rule 13 #####
        # Low Yield (-1): Modifiers containing amide bonds or peptide linkages
        if mol.HasSubstructMatch(compiled_patterns['amide_bond']):
            rule_results.append(-1)
        else:
            rule_results.append(0)

        ##### Rule 14 #####
        # Low Yield (-1): Aliphatic carboxylic acids with long flexible polyether chains
        if mol.HasSubstructMatch(compiled_patterns['carboxylic_acid']) and mol.HasSubstructMatch(compiled_patterns['ether_linkage']):
            rule_results.append(-1)
        else:
            rule_results.append(0)

        ##### Rule 15 #####
        # Low Yield (-1): Aromatic carboxylic acids with hydroxyl (-OH) groups enabling intramolecular hydrogen bonding (e.g., ortho to the COOH)
        # Check for ortho-hydroxyl benzoic acids
        if mol.HasSubstructMatch(Chem.MolFromSmarts('c1cc([OX2H])cc([CX3](=O)[OX1H1])c1')):
            rule_results.append(-1)
        else:
            rule_results.append(0)

        # Ensure the rule_results list has the correct number of rules
        if len(rule_results) != num_rules:
            rule_results.extend([0]*(num_rules - len(rule_results)))

        # Append the rule results for this molecule
        results.append(rule_results)

    # Create DataFrame
    df = pd.DataFrame(results, columns=[f'Rule {i+1}' for i in range(num_rules)])

    return df

--------------------------------------------------
    Target Name: yield
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

1. **Rule 1**: Modifiers that are **aliphatic carboxylic acids with an amino group (-NH₂) or thiol group (-SH) within three carbons of the carboxylic acid** result in a **high yield**. The proximity of these functional groups to the carboxyl group allows for effective chelation with the metal center, enhancing catalyst activity.

   - **Examples (High Yield)**:
     - **5-aminopentanoic acid**
     - **3-sulfanylpropanoic acid**
     - **(2S)-2-aminobutanedioic acid** (Aspartic acid)
     - **(2S)-2-aminopentanedioic acid** (Glutamic acid)

   - **Non-examples (Low Yield)**:
     - **7-aminoheptanoic acid**
     - **8-aminooctanoic acid**
     - **7-hydroxyheptanoic acid**

2. **Rule 2**: Modifiers that are **aromatic carboxylic acids with electron-withdrawing groups (EWGs)** such as **nitro (-NO₂)** or **bromo (-Br)** at the **para position** result in a **high yield**. EWGs increase the acidity of the carboxyl group, enhancing metal coordination.

   - **Examples (High Yield)**:
     - **4-nitrobenzoic acid**
     - **4-(bromomethyl)benzoic acid**

   - **Non-examples (Low Yield)**:
     - **4-methylbenzoic acid** (contains an electron-donating group)

3. **Rule 3**: Modifiers that are **heterocyclic carboxylic acids containing nitrogen atoms** in the ring result in a **high yield**. The nitrogen atoms act as additional coordination sites, strengthening interaction with the metal center.

   - **Examples (High Yield)**:
     - **Pyridine-3-carboxylic acid** (Nicotinic acid)
     - **1H-pyrazole-4-carboxylic acid**
     - **2-oxo-1H-pyridine-4-carboxylic acid**

   - **Non-examples (Low Yield)**:
     - **4-pyridin-4-ylbenzoic acid** (sterically hindered biphenyl structure)

4. **Rule 4**: Modifiers that are **aromatic carboxylic acids with an amino group (-NH₂) or hydroxyl group (-OH) at the para position** result in a **high yield**. These groups provide additional coordination capability with the metal center.

   - **Examples (High Yield)**:
     - **4-aminobenzoic acid**
     - **5-(4-hydroxyphenyl)pentanoic acid**

   - **Non-examples (Low Yield)**:
     - **3-(4-hydroxyphenyl)propanoic acid** (hydroxyl group is not at the para position relative to the carboxyl group)

5. **Rule 5**: Modifiers that are **medium-chain aliphatic carboxylic acids** (chains of **six to eight carbons**) **without additional interfering functional groups** result in a **high yield**. The hydrophobic alkyl chains may enhance interactions within the catalyst framework.

   - **Example (High Yield)**:
     - **Octanoic acid**

   - **Non-examples (Low Yield)**:
     - **Perfluorinated acids** (e.g., **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**)

6. **Rule 6**: Modifiers that are **aromatic carboxylic acids with electron-donating groups (EDGs) like methyl (-CH₃), methoxy (-OCH₃), or hydroxyl (-OH) at the para position**, without additional coordinating groups, result in a **low yield**. EDGs decrease the acidity of the carboxyl group, weakening metal coordination.

   - **Examples (Low Yield)**:
     - **4-methylbenzoic acid**
     - **3-(4-hydroxyphenyl)propanoic acid**

7. **Rule 7**: Modifiers that are **aromatic carboxylic acids with aldehyde (-CHO) or formyl groups conjugated to the ring** result in a **low yield**. Aldehyde groups can interfere with metal coordination or undergo side reactions.

   - **Examples (Low Yield)**:
     - **4-formylbenzoic acid**
     - **5-formyl-2-hydroxybenzoic acid**

8. **Rule 8**: Modifiers that contain **perfluoroalkyl chains** result in a **low yield**. The strong electron-withdrawing effect of fluorine atoms reduces the basicity of the carboxylate oxygen, weakening its ability to coordinate with the metal.

   - **Example (Low Yield)**:
     - **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**

9. **Rule 9**: Modifiers with **amide bonds or peptide linkages** near the carboxyl group result in a **low yield**. Amide groups can act as competing ligands, reducing the effectiveness of metal coordination by the carboxylate.

   - **Examples (Low Yield)**:
     - **(2S)-6-acetamido-2-aminohexanoic acid**
     - **2-[[(2S)-2-amino-4-methylsulfanylbutanoyl]amino]acetic acid**

10. **Rule 10**: Modifiers that are **aliphatic carboxylic acids with long flexible polyether chains** result in a **low yield**. The flexibility and steric bulk of polyether chains hinder effective coordination due to entropic factors and steric hindrance.

    - **Example (Low Yield)**:
      - **2-[2-(2-methoxyethoxy)ethoxy]acetic acid**

11. **Rule 11**: Modifiers that are **aromatic carboxylic acids directly connected to another aromatic ring without flexible linkers** result in a **low yield**. The rigid, bulky structure may cause steric hindrance, limiting effective metal coordination.

    - **Example (Low Yield)**:
      - **4-pyridin-4-ylbenzoic acid**

12. **Rule 12**: Modifiers that have **functional groups capable of chelation (e.g., ketone, hydroxyl, thiol groups) within conjugated systems** result in a **high yield**. These groups enhance metal binding through multiple coordination sites.

    - **Examples (High Yield)**:
      - **1,3-dioxo-2-benzofuran-5-carboxylic acid**
      - **2-oxo-1H-pyridine-4-carboxylic acid**
      - **3-sulfanylpropanoic acid**

    - **Non-examples (Low Yield)**:
      - **2-[(4-hydroxybenzoyl)amino]acetic acid** (hydroxyl group involved in intramolecular hydrogen bonding)

13. **Rule 13**: Modifiers that are **aliphatic carboxylic acids with distal functional groups** (functional groups located **more than three carbons away** from the carboxylic acid) result in a **low yield**. Distant functional groups are less effective in participating in chelation.

    - **Examples (Low Yield)**:
      - **7-aminoheptanoic acid**
      - **8-aminooctanoic acid**
      - **7-hydroxyheptanoic acid**

14. **Rule 14**: Modifiers that contain **intramolecular hydrogen bonding** due to **ortho-substituted hydroxyl (-OH) or formyl (-CHO) groups** in aromatic carboxylic acids result in a **low yield**. Intramolecular hydrogen bonding reduces the availability of these groups for metal coordination.

    - **Examples (Low Yield)**:
      - **5-formyl-2-hydroxybenzoic acid**
      - **2-[(4-hydroxybenzoyl)amino]acetic acid**

15. **Rule 15**: Modifiers that are **amino acids with bulky hydrophobic side chains lacking additional coordinating groups** result in a **low yield**. Steric hindrance from the bulky side chains reduces effective metal coordination.

    - **Example (Low Yield)**:
      - **(2S)-2-amino-3-phenylpropanoic acid** (Phenylalanine)

**End of Rules**

These rules combine multiple functional groups and consider the underlying physico-chemical properties that influence metal coordination and catalyst activity:

- **High Yield Modifiers**:
  - Feature functional groups (amino, thiol, ketone) proximal to the carboxyl group for effective chelation.
  - Contain electron-withdrawing groups that enhance carboxylate acidity and coordination strength.
  - Include heterocyclic rings with nitrogen atoms providing additional coordination sites.
  - Have medium-length aliphatic chains without interfering functional groups, potentially enhancing hydrophobic interactions within the catalyst.

- **Low Yield Modifiers**:
  - Possess functional groups that decrease carboxylate basicity (e.g., perfluoroalkyl chains) or compete with carboxylate coordination (amide bonds).
  - Contain electron-donating groups that weaken metal coordination.
  - Have bulky or inflexible structures causing steric hindrance.
  - Feature distal functional groups ineffective for chelation.
  - Include intramolecular hydrogen bonding that reduces availability of coordinating groups.

By applying these rules, we can predict whether a given molecular modifier will result in a high or low yield based on its structural features. The rules prioritize broader coverage of the dataset and balance simplicity with complexity to capture the key factors affecting the reaction yield.---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10,Rule 11,Rule 12,Rule 13,Rule 14,Rule 15
0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0
1,0,0,0,0,0,0,0,0,0,0,1,-1,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,1,0,0,0
0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,1,0,0,0,0,0,0,1,0,0,0
0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,-1,0,1,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,-1,0,0,0,1,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,1,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,1,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,-1,0,0,1,-1,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,-1,0,0,0,1,0,0,0
0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0
0,0,0,0,0,0,0,0,0,-1,0,1,-1,0,0
1,0,0,0,0,0,0,0,0,0,0,1,0,0,0
0,0,0,0,0,0,0,0,0,0,0,1,-1,0,0

---------------------------------------------------------------


    Train Accuracy: 0.6285714285714286; Test Accuracy: 0.0
    Train Support: 0.05714285714285714; Test Support: 0.0
    Train Confidence: 1.0; Test Confidence: 0.5
    Train Lift: 2.0588235294117645; Test Lift: NONE
    Train Leverage: 0.02938775510204081; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    # Import necessary RDKit modules
    from rdkit import Chem
    from rdkit.Chem import rdMolDescriptors
    
    # Define SMARTS patterns for functional groups and substructures
    carboxylic_acid = Chem.MolFromSmarts('[CX3](=O)[OX2H1]')  # Carboxylic acid group
    amino_group = Chem.MolFromSmarts('[NX3H2]')  # Primary amine group (-NH2)
    thiol_group = Chem.MolFromSmarts('[SX2H]')  # Thiol group (-SH)
    aromatic_ring = Chem.MolFromSmarts('a')  # Aromatic atom
    nitro_group = Chem.MolFromSmarts('[NX3](=O)[O-]')  # Nitro group
    bromo_aromatic = Chem.MolFromSmarts('cBr')  # Bromine attached to aromatic carbon
    pyridine_ring = Chem.MolFromSmarts('n1ccccc1')  # Pyridine ring
    hydroxyl_group = Chem.MolFromSmarts('[OX2H]')  # Hydroxyl group (-OH)
    aldehyde_group = Chem.MolFromSmarts('[CX3H1](=O)[#6]')  # Aldehyde group
    perfluoroalkyl_chain = Chem.MolFromSmarts('C(F)(F)F')  # Trifluoromethyl group as proxy
    amide_bond = Chem.MolFromSmarts('[CX3](=O)[NX3]')  # Amide bond
    ether_linkage = Chem.MolFromSmarts('[CX4][OX2][CX4]')  # Ether linkage
    aromatic_amino_group = Chem.MolFromSmarts('c[NX3H2]')  # Amino group attached to aromatic ring
    aliphatic_chain = Chem.MolFromSmarts('[CX4H2][CX4H2][CX4H2][CX4H2][CX4H2][CX4H2]')  # Chain of at least 6 carbons
    keto_group = Chem.MolFromSmarts('[CX3](=O)[#6]')  # Ketone group
    chelating_group = Chem.MolFromSmarts('[#6]=[O,S,N]')  # Conjugated ketone, thioketone, or imine
    ortho_hydroxyl = Chem.MolFromSmarts('c1cc([OX2H])ccc1C(=O)[OX2H1]')  # Ortho-hydroxyl in aromatic carboxylic acid
    bulky_side_chain = Chem.MolFromSmarts('[CX4H]([#6])([#6])[#6]')  # Tertiary carbon as proxy for bulky group
    
    # Initialize list to store results for each molecule
    results = []
    
    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*15)
            continue
        row = []
        try:
            # Rule 1: Aliphatic carboxylic acids with amino (-NH2) or thiol (-SH) within three carbons of carboxylic acid
            match_rule1 = False
            ca_atoms = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid)]
            amino_atoms = [match[0] for match in mol.GetSubstructMatches(amino_group)]
            thiol_atoms = [match[0] for match in mol.GetSubstructMatches(thiol_group)]
            for ca_atom in ca_atoms:
                for func_atom in amino_atoms + thiol_atoms:
                    path_length = Chem.GetShortestPath(mol, ca_atom, func_atom)
                    if len(path_length) - 1 <= 4:  # Within three bonds
                        match_rule1 = True
                        break
                if match_rule1:
                    break
            row.append(1 if match_rule1 else 0)
            
            # Rule 2: Aromatic carboxylic acids with EWGs (nitro or bromo) at para position
            match_rule2 = False
            for ring in mol.GetRingInfo().AtomRings():
                if len(ring) == 6:  # Benzene ring
                    substituents = {}
                    for atom_idx in ring:
                        atom = mol.GetAtomWithIdx(atom_idx)
                        for neighbor in atom.GetNeighbors():
                            if neighbor.GetIdx() not in ring:
                                if neighbor.HasSubstructMatch(carboxylic_acid):
                                    substituents['carboxylic_acid'] = atom_idx
                                elif neighbor.HasSubstructMatch(nitro_group) or neighbor.HasSubstructMatch(bromo_aromatic):
                                    substituents['EWG'] = atom_idx
                    if 'carboxylic_acid' in substituents and 'EWG' in substituents:
                        idx_diff = abs(ring.index(substituents['carboxylic_acid']) - ring.index(substituents['EWG']))
                        if idx_diff == 3 or idx_diff == 0:
                            match_rule2 = True
                            break
            row.append(1 if match_rule2 else 0)
            
            # Rule 3: Heterocyclic carboxylic acids containing nitrogen atoms in the ring
            match_rule3 = False
            if mol.HasSubstructMatch(pyridine_ring) and mol.HasSubstructMatch(carboxylic_acid):
                match_rule3 = True
            row.append(1 if match_rule3 else 0)
            
            # Rule 4: Aromatic carboxylic acids with amino (-NH2) or hydroxyl (-OH) at para position
            match_rule4 = False
            for ring in mol.GetRingInfo().AtomRings():
                if len(ring) == 6:
                    substituents = {}
                    for atom_idx in ring:
                        atom = mol.GetAtomWithIdx(atom_idx)
                        for neighbor in atom.GetNeighbors():
                            if neighbor.GetIdx() not in ring:
                                if neighbor.HasSubstructMatch(carboxylic_acid):
                                    substituents['carboxylic_acid'] = atom_idx
                                elif neighbor.HasSubstructMatch(amino_group) or neighbor.HasSubstructMatch(hydroxyl_group):
                                    substituents['donor_group'] = atom_idx
                    if 'carboxylic_acid' in substituents and 'donor_group' in substituents:
                        idx_diff = abs(ring.index(substituents['carboxylic_acid']) - ring.index(substituents['donor_group']))
                        if idx_diff == 3 or idx_diff == 0:
                            match_rule4 = True
                            break
            row.append(1 if match_rule4 else 0)
            
            # Rule 5: Medium-chain aliphatic carboxylic acids (6-8 carbons) without interfering functional groups
            match_rule5 = False
            if mol.HasSubstructMatch(carboxylic_acid):
                num_carbons = len([atom for atom in mol.GetAtoms() if atom.GetAtomicNum() == 6])
                num_heteroatoms = len([atom for atom in mol.GetAtoms() if atom.GetAtomicNum() != 1 and atom.GetAtomicNum() != 6])
                if 6 <= num_carbons <= 8 and num_heteroatoms == 2:  # Only carboxylic acid oxygens
                    match_rule5 = True
            row.append(1 if match_rule5 else 0)
            
            # Rule 6: Aromatic carboxylic acids with EDGs (-CH3, -OCH3, -OH) at para position without additional coordinating groups
            match_rule6 = False
            match_rule6 = mol.HasSubstructMatch(Chem.MolFromSmarts('c1ccc(cc1)[CX4H3,OX2H,OX2][CH3]'))
            row.append(-1 if match_rule6 else 0)
            
            # Rule 7: Aromatic carboxylic acids with aldehyde (-CHO) or formyl groups conjugated to the ring
            match_rule7 = False
            if mol.HasSubstructMatch(aldehyde_group) and mol.HasSubstructMatch(aromatic_ring):
                match_rule7 = True
            row.append(-1 if match_rule7 else 0)
            
            # Rule 8: Modifiers that contain perfluoroalkyl chains
            match_rule8 = False
            if mol.HasSubstructMatch(perfluoroalkyl_chain):
                match_rule8 = True
            row.append(-1 if match_rule8 else 0)
            
            # Rule 9: Modifiers with amide bonds or peptide linkages near the carboxyl group
            match_rule9 = False
            if mol.HasSubstructMatch(amide_bond) and mol.HasSubstructMatch(carboxylic_acid):
                ca_atoms = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid)]
                amide_atoms = [match[0] for match in mol.GetSubstructMatches(amide_bond)]
                for ca_atom in ca_atoms:
                    for am_atom in amide_atoms:
                        path_length = Chem.GetShortestPath(mol, ca_atom, am_atom)
                        if len(path_length) - 1 <= 3:
                            match_rule9 = True
                            break
                    if match_rule9:
                        break
            row.append(-1 if match_rule9 else 0)
            
            # Rule 10: Aliphatic carboxylic acids with long flexible polyether chains
            match_rule10 = False
            if mol.HasSubstructMatch(ether_linkage) and mol.HasSubstructMatch(carboxylic_acid):
                num_ethers = len(mol.GetSubstructMatches(ether_linkage))
                if num_ethers >= 2:
                    match_rule10 = True
            row.append(-1 if match_rule10 else 0)
            
            # Rule 11: Aromatic carboxylic acids directly connected to another aromatic ring without flexible linkers
            match_rule11 = False
            biphenyl_pattern = Chem.MolFromSmarts('c1ccccc1c2ccccc2C(=O)O')
            if mol.HasSubstructMatch(biphenyl_pattern):
                match_rule11 = True
            row.append(-1 if match_rule11 else 0)
            
            # Rule 12: Modifiers with chelating groups within conjugated systems
            match_rule12 = False
            if mol.HasSubstructMatch(chelating_group) and mol.HasSubstructMatch(carboxylic_acid):
                match_rule12 = True
            row.append(1 if match_rule12 else 0)
            
            # Rule 13: Aliphatic carboxylic acids with distal functional groups (>3 carbons away)
            match_rule13 = False
            func_groups = amino_atoms + thiol_atoms + [match[0] for match in mol.GetSubstructMatches(hydroxyl_group)]
            for ca_atom in ca_atoms:
                for func_atom in func_groups:
                    path_length = Chem.GetShortestPath(mol, ca_atom, func_atom)
                    if len(path_length) - 1 > 4:
                        match_rule13 = True
                        break
                if match_rule13:
                    break
            row.append(-1 if match_rule13 else 0)
            
            # Rule 14: Modifiers with intramolecular hydrogen bonding due to ortho-substituted hydroxyl or formyl groups
            match_rule14 = False
            if mol.HasSubstructMatch(ortho_hydroxyl):
                match_rule14 = True
            row.append(-1 if match_rule14 else 0)
            
            # Rule 15: Amino acids with bulky hydrophobic side chains lacking additional coordinating groups
            match_rule15 = False
            if mol.HasSubstructMatch(bulky_side_chain) and mol.HasSubstructMatch(carboxylic_acid) and mol.HasSubstructMatch(amino_group):
                match_rule15 = True
            row.append(-1 if match_rule15 else 0)
            
        except Exception as e:
            # In case of any error, append zeros
            row = [0]*15
        results.append(row)
    
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f'Rule {i+1}' for i in range(15)])
    return df

--------------------------------------------------
    Target Name: yield
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

1. **Rule 1**: Modifiers that are **aliphatic carboxylic acids with an amino group (-NH₂) or thiol group (-SH) located within three carbons of the carboxyl group** result in a **high yield**. The proximity of these functional groups enhances chelation with metal centers, improving catalytic activity.

   - **Examples (High Yield)**:
     - **5-aminopentanoic acid**
     - **3-sulfanylpropanoic acid**
     - **(2S)-2-aminobutanedioic acid** (Aspartic acid)
     - **(2S)-2-aminopentanedioic acid** (Glutamic acid)
   - **Non-examples (Low Yield)**:
     - **7-aminoheptanoic acid** (functional group too distant)
     - **8-aminooctanoic acid**

2. **Rule 2**: Modifiers that are **aromatic carboxylic acids with a para-substituted amino (-NH₂) or hydroxyl (-OH) group directly attached to the ring** result in a **high yield**. These groups provide additional coordination sites, enhancing metal binding.

   - **Examples (High Yield)**:
     - **4-aminobenzoic acid**
     - **5-(4-hydroxyphenyl)pentanoic acid**
   - **Non-examples (Low Yield)**:
     - **3-(4-hydroxyphenyl)propanoic acid** (short linker reduces flexibility)
     - **2-[(4-hydroxybenzoyl)amino]acetic acid** (interfering amide linkage)

3. **Rule 3**: Modifiers that are **aromatic carboxylic acids with para-substituted electron-withdrawing groups (-NO₂, -CH₂Br)** result in a **high yield**, as EWGs increase the acidity of the carboxyl group, enhancing coordination with metals.

   - **Examples (High Yield)**:
     - **4-nitrobenzoic acid**
     - **4-(bromomethyl)benzoic acid**
   - **Non-examples (Low Yield)**:
     - **4-formylbenzoic acid** (aldehyde may interfere)
     - **4-methylbenzoic acid** (electron-donating group)

4. **Rule 4**: Modifiers that are **heterocyclic carboxylic acids containing nitrogen atoms within the ring** result in a **high yield**. Nitrogen atoms act as additional coordination sites, enhancing catalyst efficiency.

   - **Examples (High Yield)**:
     - **Pyridine-3-carboxylic acid** (Nicotinic acid)
     - **1H-pyrazole-4-carboxylic acid**
     - **2-oxo-1H-pyridine-4-carboxylic acid**
   - **Non-examples (Low Yield)**:
     - **4-pyridin-4-ylbenzoic acid** (bulky structure causes steric hindrance)

5. **Rule 5**: Modifiers that are **aliphatic carboxylic acids with distal functional groups** (functional groups located more than three carbons away from the carboxyl group) result in a **low yield**. The distance reduces effective chelation, and additional groups may introduce steric hindrance.

   - **Examples (Low Yield)**:
     - **7-aminoheptanoic acid**
     - **7-hydroxyheptanoic acid**
     - **8-aminooctanoic acid**

6. **Rule 6**: Modifiers that are **aromatic carboxylic acids with ortho-substituted hydroxyl (-OH) or formyl (-CHO) groups** result in a **low yield**. Intramolecular hydrogen bonding reduces the availability of coordinating groups.

   - **Examples (Low Yield)**:
     - **5-formyl-2-hydroxybenzoic acid**

7. **Rule 7**: Modifiers that are **carboxylic acids with perfluoroalkyl chains or trifluoromethyl groups near the carboxyl group** result in a **low yield**. The strong electron-withdrawing effect decreases the basicity of the carboxylate oxygen, weakening metal coordination.

   - **Examples (Low Yield)**:
     - **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**
     - **4-[(2,2,2-trifluoroacetyl)amino]butanoic acid**

8. **Rule 8**: Modifiers with **bulky or sterically hindered groups near the coordination site** result in a **low yield** due to decreased ability to coordinate with metal centers.

   - **Examples (Low Yield)**:
     - **4-pyridin-4-ylbenzoic acid** (rigid biphenyl structure)
     - **(2S)-2-amino-3-phenylpropanoic acid** (Phenylalanine)
     - **2-[[(2S)-2-amino-4-methylsulfanylbutanoyl]amino]acetic acid**

9. **Rule 9**: Modifiers containing **amide bonds or peptide linkages adjacent to the carboxyl group** result in a **low yield**. Amide groups can compete with the carboxylate for metal coordination, reducing catalyst effectiveness.

   - **Examples (Low Yield)**:
     - **(2S)-6-acetamido-2-aminohexanoic acid**
     - **2-[[(2S)-2-amino-4-methylsulfanylbutanoyl]amino]acetic acid**

10. **Rule 10**: Modifiers that are **simple aliphatic carboxylic acids without additional functional groups or with long hydrophobic chains** result in a **high yield**. The lack of interfering groups and hydrophobic interactions may enhance catalyst performance.

    - **Example (High Yield)**:
      - **Octanoic acid**

11. **Rule 11**: Modifiers that are **amino acids with polar or chelating side chains** (e.g., carboxylate, thiol, indole ring) result in a **high yield**. These functionalities enhance coordination with the metal center.

    - **Examples (High Yield)**:
      - **(2S)-2-aminobutanedioic acid** (Aspartic acid)
      - **(2S)-2-aminopentanedioic acid** (Glutamic acid)
      - **(2R)-2-amino-3-(1H-indol-3-yl)propanoic acid** (Tryptophan)
    - **Non-examples (Low Yield)**:
      - **(2S)-2-amino-3-phenylpropanoic acid** (Phenylalanine; bulky, hydrophobic side chain)

12. **Rule 12**: Modifiers that have **multiple ether linkages and flexible chains** result in a **low yield**. The increased conformational flexibility reduces the effective concentration of coordinating groups at the metal center.

    - **Example (Low Yield)**:
      - **2-[2-(2-methoxyethoxy)ethoxy]acetic acid**
      - **3-[2-(2-aminoethoxy)ethoxy]propanoic acid**

13. **Rule 13**: Modifiers with **additional chelating groups within conjugated systems** (e.g., ketone groups adjacent to aromatic rings) result in a **high yield**. These groups strengthen metal coordination through bidentate or multidentate interactions.

    - **Example (High Yield)**:
      - **1,3-dioxo-2-benzofuran-5-carboxylic acid**

**End of Rules**

---

These rules combine multiple functional groups and structural features to predict whether a modifier will result in a high or low yield:

- **High Yield Modifiers**:
  - **Proximal Amino or Thiol Groups**: Enhance chelation with metal centers.
  - **Aromatic Rings with Para Substituents**: Amino or hydroxyl groups increase coordination sites.
  - **Electron-Withdrawing Groups**: Increase carboxylate acidity, enhancing metal binding.
  - **Nitrogen-Containing Heterocycles**: Provide additional coordination sites.
  - **Simple Aliphatic Chains**: Lack of hindering groups allows better interaction with the catalyst.
  - **Polar Side Chains in Amino Acids**: Enhance metal coordination.
  - **Chelating Groups in Conjugated Systems**: Strengthen binding through multidentate interactions.

- **Low Yield Modifiers**:
  - **Distal Functional Groups**: Reduce effective chelation and may introduce steric hindrance.
  - **Intramolecular Hydrogen Bonding**: Decreases availability of coordination sites.
  - **Perfluoroalkyl Chains**: Weaken metal coordination.
  - **Bulky Structures**: Impede effective coordination due to steric hindrance.
  - **Amide Bonds Near Carboxyl Group**: Compete for metal coordination.
  - **Flexible Ether Chains**: Reduce effective concentration of coordinating groups.

These rules prioritize broader coverage of the dataset while balancing simplicity and complexity. They consider underlying physico-chemical properties such as coordination ability, steric effects, electron-withdrawing or donating nature, and the potential for chelation with the metal center. By applying these rules, we can predict the potential effectiveness of a molecular modifier in enhancing the reaction yield.---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10,Rule 11,Rule 12,Rule 13
0,0,0,0,-1,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,1,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,1,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,1,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,-1,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,1
1,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,0,0,-1,0,0,0,0,0,0
0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,-1,0,0,0,0,0,0,0,0
0,0,0,0,-1,0,0,0,0,0,0,0,0
1,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,-1,0,0,0,0,1,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.6285714285714286; Test Accuracy: 1.0
    Train Support: 0.17142857142857143; Test Support: 1.0
    Train Confidence: 0.75; Test Confidence: 1.0
    Train Lift: 1.5441176470588234; Test Lift: NONE
    Train Leverage: 0.06040816326530611; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    # Import RDKit modules
    from rdkit import Chem
    from rdkit.Chem import AllChem
    import pandas as pd
    
    # Initialize results list
    results = []
    
    # Number of rules
    num_rules = 13
    
    # For each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*num_rules)
            continue
        row = []
        
        ##### Rule 1 #####
        # High yield: Aliphatic carboxylic acids with an amino group (-NH2) or thiol group (-SH) within three carbons of the carboxyl group
        try:
            match = False
            carboxylic_acid = Chem.MolFromSmarts('[CX3](=O)[OX1H0-,OX2H1]')
            amino_group = Chem.MolFromSmarts('[NX3;H2]')
            thiol_group = Chem.MolFromSmarts('[SX2H]')
            
            ca_atoms = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid)]
            donor_atoms = [match[0] for match in mol.GetSubstructMatches(amino_group)] + [match[0] for match in mol.GetSubstructMatches(thiol_group)]
            
            for ca_atom in ca_atoms:
                for donor_atom in donor_atoms:
                    # Calculate the shortest path between the atoms
                    path = Chem.rdmolops.GetShortestPath(mol, ca_atom, donor_atom)
                    if 0 < len(path) - 1 <= 5:  # up to 5 bonds (3 carbons in between)
                        match = True
                        break
                if match:
                    break
            if match:
                row.append(1)
            else:
                row.append(0)
        except Exception as e:
            row.append(0)
        
        ##### Rule 2 #####
        # High yield: Aromatic carboxylic acids with a para-substituted amino (-NH2) or hydroxyl (-OH) group directly attached to the ring
        try:
            match = False
            # Patterns for para-substituted amino or hydroxyl group on aromatic ring with carboxylic acid
            para_amino = Chem.MolFromSmarts('c1ccc(cc1[NH2])C(=O)[O,H]')
            para_hydroxyl = Chem.MolFromSmarts('c1ccc(cc1O)C(=O)[O,H]')
            if mol.HasSubstructMatch(para_amino) or mol.HasSubstructMatch(para_hydroxyl):
                row.append(1)
            else:
                row.append(0)
        except Exception as e:
            row.append(0)
        
        ##### Rule 3 #####
        # High yield: Aromatic carboxylic acids with para-substituted electron-withdrawing groups (-NO2, -CH2Br)
        try:
            para_nitro = Chem.MolFromSmarts('c1ccc(cc1[N+](=O)[O-])C(=O)[O,H]')
            para_bromomethyl = Chem.MolFromSmarts('c1ccc(cc1CBr)C(=O)[O,H]')
            if mol.HasSubstructMatch(para_nitro) or mol.HasSubstructMatch(para_bromomethyl):
                row.append(1)
            else:
                row.append(0)
        except Exception as e:
            row.append(0)
        
        ##### Rule 4 #####
        # High yield: Heterocyclic carboxylic acids containing nitrogen atoms within the ring
        try:
            hetero_carboxylic_acid = Chem.MolFromSmarts('[n,c]1cccc1C(=O)[O,H]')
            if mol.HasSubstructMatch(hetero_carboxylic_acid):
                row.append(1)
            else:
                row.append(0)
        except Exception as e:
            row.append(0)
        
        ##### Rule 5 #####
        # Low yield: Aliphatic carboxylic acids with distal functional groups (functional groups located more than three carbons away from the carboxyl group)
        try:
            match = False
            carboxylic_acid = Chem.MolFromSmarts('[CX3](=O)[OX1H0-,OX2H1]')
            amino_group = Chem.MolFromSmarts('[NX3;H2]')
            hydroxyl_group = Chem.MolFromSmarts('[OX2H]')
            thiol_group = Chem.MolFromSmarts('[SX2H]')
            
            ca_atoms = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid)]
            functional_atoms = [match[0] for match in mol.GetSubstructMatches(amino_group)] + [match[0] for match in mol.GetSubstructMatches(hydroxyl_group)] + [match[0] for match in mol.GetSubstructMatches(thiol_group)]
            
            for ca_atom in ca_atoms:
                for func_atom in functional_atoms:
                    path = Chem.rdmolops.GetShortestPath(mol, ca_atom, func_atom)
                    if len(path) - 1 > 5:  # More than 5 bonds
                        match = True
                        break
                if match:
                    break
            if match:
                row.append(-1)
            else:
                row.append(0)
        except Exception as e:
            row.append(0)
        
        ##### Rule 6 #####
        # Low yield: Aromatic carboxylic acids with ortho-substituted hydroxyl (-OH) or formyl (-CHO) groups
        try:
            ortho_hydroxyl = Chem.MolFromSmarts('OCc1ccccc1C(=O)[O,H]')
            ortho_formyl = Chem.MolFromSmarts('O=CCc1ccccc1C(=O)[O,H]')
            if mol.HasSubstructMatch(ortho_hydroxyl) or mol.HasSubstructMatch(ortho_formyl):
                row.append(-1)
            else:
                row.append(0)
        except Exception as e:
            row.append(0)
        
        ##### Rule 7 #####
        # Low yield: Modifiers with perfluoroalkyl chains or trifluoromethyl groups near the carboxyl group
        try:
            perfluoroalkyl = Chem.MolFromSmarts('C(F)(F)(F)C(F)(F)(F)C(=O)[O,H]')
            trifluoromethyl = Chem.MolFromSmarts('C(F)(F)(F)C(=O)[O,H]')
            if mol.HasSubstructMatch(perfluoroalkyl) or mol.HasSubstructMatch(trifluoromethyl):
                row.append(-1)
            else:
                row.append(0)
        except Exception as e:
            row.append(0)
        
        ##### Rule 8 #####
        # Low yield: Modifiers with bulky or sterically hindered groups near the coordination site
        try:
            bulky_group = Chem.MolFromSmarts('c1ccccc1CC(=O)[O,H]')
            if mol.HasSubstructMatch(bulky_group):
                row.append(-1)
            else:
                row.append(0)
        except Exception as e:
            row.append(0)
        
        ##### Rule 9 #####
        # Low yield: Modifiers containing amide bonds or peptide linkages adjacent to the carboxyl group
        try:
            amide_adjacent = Chem.MolFromSmarts('[NX3][CX3](=O)[CX3](=O)[OX1H0-,OX2H1]')
            if mol.HasSubstructMatch(amide_adjacent):
                row.append(-1)
            else:
                row.append(0)
        except Exception as e:
            row.append(0)

        ##### Rule 10 #####
        # High yield: Simple aliphatic carboxylic acids without additional functional groups or with long hydrophobic chains
        try:
            simple_aliphatic = Chem.MolFromSmarts('CCCCCCCC(=O)[O,H]')  # Octanoic acid
            if mol.HasSubstructMatch(simple_aliphatic):
                row.append(1)
            else:
                row.append(0)
        except Exception as e:
            row.append(0)

        ##### Rule 11 #####
        # High yield: Amino acids with polar or chelating side chains
        try:
            # Patterns for Aspartic acid, Glutamic acid, Tryptophan
            aspartic_acid = Chem.MolFromSmarts('N[C@@H](CC(=O)[O,H])C(=O)[O,H]')
            glutamic_acid = Chem.MolFromSmarts('N[C@@H](CCC(=O)[O,H])C(=O)[O,H]')
            tryptophan = Chem.MolFromSmarts('N[C@@H](CC1=CNc2ccccc12)C(=O)[O,H]')
            if mol.HasSubstructMatch(aspartic_acid) or mol.HasSubstructMatch(glutamic_acid) or mol.HasSubstructMatch(tryptophan):
                row.append(1)
            else:
                row.append(0)
        except Exception as e:
            row.append(0)

        ##### Rule 12 #####
        # Low yield: Modifiers with multiple ether linkages and flexible chains
        try:
            polyether = Chem.MolFromSmarts('[OX2][CX2][CX2][OX2][CX2][CX2][OX2][CX2][CX2][OX2][CX2]C(=O)[O,H]')
            if mol.HasSubstructMatch(polyether):
                row.append(-1)
            else:
                row.append(0)
        except Exception as e:
            row.append(0)

        ##### Rule 13 #####
        # High yield: Modifiers with additional chelating groups within conjugated systems
        try:
            conjugated_chelator = Chem.MolFromSmarts('O=C1OC(=O)c2ccccc12')  # 1,3-dioxo-2-benzofuran-5-carboxylic acid
            if mol.HasSubstructMatch(conjugated_chelator):
                row.append(1)
            else:
                row.append(0)
        except Exception as e:
            row.append(0)

        results.append(row)
    
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f'Rule {i+1}' for i in range(num_rules)])
    return df
--------------------------------------------------
    Target Name: yield
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

1. **Rule 1**: Modifiers that are **aliphatic carboxylic acids with amino (-NH₂), hydroxyl (-OH), or thiol (-SH) groups located within three carbons of the carboxyl group** result in a **high yield**. The close proximity of these polar groups enhances chelation with the metal center, improving catalyst performance.

   - **Examples (High Yield)**:
     - **(2S)-2-aminopentanedioic acid** (Glutamic acid)
     - **(2S)-2-aminobutanedioic acid** (Aspartic acid)
     - **5-aminopentanoic acid**
     - **3-sulfanylpropanoic acid**
   - **Non-examples (Low Yield)**:
     - **7-aminoheptanoic acid** (Amino group too distant)
     - **8-aminooctanoic acid** (Amino group too distant)

2. **Rule 2**: Modifiers that are **aromatic carboxylic acids with para-substituted electron-withdrawing groups** such as **nitro (-NO₂), bromo (-Br), or amino (-NH₂)** result in a **high yield**. These groups increase the acidity of the carboxylate and enhance coordination with the metal center.

   - **Examples (High Yield)**:
     - **4-nitrobenzoic acid**
     - **4-(bromomethyl)benzoic acid**
     - **4-aminobenzoic acid**
   - **Non-examples (Low Yield)**:
     - **4-methylbenzoic acid** (Para methyl group is electron-donating)
     - **4-formylbenzoic acid** (Aldehyde may interfere with coordination)

3. **Rule 3**: Modifiers that are **heterocyclic carboxylic acids containing nitrogen atoms within the ring**, especially **pyridine or pyrazole rings**, result in a **high yield**. Nitrogen atoms act as additional coordination sites, enhancing metal binding.

   - **Examples (High Yield)**:
     - **Pyridine-3-carboxylic acid** (Nicotinic acid)
     - **1H-pyrazole-4-carboxylic acid**
     - **2-oxo-1H-pyridine-4-carboxylic acid**
   - **Non-examples (Low Yield)**:
     - **4-pyridin-4-ylbenzoic acid** (Bulky structure causes steric hindrance)

4. **Rule 4**: Modifiers that are **aliphatic carboxylic acids with multiple adjacent hydroxyl (-OH) groups** result in a **high yield**. The additional hydroxyl groups enhance chelation and coordination with the metal center.

   - **Examples (High Yield)**:
     - **(2R,3S,4R,5R)-2,3,4,5,6-pentahydroxyhexanoic acid** (Gluconic acid)
     - **2-[[1,3-dihydroxy-2-(hydroxymethyl)propan-2-yl]oxy]acetic acid**
   - **Non-examples (Low Yield)**:
     - **7-hydroxyheptanoic acid** (Hydroxyl group too distant)

5. **Rule 5**: Modifiers that are **aliphatic carboxylic acids with long chains (more than six carbons) where functional groups are more than three carbons away from the carboxyl group** result in a **low yield**. The distance reduces effective chelation and may introduce flexibility that hinders coordination.

   - **Examples (Low Yield)**:
     - **7-aminoheptanoic acid**
     - **8-aminooctanoic acid**
     - **7-hydroxyheptanoic acid**
   - **Non-examples (High Yield)**:
     - **Octanoic acid** (High yield despite long chain due to lack of interfering groups)

6. **Rule 6**: Modifiers that are **aromatic carboxylic acids with para-substituted electron-donating groups** such as **methyl (-CH₃), methoxy (-OCH₃), or hydroxyl (-OH)** result in a **low yield**. These groups decrease the acidity of the carboxylate, reducing coordination efficiency.

   - **Examples (Low Yield)**:
     - **4-methylbenzoic acid**
     - **3-(4-hydroxyphenyl)propanoic acid**
   - **Non-examples (High Yield)**:
     - **4-nitrobenzoic acid** (Electron-withdrawing group enhances yield)

7. **Rule 7**: Modifiers containing **bulky or sterically hindering groups adjacent to the carboxyl group**, such as **phenyl rings or large substituents**, result in a **low yield** due to decreased ability to coordinate with metal centers.

   - **Examples (Low Yield)**:
     - **(2S)-2-amino-3-phenylpropanoic acid** (Phenylalanine)
     - **2-[[(2S)-2-amino-4-methylsulfanylbutanoyl]amino]acetic acid**
   - **Non-examples (High Yield)**:
     - **(2R)-2-amino-3-(1H-indol-3-yl)propanoic acid** (Tryptophan)

8. **Rule 8**: Modifiers with **fluorinated alkyl chains near the carboxyl group** result in a **low yield**. The strong electron-withdrawing effect of fluorine atoms decreases the basicity of the carboxylate oxygen, weakening metal coordination.

   - **Examples (Low Yield)**:
     - **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**
     - **4-[(2,2,2-trifluoroacetyl)amino]butanoic acid**

9. **Rule 9**: Modifiers with **functional groups capable of intramolecular hydrogen bonding** with the carboxylate group, such as **ortho-hydroxyl (-OH) or formyl (-CHO) groups**, result in a **low yield**. Intramolecular hydrogen bonding reduces the availability of coordinating groups for metal binding.

   - **Examples (Low Yield)**:
     - **5-formyl-2-hydroxybenzoic acid**
     - **2-[(4-hydroxybenzoyl)amino]acetic acid**
   - **Non-examples (High Yield)**:
     - **4-hydroxybenzoic acid** (Para-hydroxyl group does not facilitate intramolecular hydrogen bonding)

10. **Rule 10**: Modifiers that are **amino acids with aromatic side chains capable of π-interactions** (e.g., **indole rings**) result in a **high yield**. The aromatic side chains can participate in additional coordination or stabilization through π-stacking interactions with the metal center.

    - **Example (High Yield)**:
      - **(2R)-2-amino-3-(1H-indol-3-yl)propanoic acid** (Tryptophan)
    - **Non-examples (Low Yield)**:
      - **(2S)-2-amino-3-phenylpropanoic acid** (Phenylalanine)

**End of Rules**

---

**Summary and Justification:**

These rules are designed to predict whether a molecular modifier will result in a high or low yield in the radical-mediated remote δ-C(sp³)–H bond functionalization reaction. They combine multiple substructures and functional groups, considering underlying physico-chemical properties to explain their effects on yield.

- **High Yield Modifiers**:

  - **Proximal Polar Groups**: Aliphatic carboxylic acids with amino, hydroxyl, or thiol groups within three carbons enhance chelation (Rule 1).
  - **Electron-Withdrawing Para Substituents**: Increase carboxylate acidity and coordination ability in aromatic acids (Rule 2).
  - **Nitrogen-Containing Heterocycles**: Provide additional coordination sites (Rule 3).
  - **Multiple Adjacent Hydroxyl Groups**: Enhance chelation through multiple coordinating sites (Rule 4).
  - **Aromatic Amino Acids with π-Interactions**: Indole rings aid in coordination or stabilization (Rule 10).

- **Low Yield Modifiers**:

  - **Distant Functional Groups**: Reduced chelation effectiveness due to distance (Rule 5).
  - **Electron-Donating Para Substituents**: Decrease carboxylate acidity and coordination (Rule 6).
  - **Bulky or Steric Hindrance**: Impede coordination to metal centers (Rule 7).
  - **Fluorinated Chains**: Reduce basicity of carboxylate oxygen, weakening coordination (Rule 8).
  - **Intramolecular Hydrogen Bonding**: Ortho-substituted hydroxyl or formyl groups reduce coordination sites (Rule 9).

These rules provide a balanced mix of simple, broadly applicable guidelines and more complex, specific considerations:

- **Balance Between Simple and Complex Rules**: Rules like 1, 2, and 6 are relatively straightforward and cover a broad range, while rules like 10 target specific structural features with significant impact on yield.
- **Physico-Chemical Considerations**: Each rule is grounded in chemical principles, such as ligand coordination ability, electronic effects, steric hindrance, and the nature of metal-ligand interactions.
- **Predictive Clarity**: The rules clearly state whether modifiers with certain structural features will result in high or low yield, aiding in the selection or design of effective modifiers.
- **Coverage**: The rules collectively cover the majority of the dataset, ensuring applicability to various molecular structures.

---

By adhering to these rules, researchers can better predict the efficacy of molecular modifiers in the reaction and make informed decisions in catalyst design and optimization. The rules emphasize the importance of functional group placement, electronic effects, and steric factors in influencing the yield of the reaction. Understanding these relationships facilitates rational design of new modifiers to optimize catalyst performance.---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,1,0,0,0,-1,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,-1,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,-1,0
0,0,0,0,0,-1,0,0,0,0
0,1,0,0,0,-1,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,-1,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.6; Test Accuracy: 0.0
    Train Support: 0.1; Test Support: 0.0
    Train Confidence: 0.7777777777777778; Test Confidence: 0.5
    Train Lift: 1.5441176470588236; Test Lift: NONE
    Train Leverage: 0.022857142857142854; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    """
    Converts a list of SMILES strings into a feature matrix based on chemical rules.
    Each SMILES string is evaluated against a set of rules defined by SMARTS patterns and other criteria.
    The output is a DataFrame where each column corresponds to a rule, and each row corresponds to a SMILES string from the list.
    Values are 1, -1, or 0 according to the matching rules.
    """
    
    # List of rules
    rules = []
    
    # Rule 1
    # Modifiers that are aliphatic carboxylic acids with amino (-NH2), hydroxyl (-OH), or thiol (-SH) groups located within three carbons of the carboxyl group result in a high yield.
    def rule1(mol):
        # Aliphatic carboxylic acid not attached to an aromatic ring
        pattern_carboxylic_acid = Chem.MolFromSmarts('[C;!R;!a][CX3](=O)[OX1H1]')
        matches_carboxylic_acid = mol.GetSubstructMatches(pattern_carboxylic_acid)
        if not matches_carboxylic_acid:
            return False
        # Functional group patterns
        pattern_amino = Chem.MolFromSmarts('[NX3H2]')
        pattern_hydroxyl = Chem.MolFromSmarts('[OX2H]')
        pattern_thiol = Chem.MolFromSmarts('[SX2H]')
        # Get atom indices of functional groups
        fg_atoms = set()
        for pat in [pattern_amino, pattern_hydroxyl, pattern_thiol]:
            matches = mol.GetSubstructMatches(pat)
            fg_atoms.update([match[0] for match in matches])
        if not fg_atoms:
            return False
        # For each carboxyl group, check if any functional group atom is within 3 bonds
        for match in matches_carboxylic_acid:
            carboxyl_carbon_idx = match[1]  # Index of C in COOH
            for fg_idx in fg_atoms:
                try:
                    path_length = len(Chem.rdmolops.GetShortestPath(mol, carboxyl_carbon_idx, fg_idx)) - 1
                    if path_length <= 3:
                        return True
                except:
                    continue
        return False
    rules.append({'number': 1,
                  'description': 'Aliphatic carboxylic acids with amino (-NH2), hydroxyl (-OH), or thiol (-SH) groups within three carbons of the carboxyl group result in a high yield.',
                  'function': rule1,
                  'prediction': 1})
    
    # Rule 2
    # Modifiers that are aromatic carboxylic acids with para-substituted electron-withdrawing groups such as nitro (-NO2), bromo (-Br), or amino (-NH2) result in a high yield.
    def rule2(mol):
        # Aromatic carboxylic acid
        pattern_aromatic_carboxylic_acid = Chem.MolFromSmarts('c1ccc(cc1)C(=O)O')
        if not mol.HasSubstructMatch(pattern_aromatic_carboxylic_acid):
            return False
        # Electron-withdrawing groups at para position
        pattern_para_substituent = Chem.MolFromSmarts('c1cc([N+](=O)[O-])[cH]cc1')  # Para-nitro
        pattern_para_bromo = Chem.MolFromSmarts('c1cc(Br)[cH]cc1')  # Para-bromo
        pattern_para_amino = Chem.MolFromSmarts('c1cc(N)[cH]cc1')  # Para-amino
        if mol.HasSubstructMatch(pattern_para_substituent) or mol.HasSubstructMatch(pattern_para_bromo) or mol.HasSubstructMatch(pattern_para_amino):
            return True
        return False
    rules.append({'number': 2,
                  'description': 'Aromatic carboxylic acids with para-substituted electron-withdrawing groups such as nitro (-NO2), bromo (-Br), or amino (-NH2) result in a high yield.',
                  'function': rule2,
                  'prediction': 1})
    
    # Rule 3
    # Modifiers that are heterocyclic carboxylic acids containing nitrogen atoms within the ring, especially pyridine or pyrazole rings, result in a high yield.
    def rule3(mol):
        # Pyridine carboxylic acid
        pattern_pyridine_carboxylic_acid = Chem.MolFromSmarts('n1ccccc1C(=O)O')
        # Pyrazole carboxylic acid
        pattern_pyrazole_carboxylic_acid = Chem.MolFromSmarts('n1nccc1C(=O)O')
        if mol.HasSubstructMatch(pattern_pyridine_carboxylic_acid) or mol.HasSubstructMatch(pattern_pyrazole_carboxylic_acid):
            return True
        return False
    rules.append({'number': 3,
                  'description': 'Heterocyclic carboxylic acids containing nitrogen atoms within the ring, especially pyridine or pyrazole rings, result in a high yield.',
                  'function': rule3,
                  'prediction': 1})
    
    # Rule 4
    # Modifiers that are aliphatic carboxylic acids with multiple adjacent hydroxyl (-OH) groups result in a high yield.
    def rule4(mol):
        # Aliphatic carboxylic acid
        pattern_carboxylic_acid = Chem.MolFromSmarts('[C;!R;!a][CX3](=O)[OX1H1]')
        if not mol.HasSubstructMatch(pattern_carboxylic_acid):
            return False
        # Multiple adjacent hydroxyl groups
        pattern_adjacent_oh = Chem.MolFromSmarts('[OX2H][CX4][OX2H][CX4][OX2H]')
        if mol.HasSubstructMatch(pattern_adjacent_oh):
            return True
        return False
    rules.append({'number': 4,
                  'description': 'Aliphatic carboxylic acids with multiple adjacent hydroxyl (-OH) groups result in a high yield.',
                  'function': rule4,
                  'prediction': 1})
    
    # Rule 5
    # Modifiers that are aliphatic carboxylic acids with long chains (more than six carbons) where functional groups are more than three carbons away from the carboxyl group result in a low yield.
    def rule5(mol):
        # Long-chain aliphatic carboxylic acid (chain of at least 6 carbons)
        pattern_long_chain = Chem.MolFromSmarts('[CH3][CH2][CH2][CH2][CH2][CH2][CX3](=O)[OX1H1]')
        if mol.HasSubstructMatch(pattern_long_chain):
            return True
        return False
    rules.append({'number': 5,
                  'description': 'Aliphatic carboxylic acids with long chains (>6 carbons) where functional groups are more than three carbons away from the carboxyl group result in a low yield.',
                  'function': rule5,
                  'prediction': -1})
    
    # Rule 6
    # Modifiers that are aromatic carboxylic acids with para-substituted electron-donating groups such as methyl (-CH3), methoxy (-OCH3), or hydroxyl (-OH) result in a low yield.
    def rule6(mol):
        # Aromatic carboxylic acid
        pattern_aromatic_carboxylic_acid = Chem.MolFromSmarts('c1ccc(cc1)C(=O)O')
        if not mol.HasSubstructMatch(pattern_aromatic_carboxylic_acid):
            return False
        # Electron-donating groups at para position
        pattern_para_methyl = Chem.MolFromSmarts('c1cc(C)[cH]cc1')
        pattern_para_methoxy = Chem.MolFromSmarts('c1cc(OC)[cH]cc1')
        pattern_para_hydroxyl = Chem.MolFromSmarts('c1cc(O)[cH]cc1')
        if mol.HasSubstructMatch(pattern_para_methyl) or mol.HasSubstructMatch(pattern_para_methoxy) or mol.HasSubstructMatch(pattern_para_hydroxyl):
            return True
        return False
    rules.append({'number': 6,
                  'description': 'Aromatic carboxylic acids with para-substituted electron-donating groups such as methyl (-CH3), methoxy (-OCH3), or hydroxyl (-OH) result in a low yield.',
                  'function': rule6,
                  'prediction': -1})
    
    # Rule 7
    # Modifiers containing bulky or sterically hindering groups adjacent to the carboxyl group result in a low yield.
    def rule7(mol):
        # Carboxyl group adjacent to bulky group (e.g., phenyl ring)
        pattern_bulky_adjacent = Chem.MolFromSmarts('[CX3](=O)[OX1H1][CX4][c]')
        if mol.HasSubstructMatch(pattern_bulky_adjacent):
            return True
        return False
    rules.append({'number': 7,
                  'description': 'Modifiers containing bulky or sterically hindering groups adjacent to the carboxyl group result in a low yield.',
                  'function': rule7,
                  'prediction': -1})
    
    # Rule 8
    # Modifiers with fluorinated alkyl chains near the carboxyl group result in a low yield.
    def rule8(mol):
        # Fluorinated alkyl chains near carboxyl group
        pattern_fluoroalkyl = Chem.MolFromSmarts('[CX4](F)(F)F[CX3](=O)[OX1H1]')
        if mol.HasSubstructMatch(pattern_fluoroalkyl):
            return True
        return False
    rules.append({'number': 8,
                  'description': 'Modifiers with fluorinated alkyl chains near the carboxyl group result in a low yield.',
                  'function': rule8,
                  'prediction': -1})
    
    # Rule 9
    # Modifiers with functional groups capable of intramolecular hydrogen bonding with the carboxylate group, such as ortho-hydroxyl (-OH) or formyl (-CHO) groups, result in a low yield.
    def rule9(mol):
        # Ortho-hydroxyl benzoic acid
        pattern_ortho_hydroxy = Chem.MolFromSmarts('c1c(cccc1O)C(=O)O')
        # Ortho-formyl benzoic acid
        pattern_ortho_formyl = Chem.MolFromSmarts('c1c(cccc1C=O)C(=O)O')
        if mol.HasSubstructMatch(pattern_ortho_hydroxy) or mol.HasSubstructMatch(pattern_ortho_formyl):
            return True
        return False
    rules.append({'number': 9,
                  'description': 'Modifiers with functional groups capable of intramolecular hydrogen bonding with the carboxylate group, such as ortho-hydroxyl (-OH) or formyl (-CHO) groups, result in a low yield.',
                  'function': rule9,
                  'prediction': -1})
    
    # Rule 10
    # Modifiers that are amino acids with aromatic side chains capable of π-interactions (e.g., indole rings) result in a high yield.
    def rule10(mol):
        # Tryptophan
        pattern_tryptophan = Chem.MolFromSmarts('NC(CC1=CNC2=CC=CC=C12)C(=O)O')
        if mol.HasSubstructMatch(pattern_tryptophan):
            return True
        return False
    rules.append({'number': 10,
                  'description': 'Modifiers that are amino acids with aromatic side chains capable of π-interactions (e.g., indole rings) result in a high yield.',
                  'function': rule10,
                  'prediction': 1})
    
    # Initialize results list
    results = []
    
    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*len(rules))
            continue
        row = []
        for rule in rules:
            try:
                if rule['function'](mol):
                    row.append(rule['prediction'])
                else:
                    row.append(0)
            except Exception as e:
                # In case of any error, append 0
                # print(f"Error processing rule {rule['number']} for SMILES {smi}: {e}")
                row.append(0)
        results.append(row)
    
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])
    return df

--------------------------------------------------
    Target Name: yield
    GPT Model: o1-preview-2024-09-12
    ML Model: ETC
    Current_Rules:
    **Start of Rules**

1. **Rule 1**: Modifiers that are **aliphatic carboxylic acids with amino (-NH₂), hydroxyl (-OH), or thiol (-SH) groups within three carbons of the carboxyl group** result in a **high yield**. These proximal polar groups enhance chelation with the metal center, improving catalyst performance.

   - **Examples (High Yield)**:
     - **(2S)-2-aminobutanedioic acid** (Aspartic acid)
     - **(2S)-2-aminopentanedioic acid** (Glutamic acid)
     - **5-aminopentanoic acid**
     - **3-sulfanylpropanoic acid**
   - **Non-examples (Low Yield)**:
     - **7-aminoheptanoic acid**
     - **8-aminooctanoic acid**

2. **Rule 2**: Modifiers that are **aromatic carboxylic acids with electron-withdrawing groups in the para position**, such as **nitro (-NO₂), bromo (-Br), or amino (-NH₂)**, result in a **high yield**. Electron-withdrawing groups increase the acidity of the carboxylic acid, enhancing its ability to coordinate with metal centers.

   - **Examples (High Yield)**:
     - **4-nitrobenzoic acid**
     - **4-(bromomethyl)benzoic acid**
     - **4-aminobenzoic acid**
   - **Non-examples (Low Yield)**:
     - **4-methylbenzoic acid**

3. **Rule 3**: Modifiers that are **aromatic carboxylic acids with electron-donating groups in the para position**, such as **methyl (-CH₃)**, result in a **low yield**. Electron-donating groups decrease the acidity of the carboxylic acid, reducing coordination efficiency.

   - **Examples (Low Yield)**:
     - **4-methylbenzoic acid**
   - **Non-examples (High Yield)**:
     - **4-nitrobenzoic acid**

4. **Rule 4**: Modifiers that are **heterocyclic carboxylic acids containing nitrogen atoms within the ring**, such as **pyridine or pyrazole rings**, result in a **high yield**. Nitrogen atoms act as additional coordination sites with the metal center.

   - **Examples (High Yield)**:
     - **Pyridine-3-carboxylic acid**
     - **1H-pyrazole-4-carboxylic acid**
     - **2-oxo-1H-pyridine-4-carboxylic acid**

5. **Rule 5**: Modifiers that are **aliphatic carboxylic acids with multiple adjacent hydroxyl (-OH) groups** result in a **high yield**. The additional hydroxyl groups enhance chelation and coordination with the metal center.

   - **Examples (High Yield)**:
     - **(2R,3S,4R,5R)-2,3,4,5,6-pentahydroxyhexanoic acid** (Gluconic acid)
     - **2-[[1,3-dihydroxy-2-(hydroxymethyl)propan-2-yl]oxy]acetic acid**

6. **Rule 6**: Modifiers that are **aliphatic carboxylic acids with amino (-NH₂) or hydroxyl (-OH) groups located more than three carbons away from the carboxyl group** result in a **low yield**. The increased distance reduces effective chelation with the metal center.

   - **Examples (Low Yield)**:
     - **7-aminoheptanoic acid**
     - **8-aminooctanoic acid**
     - **7-hydroxyheptanoic acid**

7. **Rule 7**: Modifiers containing **fluorinated alkyl chains near the carboxyl group** result in a **low yield**. The strong electron-withdrawing effect of fluorine decreases the basicity of the carboxylate oxygen, weakening metal coordination.

   - **Example (Low Yield)**:
     - **2,2,3,3,4,4,5,5,5-nonafluoropentanoic acid**

8. **Rule 8**: Modifiers with **ortho-substituted hydroxyl (-OH) or formyl (-CHO) groups** relative to the carboxyl group on aromatic rings result in a **low yield**. Intramolecular hydrogen bonding reduces the availability of coordinating sites to the metal center.

   - **Examples (Low Yield)**:
     - **5-formyl-2-hydroxybenzoic acid**
     - **2-[(4-hydroxybenzoyl)amino]acetic acid**

9. **Rule 9**: Modifiers that are **amino acids with indole side chains**, such as **tryptophan**, result in a **high yield**. The indole ring may participate in π interactions with the metal center, enhancing catalyst performance.

   - **Example (High Yield)**:
     - **(2R)-2-amino-3-(1H-indol-3-yl)propanoic acid** (Tryptophan)
   - **Non-example (Low Yield)**:
     - **(2S)-2-amino-3-phenylpropanoic acid** (Phenylalanine)

10. **Rule 10**: Modifiers that are **aliphatic carboxylic acids without additional functional groups** result in a **high yield**. The simple structure allows unimpeded coordination with the metal center.

    - **Example (High Yield)**:
      - **Octanoic acid**

11. **Rule 11**: Modifiers with **polyether chains or flexible linkers bearing amino (-NH₂) or methoxy (-OCH₃) groups distant from the carboxyl group** result in a **low yield**. The flexibility and distance reduce effective chelation with the metal center.

    - **Examples (Low Yield)**:
      - **3-[2-(2-aminoethoxy)ethoxy]propanoic acid**
      - **2-[2-(2-methoxyethoxy)ethoxy]acetic acid**

12. **Rule 12**: Modifiers with **bulky substituents adjacent to the carboxyl group**, such as **aromatic rings**, result in a **low yield** due to steric hindrance affecting metal coordination.

    - **Example (Low Yield)**:
      - **(2S)-2-amino-3-phenylpropanoic acid** (Phenylalanine)

13. **Rule 13**: Modifiers that are **aromatic carboxylic acids containing formyl (-CHO) groups** result in a **low yield**. The formyl group may interfere with metal coordination or engage in intramolecular interactions.

    - **Examples (Low Yield)**:
      - **4-formylbenzoic acid**
      - **5-formyl-2-hydroxybenzoic acid**

14. **Rule 14**: Modifiers that are **aliphatic carboxylic acids containing sulfur groups (-SH) within three carbons of the carboxyl group** result in a **high yield**. Sulfur atoms enhance coordination with the metal center.

    - **Example (High Yield)**:
      - **3-sulfanylpropanoic acid**

15. **Rule 15**: Modifiers that are **aromatic carboxylic acids with methoxy (-OCH₃) groups in the meta or para position** result in a **high yield**. Methoxy groups can participate in electron donation, influencing metal coordination.

    - **Example (High Yield)**:
      - **4-(3,4-dimethoxyphenyl)-4-oxobutanoic acid**
    - **Non-example (Low Yield)**:
      - **3-(4-hydroxyphenyl)propanoic acid**

**End of Rules**---------------------------------------------------------------


    Current_Matrix:
    Matrix Generator Message:
Rule 1,Rule 2,Rule 3,Rule 4,Rule 5,Rule 6,Rule 7,Rule 8,Rule 9,Rule 10,Rule 11,Rule 12,Rule 13,Rule 14,Rule 15
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

---------------------------------------------------------------


    Train Accuracy: 0.5142857142857142; Test Accuracy: 0.0
    Train Support: 0.0; Test Support: 0.0
    Train Confidence: 0.5; Test Confidence: 0.5
    Train Lift: 1.0; Test Lift: NONE
    Train Leverage: 0.0; Test Leverage: NONE
    ----------------------------------------------------------------------------------

    Current Rule Code:
def rule2matrix(smiles_list):
    # Define SMARTS patterns for functional groups
    carboxylic_acid_pat = Chem.MolFromSmarts('[CX3](=O)[OX2H1]')
    amino_group_pat = Chem.MolFromSmarts('[NX3;H2,H1;!$(N=*)]')  # Excludes imines and other sp2 nitrogens
    hydroxyl_group_pat = Chem.MolFromSmarts('[OX2H]')
    thiol_group_pat = Chem.MolFromSmarts('[SX2H]')
    aliphatic_C_pat = Chem.MolFromSmarts('[C;!R]')  # Aliphatic carbon
    aromatic_C_pat = Chem.MolFromSmarts('[c]')
    nitro_group_pat = Chem.MolFromSmarts('[NX3](=O)=O')
    bromo_pat = Chem.MolFromSmarts('[Br]')
    methyl_group_pat = Chem.MolFromSmarts('[CX4H3]')
    indole_pat = Chem.MolFromSmarts('c1c[cH]c2[cH]c[cH][nH]c12')
    methoxy_group_pat = Chem.MolFromSmarts('[OX2][CH3]')
    formyl_group_pat = Chem.MolFromSmarts('[CX3H1](=O)')
    fluorinated_alkyl_pat = Chem.MolFromSmarts('[CX4][F]')
    ether_linkage_pat = Chem.MolFromSmarts('[#6][OX2][#6]')
    amino_acid_pat = Chem.MolFromSmarts('[NX3;H2,H1][CX4][CX3](=O)[OX2H1]')
    aromatic_ring_pat = Chem.MolFromSmarts('a1aaaaa1')
    heterocycle_N_pat = Chem.MolFromSmarts('[$([nH1]),$([nH0])]1aaaa1')
    # Define the rules with their associated patterns and predictions
    rules = [
        {
            'number': 1,
            'description': 'High Yield: Aliphatic carboxylic acids with amino (-NH2), hydroxyl (-OH), or thiol (-SH) groups within three carbons of the carboxyl group.',
            'function': 'apply_rule_1',
            'prediction': 1
        },
        {
            'number': 2,
            'description': 'High Yield: Aromatic carboxylic acids with electron-withdrawing groups (nitro, bromo, amino) in the para position.',
            'function': 'apply_rule_2',
            'prediction': 1
        },
        {
            'number': 3,
            'description': 'Low Yield: Aromatic carboxylic acids with electron-donating groups (methyl) in the para position.',
            'function': 'apply_rule_3',
            'prediction': -1
        },
        {
            'number': 4,
            'description': 'High Yield: Heterocyclic carboxylic acids containing nitrogen atoms within the ring.',
            'function': 'apply_rule_4',
            'prediction': 1
        },
        {
            'number': 5,
            'description': 'High Yield: Aliphatic carboxylic acids with multiple adjacent hydroxyl (-OH) groups.',
            'function': 'apply_rule_5',
            'prediction': 1
        },
        {
            'number': 6,
            'description': 'Low Yield: Aliphatic carboxylic acids with amino (-NH2) or hydroxyl (-OH) groups located more than three carbons away from the carboxyl group.',
            'function': 'apply_rule_6',
            'prediction': -1
        },
        {
            'number': 7,
            'description': 'Low Yield: Modifiers containing fluorinated alkyl chains near the carboxyl group.',
            'function': 'apply_rule_7',
            'prediction': -1
        },
        {
            'number': 8,
            'description': 'Low Yield: Aromatic carboxylic acids with ortho-substituted hydroxyl (-OH) or formyl (-CHO) groups.',
            'function': 'apply_rule_8',
            'prediction': -1
        },
        {
            'number': 9,
            'description': 'High Yield: Amino acids with indole side chains (tryptophan).',
            'function': 'apply_rule_9',
            'prediction': 1
        },
        {
            'number': 10,
            'description': 'High Yield: Aliphatic carboxylic acids without additional functional groups.',
            'function': 'apply_rule_10',
            'prediction': 1
        },
        {
            'number': 11,
            'description': 'Low Yield: Modifiers with polyether chains or flexible linkers bearing amino (-NH2) or methoxy (-OCH3) groups distant from the carboxyl group.',
            'function': 'apply_rule_11',
            'prediction': -1
        },
        {
            'number': 12,
            'description': 'Low Yield: Modifiers with bulky substituents adjacent to the carboxyl group (e.g., aromatic rings).',
            'function': 'apply_rule_12',
            'prediction': -1
        },
        {
            'number': 13,
            'description': 'Low Yield: Aromatic carboxylic acids containing formyl (-CHO) groups.',
            'function': 'apply_rule_13',
            'prediction': -1
        },
        {
            'number': 14,
            'description': 'High Yield: Aliphatic carboxylic acids containing sulfur groups (-SH) within three carbons of the carboxyl group.',
            'function': 'apply_rule_14',
            'prediction': 1
        },
        {
            'number': 15,
            'description': 'High Yield: Aromatic carboxylic acids with methoxy (-OCH3) groups in the meta or para position.',
            'function': 'apply_rule_15',
            'prediction': 1
        }
    ]
    # Initialize results list
    results = []
    # Process each SMILES string
    for smi in smiles_list:
        mol = Chem.MolFromSmiles(smi)
        if mol is None:
            # If the molecule cannot be parsed, append a row of zeros
            results.append([0]*len(rules))
            continue
        row = []
        # Apply each rule function
        for rule in rules:
            func_name = rule['function']
            prediction = rule['prediction']
            try:
                match = globals()[func_name](mol)
                if match:
                    row.append(prediction)
                else:
                    row.append(0)
            except Exception as e:
                # In case of any error, append 0
                row.append(0)
        results.append(row)
    # Create DataFrame with results
    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])
    return df

    # Function definitions for rules
    def apply_rule_1(mol):
        # Rule 1 implementation
        try:
            # Find carboxylic acid carbons
            carboxyl_carbons = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid_pat)]
            # Find amino/hydroxyl/thiol groups
            amino_atoms = [match[0] for match in mol.GetSubstructMatches(amino_group_pat)]
            hydroxyl_atoms = [match[0] for match in mol.GetSubstructMatches(hydroxyl_group_pat)]
            thiol_atoms = [match[0] for match in mol.GetSubstructMatches(thiol_group_pat)]
            functional_atoms = amino_atoms + hydroxyl_atoms + thiol_atoms
            # For each carboxyl carbon, check if any functional group is within 3 bonds
            for c_idx in carboxyl_carbons:
                for f_idx in functional_atoms:
                    path = Chem.GetShortestPath(mol, c_idx, f_idx)
                    if len(path) - 1 <= 3:
                        return True
            return False
        except:
            return False

    def apply_rule_2(mol):
        # Rule 2 implementation
        try:
            # Find aromatic carboxylic acids
            aromatic_carboxylic_acid_pat = Chem.MolFromSmarts('[c][CX3](=O)[OX2H1]')
            matches = mol.GetSubstructMatches(aromatic_carboxylic_acid_pat)
            if not matches:
                return False
            # For each match, check for EWG in para position
            for match in matches:
                aromatic_c_idx = match[0]  # Aromatic carbon attached to carboxyl group
                # Get the ring that contains the aromatic carbon
                ring_info = mol.GetRingInfo()
                rings = ring_info.AtomRings()
                for ring in rings:
                    if aromatic_c_idx in ring and len(ring) == 6:
                        # Find the index of the aromatic carbon in the ring
                        idx_in_ring = ring.index(aromatic_c_idx)
                        # Para position is three atoms away in the ring (opposite side)
                        para_idx = ring[(idx_in_ring + 3) % 6]
                        para_atom = mol.GetAtomWithIdx(para_idx)
                        # Check for substituents at para position
                        for neighbor in para_atom.GetNeighbors():
                            if neighbor.GetIdx() != para_idx and neighbor.GetIdx() not in ring:
                                sub_mol = Chem.PathToSubmol(mol, [neighbor.GetIdx()])
                                if sub_mol.HasSubstructMatch(nitro_group_pat) or sub_mol.HasSubstructMatch(bromo_pat) or sub_mol.HasSubstructMatch(amino_group_pat):
                                    return True
            return False
        except:
            return False

    def apply_rule_3(mol):
        # Rule 3 implementation
        try:
            # Find aromatic carboxylic acids
            aromatic_carboxylic_acid_pat = Chem.MolFromSmarts('[c][CX3](=O)[OX2H1]')
            matches = mol.GetSubstructMatches(aromatic_carboxylic_acid_pat)
            if not matches:
                return False
            # For each match, check for methyl group in para position
            for match in matches:
                aromatic_c_idx = match[0]
                ring_info = mol.GetRingInfo()
                rings = ring_info.AtomRings()
                for ring in rings:
                    if aromatic_c_idx in ring and len(ring) == 6:
                        idx_in_ring = ring.index(aromatic_c_idx)
                        para_idx = ring[(idx_in_ring + 3) % 6]
                        para_atom = mol.GetAtomWithIdx(para_idx)
                        for neighbor in para_atom.GetNeighbors():
                            if neighbor.GetIdx() != para_idx and neighbor.GetIdx() not in ring:
                                sub_mol = Chem.PathToSubmol(mol, [neighbor.GetIdx()])
                                if sub_mol.HasSubstructMatch(methyl_group_pat):
                                    return True
            return False
        except:
            return False

    def apply_rule_4(mol):
        # Rule 4 implementation
        try:
            matches = mol.GetSubstructMatches(heterocycle_N_pat)
            for match in matches:
                atom = mol.GetAtomWithIdx(match[0])
                # Check if the heterocycle has a carboxylic acid group
                for neighbor in atom.GetNeighbors():
                    if neighbor.HasSubstructMatch(carboxylic_acid_pat):
                        return True
            return False
        except:
            return False

    def apply_rule_5(mol):
        # Rule 5 implementation
        try:
            hydroxyl_matches = mol.GetSubstructMatches(hydroxyl_group_pat)
            hydroxyl_atoms = [match[0] for match in hydroxyl_matches]
            # Check for adjacent hydroxyl groups
            for i in range(len(hydroxyl_atoms)):
                atom_i = mol.GetAtomWithIdx(hydroxyl_atoms[i])
                for j in range(i+1, len(hydroxyl_atoms)):
                    atom_j = mol.GetAtomWithIdx(hydroxyl_atoms[j])
                    path = Chem.GetShortestPath(mol, atom_i.GetIdx(), atom_j.GetIdx())
                    if len(path) == 2:  # Adjacent hydroxyl groups
                        # Check for carboxylic acid in the molecule
                        if mol.HasSubstructMatch(carboxylic_acid_pat):
                            return True
            return False
        except:
            return False

    def apply_rule_6(mol):
        # Rule 6 implementation
        try:
            # Similar to Rule 1 but for groups more than 3 bonds away
            carboxyl_carbons = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid_pat)]
            amino_atoms = [match[0] for match in mol.GetSubstructMatches(amino_group_pat)]
            hydroxyl_atoms = [match[0] for match in mol.GetSubstructMatches(hydroxyl_group_pat)]
            functional_atoms = amino_atoms + hydroxyl_atoms
            found_far = False
            found_close = False
            for c_idx in carboxyl_carbons:
                for f_idx in functional_atoms:
                    path = Chem.GetShortestPath(mol, c_idx, f_idx)
                    if len(path) - 1 > 3:
                        found_far = True
                    elif len(path) - 1 <= 3:
                        found_close = True
            if found_far and not found_close:
                return True
            return False
        except:
            return False

    def apply_rule_7(mol):
        # Rule 7 implementation
        try:
            # Check for fluorinated alkyl chains near carboxyl group
            carboxyl_carbons = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid_pat)]
            fluorinated_carbons = [match[0] for match in mol.GetSubstructMatches(fluorinated_alkyl_pat)]
            for c_idx in carboxyl_carbons:
                for f_idx in fluorinated_carbons:
                    path = Chem.GetShortestPath(mol, c_idx, f_idx)
                    if len(path) - 1 <= 3:
                        return True
            return False
        except:
            return False

    def apply_rule_8(mol):
        # Rule 8 implementation
        try:
            # Find aromatic carboxylic acids
            aromatic_carboxylic_acid_pat = Chem.MolFromSmarts('[c][CX3](=O)[OX2H1]')
            matches = mol.GetSubstructMatches(aromatic_carboxylic_acid_pat)
            if not matches:
                return False
            # Check for ortho-substituted hydroxyl or formyl groups
            for match in matches:
                aromatic_c_idx = match[0]
                ring_info = mol.GetRingInfo()
                rings = ring_info.AtomRings()
                for ring in rings:
                    if aromatic_c_idx in ring and len(ring) == 6:
                        idx_in_ring = ring.index(aromatic_c_idx)
                        ortho_indices = [ring[(idx_in_ring + 1) % 6], ring[(idx_in_ring - 1) % 6]]
                        for ortho_idx in ortho_indices:
                            ortho_atom = mol.GetAtomWithIdx(ortho_idx)
                            for neighbor in ortho_atom.GetNeighbors():
                                if neighbor.GetIdx() not in ring:
                                    sub_mol = Chem.PathToSubmol(mol, [neighbor.GetIdx()])
                                    if sub_mol.HasSubstructMatch(hydroxyl_group_pat) or sub_mol.HasSubstructMatch(formyl_group_pat):
                                        return True
            return False
        except:
            return False

    def apply_rule_9(mol):
        # Rule 9 implementation
        try:
            # Check for amino acid with indole side chain
            if mol.HasSubstructMatch(indole_pat) and mol.HasSubstructMatch(amino_acid_pat):
                return True
            return False
        except:
            return False

    def apply_rule_10(mol):
        # Rule 10 implementation
        try:
            # Aliphatic carboxylic acids without additional functional groups
            if mol.HasSubstructMatch(carboxylic_acid_pat):
                # Exclude molecules with other functional groups
                if not (mol.HasSubstructMatch(amino_group_pat) or mol.HasSubstructMatch(hydroxyl_group_pat) or mol.HasSubstructMatch(thiol_group_pat) or mol.HasSubstructMatch(aromatic_C_pat)):
                    return True
            return False
        except:
            return False

    def apply_rule_11(mol):
        # Rule 11 implementation
        try:
            # Check for polyether chains or flexible linkers with amino or methoxy groups distant from carboxyl
            if mol.HasSubstructMatch(ether_linkage_pat) and (mol.HasSubstructMatch(amino_group_pat) or mol.HasSubstructMatch(methoxy_group_pat)):
                # Check the distance from carboxyl group
                carboxyl_carbons = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid_pat)]
                functional_atoms = [match[0] for match in mol.GetSubstructMatches(amino_group_pat)] + [match[0] for match in mol.GetSubstructMatches(methoxy_group_pat)]
                for c_idx in carboxyl_carbons:
                    for f_idx in functional_atoms:
                        path = Chem.GetShortestPath(mol, c_idx, f_idx)
                        if len(path) - 1 > 3:
                            return True
            return False
        except:
            return False

    def apply_rule_12(mol):
        # Rule 12 implementation
        try:
            # Check for bulky substituents adjacent to carboxyl group
            carboxyl_carbons = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid_pat)]
            for c_idx in carboxyl_carbons:
                carboxyl_carbon = mol.GetAtomWithIdx(c_idx)
                for neighbor in carboxyl_carbon.GetNeighbors():
                    if neighbor.GetAtomicNum() == 6 and neighbor.IsInRing():
                        return True
            return False
        except:
            return False

    def apply_rule_13(mol):
        # Rule 13 implementation
        try:
            # Aromatic carboxylic acids with formyl groups
            aromatic_carboxylic_acid_pat = Chem.MolFromSmarts('[c][CX3](=O)[OX2H1]')
            formyl_group_pat = Chem.MolFromSmarts('[CX3H1](=O)[#6]')
            if mol.HasSubstructMatch(aromatic_carboxylic_acid_pat) and mol.HasSubstructMatch(formyl_group_pat):
                return True
            return False
        except:
            return False

    def apply_rule_14(mol):
        # Rule 14 implementation
        try:
            # Similar to Rule 1 but for sulfur groups
            carboxyl_carbons = [match[0] for match in mol.GetSubstructMatches(carboxylic_acid_pat)]
            thiol_atoms = [match[0] for match in mol.GetSubstructMatches(thiol_group_pat)]
            for c_idx in carboxyl_carbons:
                for f_idx in thiol_atoms:
                    path = Chem.GetShortestPath(mol, c_idx, f_idx)
                    if len(path) - 1 <= 3:
                        return True
            return False
        except:
            return False

    def apply_rule_15(mol):
        # Rule 15 implementation
        try:
            # Check for methoxy groups in meta or para position
            aromatic_carboxylic_acid_pat = Chem.MolFromSmarts('[c][CX3](=O)[OX2H1]')
            matches = mol.GetSubstructMatches(aromatic_carboxylic_acid_pat)
            if not matches:
                return False
            for match in matches:
                aromatic_c_idx = match[0]
                ring_info = mol.GetRingInfo()
                rings = ring_info.AtomRings()
                for ring in rings:
                    if aromatic_c_idx in ring and len(ring) == 6:
                        idx_in_ring = ring.index(aromatic_c_idx)
                        # Meta positions
                        meta_indices = [ring[(idx_in_ring + 2) % 6], ring[(idx_in_ring - 2) % 6]]
                        # Para position
                        para_idx = ring[(idx_in_ring + 3) % 6]
                        positions = meta_indices + [para_idx]
                        for pos_idx in positions:
                            pos_atom = mol.GetAtomWithIdx(pos_idx)
                            for neighbor in pos_atom.GetNeighbors():
                                if neighbor.GetIdx() not in ring:
                                    sub_mol = Chem.PathToSubmol(mol, [neighbor.GetIdx()])
                                    if sub_mol.HasSubstructMatch(methoxy_group_pat):
                                        return True
            return False
        except:
            return False
--------------------------------------------------