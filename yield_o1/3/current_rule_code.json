{
    "prefix": "The following code converts a list of SMILES strings into a feature matrix by applying a set of rules using RDKit. Each rule corresponds to a chemical pattern described by SMARTS strings or combinations thereof. The function 'rule2matrix' takes a list of SMILES strings as input, applies the rules to each molecule, and returns a pandas DataFrame where each column represents a rule, and each row represents a molecule from the input list. The values in the matrix are 1, -1, or 0, according to whether the rule matches (1 for high yield, -1 for low yield), or does not match (0), as per the rules specified.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\n",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for common functional groups and substructures\n    # Carboxylic acid group attached to aromatic ring\n    aromatic_carboxylic_acid = '[c][C](=O)[O,H]'\n    \n    # Electron-withdrawing groups attached to aromatic ring\n    ewg_on_aromatic = ['[c][N+](=O)[O-]',  # Nitro group\n                       '[c][CH2Br]',        # Bromomethyl group\n                       '[c][NH2]']          # Amino group (according to the rules)\n    \n    # Electron-donating groups attached to aromatic ring\n    edg_on_aromatic = ['[c][CH3]',          # Methyl group\n                       '[c][OH]',           # Hydroxyl group\n                       '[c][SH]']           # Thiol group\n    \n    # Heteroaromatic ring with carboxylic acid attached\n    heteroaromatic_carboxylic_acid = '[n,o,s][c]:[c]:[c]:[c]:[c][C](=O)[O,H]'\n    \n    # Linear aliphatic carboxylic acid with chain length >=6 carbons and no other functional groups\n    # Due to limitations in SMARTS, we'll need to handle this in code\n    \n    # Amino acid with short aliphatic chain (<=5 carbons) and amino group\n    short_aliphatic_amino_acid = '[NX3][CH2][CH2][CH2][C](=O)[O,H]'\n    \n    # Amino acid with long aliphatic chain (>5 carbons) and amino group\n    long_aliphatic_amino_acid = '[NX3][CH2]{5,}[C](=O)[O,H]'\n    \n    # Amino acids with aromatic side chains\n    indole_side_chain = 'c1cc2ccccc2[nH]1'   # Indole ring\n    phenyl_side_chain = 'c1ccccc1'           # Phenyl ring\n    amino_acid_backbone = '[NX3][CH]([*])[C](=O)[O,H]'  # Simplified backbone pattern\n    \n    # Polyhydroxy aliphatic chains (multiple hydroxyl groups)\n    polyhydroxy_chain = '[C;!$(C=O)]([OH])[C;!$(C=O)]([OH])[C;!$(C=O)]([OH])'  # At least 3 hydroxyls\n    \n    # Single hydroxyl group on aliphatic chain\n    single_hydroxyl_chain = '[C;!$(C=O)]([OH])[C;!$(C=O)]'\n    \n    # Ether linkage in aliphatic chain\n    ether_linkage = '[C][O][C]'\n    \n    # Aromatic ring connected via aliphatic chain (>3 carbons) to carboxylic acid\n    long_chain_to_aromatic = '[C][C][C][C][c]'  # Chain of at least 4 carbons to aromatic ring\n    short_chain_to_aromatic = '[C][C][C][c]'  # Chain of 3 carbons to aromatic ring\n    \n    # Fluorinated alkyl chains\n    fluorinated_chain = '[C](F)(F)F'  # Trifluoromethyl group as example\n    \n    # Aldehyde group attached to aromatic ring\n    aromatic_aldehyde = '[c][CH]=O'\n    \n    # Thiol groups on short aliphatic chains\n    thiol_short_chain = '[SH][C][C][C](=O)[O,H]'\n    \n    # Thiol groups attached directly to aromatic rings\n    aromatic_thiol = '[c][SH]'\n    \n    # N-acetylated amino acids\n    n_acetylated_amino_acid = 'C(C)=O[N][C][C](=O)[O,H]'\n    \n    # Ketone group adjacent to aromatic ring and linked to carboxylic acid via aliphatic chain\n    aromatic_ketone_chain = '[c][C](=O)[C][C](=O)[O,H]'\n    \n    # Fused aromatic systems with carboxylic acid groups\n    fused_aromatic_carboxylic_acid = '[c]1[c][c][c][c][c]1[C](=O)[O,H]'\n    \n    # Define the rules with their associated patterns and predictions\n    rules = [\n        {   # Rule 1\n            'number': 1,\n            'description': 'High yield for aromatic carboxylic acids with electron-withdrawing substituents at para position.',\n            'patterns': [\n                ['[c][C](=O)[O,H]'],  # Aromatic carboxylic acid\n                ewg_on_aromatic       # EWG on aromatic ring\n            ],\n            'prediction': 1\n        },\n        {   # Rule 2\n            'number': 2,\n            'description': 'Low yield for aromatic carboxylic acids with electron-donating substituents at para position.',\n            'patterns': [\n                ['[c][C](=O)[O,H]'],  # Aromatic carboxylic acid\n                edg_on_aromatic       # EDG on aromatic ring\n            ],\n            'prediction': -1\n        },\n        {   # Rule 3\n            'number': 3,\n            'description': 'High yield for heteroaromatic carboxylic acids.',\n            'patterns': [\n                ['[n,o,s][c]:[c]:[c]:[c]:[c][C](=O)[O,H]']  # Heteroaromatic carboxylic acid\n            ],\n            'prediction': 1\n        },\n        {   # Rule 4\n            'number': 4,\n            'description': 'High yield for aliphatic carboxylic acids with unbranched chains >=6 carbons without polar groups.',\n            'patterns': [\n                ['[CH3][CH2][CH2][CH2][CH2][CH2][C](=O)[O,H]']  # Octanoic acid as example\n            ],\n            'exclude_patterns': [\n                ['[N]', '[O]', '[S]']  # Exclude polar groups\n            ],\n            'prediction': 1\n        },\n        {   # Rule 5\n            'number': 5,\n            'description': 'High yield for short-chain (<=5 carbons) aliphatic amino acids.',\n            'patterns': [\n                ['[N][CH2][CH2][CH2][C](=O)[O,H]']  # 5-Aminopentanoic acid as example\n            ],\n            'prediction': 1\n        },\n        {   # Rule 6\n            'number': 6,\n            'description': 'High yield for amino acids with indole-containing side chains; low yield for phenyl-containing side chains.',\n            'patterns': [\n                ['[N][C][C](=O)[O,H]', indole_side_chain],  # Indole side chain\n            ],\n            'prediction': 1\n        },\n        {   # Rule 7\n            'number': 7,\n            'description': 'High yield for modifiers containing multiple hydroxyl groups on aliphatic chains.',\n            'patterns': [\n                [polyhydroxy_chain],  # Multiple hydroxyl groups\n            ],\n            'prediction': 1\n        },\n        {   # Rule 8\n            'number': 8,\n            'description': 'High yield for modifiers containing aromatic rings connected via longer aliphatic chains (>3 carbons) to carboxylic acids.',\n            'patterns': [\n                [long_chain_to_aromatic],  # Long aliphatic chain to aromatic ring\n            ],\n            'prediction': 1\n        },\n        {   # Rule 9\n            'number': 9,\n            'description': 'Low yield for modifiers with fluorinated alkyl chains.',\n            'patterns': [\n                [fluorinated_chain],  # Fluorinated chains\n            ],\n            'prediction': -1\n        },\n        {   # Rule 10\n            'number': 10,\n            'description': 'Low yield for modifiers containing aldehyde groups attached to aromatic rings.',\n            'patterns': [\n                [aromatic_aldehyde],  # Aldehyde on aromatic ring\n            ],\n            'prediction': -1\n        },\n        {   # Rule 11\n            'number': 11,\n            'description': 'Low yield for modifiers with ether linkages in aliphatic chains.',\n            'patterns': [\n                [ether_linkage],  # Ether linkage\n            ],\n            'prediction': -1\n        },\n        {   # Rule 12\n            'number': 12,\n            'description': 'High yield for thiol groups on short aliphatic chains; low yield if attached to aromatic rings.',\n            'patterns': [\n                [thiol_short_chain],  # Thiol on short chain\n            ],\n            'prediction': 1\n        },\n        {   # Rule 13\n            'number': 13,\n            'description': 'Low yield for N-acetylated amino acids.',\n            'patterns': [\n                [n_acetylated_amino_acid],  # N-acetylated amino acid\n            ],\n            'prediction': -1\n        },\n        {   # Rule 14\n            'number': 14,\n            'description': 'High yield for modifiers with ketone groups adjacent to aromatic rings and linked to carboxylic acids via aliphatic chains.',\n            'patterns': [\n                [aromatic_ketone_chain],  # Ketone adjacent to aromatic ring\n            ],\n            'prediction': 1\n        },\n        {   # Rule 15\n            'number': 15,\n            'description': 'High yield for modifiers containing fused aromatic systems with carboxylic acid groups.',\n            'patterns': [\n                [fused_aromatic_carboxylic_acid],  # Fused aromatic carboxylic acid\n            ],\n            'prediction': 1\n        }\n    ]\n    \n    # Compile all SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for group in rule.get('patterns', []):\n            compiled_group = [Chem.MolFromSmarts(pat) for pat in group]\n            compiled_patterns.append(compiled_group)\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for group in rule['exclude_patterns']:\n                compiled_group = [Chem.MolFromSmarts(pat) for pat in group]\n                compiled_excludes.append(compiled_group)\n            rule['compiled_exclude_patterns'] = compiled_excludes\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for group in rule['compiled_exclude_patterns']:\n                        for pat in group:\n                            if mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                        if not match:\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for compiled_group in rule['compiled_patterns']:\n                    group_match = False\n                    for pat in compiled_group:\n                        matches = mol.GetSubstructMatches(pat)\n                        if matches:\n                            group_match = True\n                            break\n                    if not group_match:\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}