{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit based on the provided rules. Each rule is translated into SMARTS patterns to identify specific substructures in the molecules. The function `rule2matrix` processes each SMILES string, checks it against each rule, and assigns a value of 1, -1, or 0 according to the matching criteria. The result is a DataFrame with rows corresponding to the input SMILES strings and columns corresponding to the rules.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import rdMolDescriptors",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1]'\n    # Amino group (-NH2) attached to alpha carbon\n    alpha_amino_group = '[C;!R][CH](N)[C](=O)[O]'\n    # Dicarboxylic acid (two carboxylic acid groups)\n    dicarboxylic_acid = '[C;!R][CH](N)([C](=O)[O])[C](=O)[O]'\n    \n    # Nitrogen-containing heterocycles directly attached to carboxylic acids\n    nitrogen_heterocycle_carboxylic_acid = '[#1]c1ncccc1C(=O)O'\n    \n    # Para-substituted benzoic acids with EWG or coordinating groups\n    para_substituted_benzoic_acid = 'c1ccc(cc1)[CX3](=O)[OX1H0-,OX2H1]'\n    # Electron-withdrawing groups (EWGs) or coordinating groups at para position\n    ewgs_or_coordinating_groups = ['[NX3+](=O)[O-]', '[NX3](=O)=O', '[F,Cl,Br,I]', '[NX3;H2,H1][CX4H]']\n    \n    # Straight-chain aliphatic carboxylic acids without terminal polar groups\n    straight_chain_aliphatic_carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1][CH2]n[CH3]'\n    terminal_polar_groups = ['[NX3;H2,H1,H0]','[OX2H]','[SX2H]']\n    \n    # Thiol groups on aliphatic chains\n    thiol_on_aliphatic_chain = '[CX4][CH2][SX2H]'\n    # Thiol groups on aromatic rings\n    thiol_on_aromatic_ring = 'c[SX2H]'\n    \n    # Multiple hydroxyl groups on aliphatic chains\n    aliphatic_chain_with_multiple_hydroxyls = '[CX3](=O)[OX1H0-,OX2H1][CH2][CH](O)[CH](O)[CH2][OH]'\n    \n    # Functional groups that interfere with coordination\n    interfering_groups = ['[CX3](=O)[CH](=O)', '[C,F,Cl,Br,I][C](F)(F)F', '[OX2][CX2][CX2][OX2]', '[CX3](=O)[NX3][CX3](=O)[CX4]']\n    \n    # \u03b1-Amino monocarboxylic acids with hydrophobic side chains\n    alpha_amino_mono_carboxylic_acid_hydrophobic = '[C;!R][CH](N)[C](=O)[O][C][C][C]'\n    # Exception for indole rings\n    indole_ring = 'c1ccc2c(c1)cc[nH]2'\n    \n    # Aromatic rings connected via medium-length aliphatic chains\n    aromatic_ring_with_aliphatic_chain = '[CX3](=O)[OX1H0-,OX2H1][CH2][CH2][CH2][c]'\n    \n    # Fused aromatic rings with electron-withdrawing groups\n    fused_aromatic_with_ewg = 'c1ccc2c(c1)c(=O)oc2C(=O)O'\n    \n    # Compile SMARTS patterns\n    patterns = {\n        'Rule 1': {\n            'patterns': [dicarboxylic_acid],\n            'prediction': 1\n        },\n        'Rule 2': {\n            'patterns': [nitrogen_heterocycle_carboxylic_acid],\n            'prediction': 1\n        },\n        'Rule 3': {\n            'patterns': [para_substituted_benzoic_acid],\n            'sub_patterns': ewgs_or_coordinating_groups,\n            'prediction': 1\n        },\n        'Rule 4': {\n            'patterns': [straight_chain_aliphatic_carboxylic_acid],\n            'exclude_patterns': terminal_polar_groups,\n            'prediction': 1\n        },\n        'Rule 5 High': {\n            'patterns': [thiol_on_aliphatic_chain],\n            'prediction': 1\n        },\n        'Rule 5 Low': {\n            'patterns': [thiol_on_aromatic_ring],\n            'prediction': -1\n        },\n        'Rule 6': {\n            'patterns': [aliphatic_chain_with_multiple_hydroxyls],\n            'prediction': 1\n        },\n        'Rule 7': {\n            'patterns': interfering_groups,\n            'prediction': -1\n        },\n        'Rule 8 Low': {\n            'patterns': [alpha_amino_mono_carboxylic_acid_hydrophobic],\n            'exclude_patterns': [indole_ring],\n            'prediction': -1\n        },\n        'Rule 8 High': {\n            'patterns': [indole_ring],\n            'prediction': 1\n        },\n        'Rule 9': {\n            'patterns': [aromatic_ring_with_aliphatic_chain],\n            'prediction': 1\n        },\n        'Rule 10': {\n            'patterns': [fused_aromatic_with_ewg],\n            'prediction': 1\n        }\n    }\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(patterns))\n            continue\n        row = []\n        for rule_name, rule in patterns.items():\n            try:\n                match = False\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    exclude = False\n                    for exclude_smarts in rule['exclude_patterns']:\n                        exclude_pattern = Chem.MolFromSmarts(exclude_smarts)\n                        if mol.HasSubstructMatch(exclude_pattern):\n                            exclude = True\n                            break\n                    if exclude:\n                        row.append(0)\n                        continue\n                # Check main patterns\n                for smarts in rule['patterns']:\n                    pattern = Chem.MolFromSmarts(smarts)\n                    if mol.HasSubstructMatch(pattern):\n                        # For Rule 3, check sub-patterns\n                        if 'sub_patterns' in rule:\n                            sub_match = False\n                            for sub_smarts in rule['sub_patterns']:\n                                sub_pattern = Chem.MolFromSmarts(sub_smarts)\n                                if mol.HasSubstructMatch(sub_pattern):\n                                    sub_match = True\n                                    break\n                            if sub_match:\n                                match = True\n                                break\n                        else:\n                            match = True\n                            break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception:\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=patterns.keys())\n    return df\n"
}