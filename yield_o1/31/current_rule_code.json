{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit, following the provided rules.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and substructures\n    \n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Amino acid backbone (alpha amino acid)\n    alpha_amino_acid = '[NX3][CX4H]([#6])[CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Additional carboxyl group (not part of the backbone)\n    additional_carboxylic_acid = '[C;!$(C=O)][CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Aromatic carboxylic acid\n    aromatic_carboxylic_acid = '[c][CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Para-substituted groups capable of metal coordination\n    para_amino = 'c1cc(N)c(cc1)[CX3](=O)[OX1H0-,OX2H1]'\n    para_nitro = 'c1cc([NX3](=O)=O)c(cc1)[CX3](=O)[OX1H0-,OX2H1]'\n    para_bromomethyl = 'c1cc(CBr)c(cc1)[CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Heteroaromatic carboxylic acids containing nitrogen atoms\n    heteroaromatic_nitrogen = '[n][c][CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Aliphatic carboxylic acids with chain lengths of eight carbons or fewer\n    aliphatic_carboxylic_acid = '[#6]-[CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Coordinating groups near the carboxyl end (e.g., amino or thiol)\n    amino_group = '[NX3;H2,H1][#6]'\n    thiol_group = '[#6][SX2H]'\n    \n    # Polyhydroxylated carboxylic acids (multiple hydroxyl groups)\n    hydroxyl_group = '[OX2H]'\n    \n    # Ether linkages (-O-) within carbon chains\n    ether_linkage = '[#6][OX2][#6]'\n    \n    # Electron-withdrawing groups adjacent to the carboxylic acid\n    formyl_group = '[CX3H0](=O)[#6]'\n    fluorinated_alkyl = '[CX4]([F,Cl,Br,I])[#6]'\n    \n    # Bulky substituents or sterically hindering groups near coordination sites\n    bulky_group = '[CX4]([C])[C]'\n    \n    # Aromatic carboxylic acids with flexible aliphatic linkers and coordinating substituents\n    flexible_linker = '[c][CX3](=O)[OX1H0-,OX2H1][C][C][C][c,N]'\n    \n    # Alpha-amino acids with side chains containing heteroatoms capable of chelation (e.g., indole ring)\n    indole_side_chain = '[NX3][CX4H]([#6])[CX3](=O)[OX1H0-,OX2H1][#6][#6]c1c[nH]c2ccccc12'\n    \n    # Compile SMARTS patterns\n    pattern_dict = {\n        'carboxylic_acid': Chem.MolFromSmarts(carboxylic_acid),\n        'alpha_amino_acid': Chem.MolFromSmarts(alpha_amino_acid),\n        'additional_carboxylic_acid': Chem.MolFromSmarts(additional_carboxylic_acid),\n        'aromatic_carboxylic_acid': Chem.MolFromSmarts(aromatic_carboxylic_acid),\n        'para_amino': Chem.MolFromSmarts(para_amino),\n        'para_nitro': Chem.MolFromSmarts(para_nitro),\n        'para_bromomethyl': Chem.MolFromSmarts(para_bromomethyl),\n        'heteroaromatic_nitrogen': Chem.MolFromSmarts(heteroaromatic_nitrogen),\n        'aliphatic_carboxylic_acid': Chem.MolFromSmarts(aliphatic_carboxylic_acid),\n        'amino_group': Chem.MolFromSmarts(amino_group),\n        'thiol_group': Chem.MolFromSmarts(thiol_group),\n        'hydroxyl_group': Chem.MolFromSmarts(hydroxyl_group),\n        'ether_linkage': Chem.MolFromSmarts(ether_linkage),\n        'formyl_group': Chem.MolFromSmarts(formyl_group),\n        'fluorinated_alkyl': Chem.MolFromSmarts(fluorinated_alkyl),\n        'bulky_group': Chem.MolFromSmarts(bulky_group),\n        'flexible_linker': Chem.MolFromSmarts(flexible_linker),\n        'indole_side_chain': Chem.MolFromSmarts(indole_side_chain)\n    }\n    \n    # Define the rules with their associated patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are \u03b1-amino dicarboxylic acids (\u03b1-amino acids with an additional carboxyl group in the side chain).',\n            'patterns': ['alpha_amino_acid', 'additional_carboxylic_acid'],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Aromatic carboxylic acids with para-substituted groups capable of metal coordination (amino, nitro, or bromomethyl).',\n            'patterns': ['para_amino', 'para_nitro', 'para_bromomethyl'],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Heteroaromatic carboxylic acids containing nitrogen atoms in the ring.',\n            'patterns': ['heteroaromatic_nitrogen'],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Aliphatic carboxylic acids with chain lengths of eight carbons or fewer with coordinating groups near the carboxyl end.',\n            'patterns': ['aliphatic_carboxylic_acid'],\n            'additional_patterns': ['amino_group', 'thiol_group'],\n            'max_chain_length': 8,\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers that are polyhydroxylated carboxylic acids (multiple hydroxyl groups).',\n            'patterns': ['carboxylic_acid', 'hydroxyl_group'],\n            'hydroxyl_count': 2,\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers that contain ether linkages (-O-) within their carbon chains.',\n            'patterns': ['ether_linkage'],\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers with electron-withdrawing groups adjacent to the carboxylic acid (formyl groups or fluorinated alkyl chains).',\n            'patterns': ['formyl_group', 'fluorinated_alkyl'],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers with bulky substituents or sterically hindering groups near potential coordination sites.',\n            'patterns': ['bulky_group'],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Aromatic carboxylic acids with flexible aliphatic linkers and coordinating substituents on the aromatic ring.',\n            'patterns': ['flexible_linker'],\n            'prediction': 1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers that are \u03b1-amino acids with side chains containing heteroatoms capable of chelation (e.g., indole ring).',\n            'patterns': ['indole_side_chain'],\n            'prediction': 1\n        }\n    ]\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = False\n                # Check all patterns for the rule\n                for pat_name in rule['patterns']:\n                    pat = pattern_dict[pat_name]\n                    if mol.HasSubstructMatch(pat):\n                        match = True\n                        # Additional checks for specific rules\n                        if rule['number'] == 1:\n                            # Rule 1: Check for at least two carboxyl groups\n                            num_carboxyl_groups = len(mol.GetSubstructMatches(pattern_dict['carboxylic_acid']))\n                            if num_carboxyl_groups < 2:\n                                match = False\n                                break\n                        elif rule['number'] == 4:\n                            # Rule 4: Check chain length and presence of coordinating group\n                            # Get the longest carbon chain\n                            chains = Chem.GetMolFrags(mol, asMols=True, sanitizeFrags=False)\n                            max_chain = 0\n                            for chain in chains:\n                                num_carbons = len([atom for atom in chain.GetAtoms() if atom.GetAtomicNum() == 6])\n                                if num_carbons > max_chain:\n                                    max_chain = num_carbons\n                            if max_chain > rule['max_chain_length']:\n                                match = False\n                                break\n                            # Check for coordinating groups near carboxyl end\n                            amino_matches = mol.GetSubstructMatches(pattern_dict['amino_group'])\n                            thiol_matches = mol.GetSubstructMatches(pattern_dict['thiol_group'])\n                            if not amino_matches and not thiol_matches:\n                                match = False\n                                break\n                        elif rule['number'] == 5:\n                            # Rule 5: Check for multiple hydroxyl groups\n                            hydroxyl_matches = mol.GetSubstructMatches(pattern_dict['hydroxyl_group'])\n                            if len(hydroxyl_matches) < rule['hydroxyl_count']:\n                                match = False\n                                break\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df\n"
}