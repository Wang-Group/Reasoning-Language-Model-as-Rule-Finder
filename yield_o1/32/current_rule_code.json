{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit, following the provided rules. Each rule is converted into SMARTS patterns for substructure searches. The function 'rule2matrix' returns a DataFrame where each column corresponds to one rule, and each row corresponds to one SMILES string from the list.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    \n    # Hydroxyl group (-OH)\n    hydroxyl_group = '[OX2H]'\n    \n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX1H1]'\n    \n    # Pattern for Rule 2: Aromatic carboxylic acids with coordinating groups at para position\n    # Aromatic carboxylic acid with para-coordinating group (amino, hydroxyl, nitro)\n    rule2_pattern = 'c1cc([CX3](=O)[OX1H1])ccc1[OH,NH2,N+](=O)[O-]'\n    \n    # Rule 4 pattern: Unbranched aliphatic carboxylic acids with chain lengths of C6 to C8\n    rule4_pattern = '[CH3][CH2]{4,6}C(=O)[OX1H1]'\n    \n    # Rule 5: Polyhydroxy carboxylic acids (two or more hydroxyl groups and carboxylic acid)\n    # Patterns defined above\n    \n    # Rule 6: Perfluorinated carboxylic acids\n    perfluorinated_carboxylic_acid = '[CF3][CF2]{0,}[CX3](=O)[OX1H1]'\n    \n    # Rule 8: Aromatic carboxylic acids with ortho-substituted hydroxyl or formyl groups\n    rule8_pattern = '[OH,C=O][c]1ccc(cc1)C(=O)[OX1H1]'\n    \n    # Initialize rules list\n    rules = [\n        {\n            'number': 2,\n            'description': 'Modifiers that are aromatic carboxylic acids with functional groups capable of coordinating to the metal center at the para position (e.g., amino, nitro, hydroxyl) tend to result in a high yield.',\n            'patterns': [[rule2_pattern]],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers that are unbranched aliphatic carboxylic acids with chain lengths of C6 to C8 and without additional functional groups tend to result in a high yield.',\n            'patterns': [[rule4_pattern]],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers that are polyhydroxy carboxylic acids, containing multiple hydroxyl groups capable of chelation, tend to result in a high yield.',\n            'patterns': [[hydroxyl_group], [carboxylic_acid]],\n            'count_threshold': {'[OX2H]': 2},\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers that are perfluorinated carboxylic acids tend to result in a low yield due to strong electron-withdrawing effects.',\n            'patterns': [[perfluorinated_carboxylic_acid]],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers that are aromatic carboxylic acids with ortho-substituted hydroxyl or formyl groups capable of intramolecular hydrogen bonding tend to result in a low yield.',\n            'patterns': [[rule8_pattern]],\n            'prediction': -1\n        }\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for group in rule.get('patterns', []):\n            compiled_group = [Chem.MolFromSmarts(p) for p in group]\n            compiled_patterns.append(compiled_group)\n        rule['compiled_patterns'] = compiled_patterns\n        \n        # Compile count_threshold patterns if any\n        if 'count_threshold' in rule:\n            compiled_count_threshold = {}\n            for smarts, threshold in rule['count_threshold'].items():\n                pat = Chem.MolFromSmarts(smarts)\n                compiled_count_threshold[pat] = threshold\n            rule['compiled_count_threshold'] = compiled_count_threshold\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                \n                # Check required patterns\n                for i, compiled_group in enumerate(rule['compiled_patterns']):\n                    group_match = False\n                    for pat in compiled_group:\n                        matches = mol.GetSubstructMatches(pat)\n                        if matches:\n                            # If a count threshold is specified for this pattern\n                            if 'compiled_count_threshold' in rule and pat in rule['compiled_count_threshold']:\n                                threshold = rule['compiled_count_threshold'][pat]\n                                if len(matches) >= threshold:\n                                    group_match = True\n                                    break\n                            else:\n                                group_match = True\n                                break\n                    if not group_match:\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    \n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}