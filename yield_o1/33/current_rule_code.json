{
    "prefix": "This code defines a function 'rule2matrix' that converts a list of SMILES strings into a feature matrix using RDKit, following the specified rules. Each rule is defined using SMARTS patterns, and the function returns a DataFrame where each column corresponds to one rule and each row corresponds to one SMILES string from the input list.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Amino group (-NH2)\n    amino_group = '[NX3][H2]'\n    \n    # Hydroxy group (-OH)\n    hydroxy_group = '[OX2H]'\n    \n    # Thiol group (-SH)\n    thiol_group = '[SX2H]'\n    \n    # Aliphatic chain of \u22645 carbons\n    short_aliphatic_chain = '[C;X4H2][C;X4H2][C;X4H2][C;X4H2][C;X4H2]'\n    \n    # Aliphatic chain of \u22656 carbons\n    long_aliphatic_chain = '[C;X4H2][C;X4H2][C;X4H2][C;X4H2][C;X4H2][C;X4H2]'\n    \n    # Aromatic ring\n    aromatic_ring = 'a'\n    \n    # Electron-donating groups (EDGs) on aromatic ring\n    edg_on_aromatic = ['[c][NX3;H2,H1]', '[c][OX2H]']\n    \n    # Electron-withdrawing groups (EWGs) on aromatic ring\n    ewg_on_aromatic = ['[c][NX3+](=O)[O-]', '[c][CX3](=O)[OX1H0-,OX2H1]', '[c][F,Cl,Br,I]']\n    \n    # Nitrogen-containing heterocycle with carboxylic acid group\n    nitrogen_heterocycle_carboxylic_acid = '[n,a][a][a][CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Polyether chain (-O-)\n    polyether_chain = '[#6][OX2][#6][OX2][#6]'\n    \n    # Bulky nonpolar aromatic side chain (e.g., phenylalanine)\n    bulky_aromatic_side_chain = '[CX4][CX3](=O)[NX3][CX4][c]'\n    \n    # Amide bond adjacent to aromatic ring\n    amide_adjacent_aromatic = '[c][CX3](=O)[NX3]'\n    \n    # Fluorinated alkyl chain or trifluoromethyl group\n    fluorinated_alkyl_chain = '[CX4][F,Cl,Br,I]'\n    trifluoromethyl_group = '[CX4](F)(F)F'\n    \n    # Thiol group on aromatic ring\n    thiol_on_aromatic = '[c][SX2H]'\n    \n    # Ortho-substituted hydroxy or amino groups on aromatic ring\n    ortho_substituted_hydroxy_amino = '[c]1[c][c][c][c][c]1[OX2H,NX3;H2,H1]'\n    \n    # Amide bond within aliphatic chain\n    amide_within_aliphatic_chain = '[C][CX3](=O)[NX3][C]'\n    \n    # Aromatic ring separated from carboxylic acid by short aliphatic chain (2-4 carbons)\n    aromatic_ring_short_chain_carboxylic_acid = '[c][C;X4][C;X4][C;X4][CX3](=O)[OX1H0-,OX2H1]'\n    \n    # Define the rules with their associated patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are \u03b1-amino dicarboxylic acids (amino acids with two carboxyl groups) give high yield.',\n            'patterns': [\n                [amino_group],  # Amino group\n                [carboxylic_acid],  # Carboxylic acid group\n            ],\n            'count_thresholds': {\n                carboxylic_acid: 2  # At least two carboxylic acid groups\n            },\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers that are aromatic carboxylic acids with para-substituted electron-donating groups (e.g., amino, hydroxy) give high yield.',\n            'patterns': [\n                [aromatic_ring],  # Aromatic ring\n                [carboxylic_acid],  # Carboxylic acid group\n                edg_on_aromatic  # Electron-donating groups on aromatic ring\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers that are nitrogen-containing heterocyclic carboxylic acids give high yield.',\n            'patterns': [\n                [nitrogen_heterocycle_carboxylic_acid],  # Nitrogen-containing heterocycle with carboxylic acid\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers with short aliphatic chains (\u22645 carbons) bearing polar functional groups (e.g., amino, thiol) give high yield.',\n            'patterns': [\n                [short_aliphatic_chain],  # Short aliphatic chain\n                [amino_group, thiol_group],  # Polar functional groups\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers that are polyhydroxylated aliphatic carboxylic acids (sugar acids) give high yield.',\n            'patterns': [\n                [carboxylic_acid],  # Carboxylic acid group\n                [hydroxy_group],  # Hydroxy group\n            ],\n            'count_thresholds': {\n                hydroxy_group: 2  # At least two hydroxy groups\n            },\n            'prediction': 1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers that are aromatic carboxylic acids with para-substituted electron-withdrawing groups (e.g., nitro, formyl) give low yield.',\n            'patterns': [\n                [aromatic_ring],  # Aromatic ring\n                [carboxylic_acid],  # Carboxylic acid group\n                ewg_on_aromatic  # Electron-withdrawing groups on aromatic ring\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers with long aliphatic chains (\u22656 carbons) regardless of functional groups give low yield.',\n            'patterns': [\n                [long_aliphatic_chain],  # Long aliphatic chain\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers containing polyether chains (multiple ether linkages in aliphatic chains) give low yield.',\n            'patterns': [\n                [polyether_chain],  # Polyether chain\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers with bulky nonpolar aromatic side chains (e.g., phenyl groups) give low yield.',\n            'patterns': [\n                [bulky_aromatic_side_chain],  # Bulky aromatic side chain\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers containing amide bonds adjacent to aromatic rings give low yield.',\n            'patterns': [\n                [amide_adjacent_aromatic],  # Amide bond adjacent to aromatic ring\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers with fluorinated alkyl chains or trifluoromethyl groups give low yield.',\n            'patterns': [\n                [fluorinated_alkyl_chain, trifluoromethyl_group],  # Fluorinated groups\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers with thiol groups on aromatic rings give low yield.',\n            'patterns': [\n                [thiol_on_aromatic],  # Thiol group on aromatic ring\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers that are aromatic carboxylic acids with ortho-substituted hydroxy or amino groups give high yield.',\n            'patterns': [\n                [aromatic_ring],  # Aromatic ring\n                [carboxylic_acid],  # Carboxylic acid group\n                [ortho_substituted_hydroxy_amino],  # Ortho-substituted hydroxy or amino groups\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers with amide bonds within aliphatic chains give low yield.',\n            'patterns': [\n                [amide_within_aliphatic_chain],  # Amide bond within aliphatic chain\n            ],\n            'prediction': -1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers with aromatic rings separated from carboxylic acid groups by short aliphatic chains (2\u20134 carbons) give high yield.',\n            'patterns': [\n                [aromatic_ring_short_chain_carboxylic_acid],  # Aromatic ring separated by short chain to carboxylic acid\n            ],\n            'prediction': 1\n        },\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for group in rule.get('patterns', []):\n            compiled_group = [Chem.MolFromSmarts(p) for p in group]\n            compiled_patterns.append(compiled_group)\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for group in rule['exclude_patterns']:\n                compiled_group = [Chem.MolFromSmarts(p) for p in group]\n                compiled_excludes.append(compiled_group)\n            rule['compiled_exclude_patterns'] = compiled_excludes\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for group in rule['compiled_exclude_patterns']:\n                        for pat in group:\n                            if mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                        if not match:\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for idx, compiled_group in enumerate(rule['compiled_patterns']):\n                    group_match = False\n                    for pat in compiled_group:\n                        matches = mol.GetSubstructMatches(pat)\n                        if matches:\n                            # If a count threshold is specified for this pattern\n                            if 'count_thresholds' in rule and pat is not None:\n                                smarts = Chem.MolToSmarts(pat)\n                                if smarts in rule['count_thresholds']:\n                                    threshold = rule['count_thresholds'][smarts]\n                                    if len(matches) >= threshold:\n                                        group_match = True\n                                        break\n                                else:\n                                    group_match = True\n                                    break\n                            else:\n                                group_match = True\n                                break\n                    if not group_match:\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule[\"number\"]}' for rule in rules])\n    return df\n"
}