{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. Each column in the matrix corresponds to one of the specified rules, and each row corresponds to a SMILES string from the list. The code defines SMARTS patterns for each rule based on the structural descriptions provided. It uses substructure searches to check if a molecule matches the patterns. A value of 0 is assigned if the rule does not match the SMILES string, 1 if the rule matches and predicts a high target value, and -1 if the rule matches and predicts a low target value. Possible errors during processing are handled by assigning a value of 0.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    carboxylic_acid = '[CX3](=O)[OX2H1]'  # Carboxylic acid group (-COOH)\n    amino_group = '[NX3;H2,H1][CX4]'      # Primary or secondary amine attached to carbon\n    hydroxyl_group = '[OX2H]'             # Hydroxyl group (-OH)\n    sulfanyl_group = '[SX2H]'             # Sulfanyl (thiol) group\n    nitro_group = '[NX3](=O)[O-]'         # Nitro group (-NO2)\n    perfluoroalkyl = 'C(F)(F)F'           # Trifluoromethyl group as perfluoroalkyl\n    aromatic_ring = 'a'                   # Aromatic atom\n    aromatic_carboxylic_acid = '[a][CX3](=O)[OX2H1]'  # Aromatic carboxylic acid\n    ether_linkage = '[CX4][OX2][CX4]'     # Ether linkage (-O-)\n    amide_bond = '[CX3](=O)[NX3][CX3](=O)[OX2H1]'  # Amide bond linking to carboxylic acid\n    ketone_adjacent_carboxylic = '[CX3](=O)[CX3](=O)[OX2H1]'  # Ketone adjacent to carboxylic acid\n    \n    # Define SMARTS patterns for each rule\n    patterns = {\n        'Rule 1': {\n            'description': 'Modifiers that are \u03b1-amino dicarboxylic acids yield high',\n            'patterns': [\n                '[NX3;H2,H1][CX4][CX3](=O)[OX2H1]',  # \u03b1-amino acid\n            ],\n            'count_patterns': {carboxylic_acid: 2},  # At least two carboxylic acid groups\n            'prediction': 1\n        },\n        'Rule 2': {\n            'description': 'Modifiers that are aromatic carboxylic acids with para-amino or hydroxy groups yield high',\n            'patterns': [\n                '[cH]:[cH]:[c](:[cH]):[cH][c][CX3](=O)[OX2H1]',  # Para-amino or para-hydroxy benzoic acid\n            ],\n            'sub_patterns': [\n                '[c][NX3;H2,H1]',  # Para-amino group\n                '[c][OX2H]',       # Para-hydroxy group\n            ],\n            'prediction': 1\n        },\n        'Rule 3': {\n            'description': 'Modifiers that are heteroaromatic carboxylic acids with adjacent donor atoms yield high',\n            'patterns': [\n                '[n,c][n][c][CX3](=O)[OX2H1]',   # Heteroaromatic with adjacent donor atom to carboxylic acid\n            ],\n            'prediction': 1\n        },\n        'Rule 4': {\n            'description': 'Modifiers that are straight-chain aliphatic carboxylic acids without terminal polar groups yield high',\n            'patterns': [\n                'C{6}[CX3](=O)[OX2H1]',  # Aliphatic chain with 6 carbons ending with carboxylic acid\n            ],\n            'exclude_patterns': [\n                '[OX2H]',      # Exclude hydroxyl groups\n                '[NX3;H2,H1]', # Exclude amino groups\n            ],\n            'prediction': 1\n        },\n        'Rule 5': {\n            'description': 'Modifiers containing flexible polyether chains yield low',\n            'patterns': [\n                '(OCC){2,}',  # Polyether chain repeated at least twice\n            ],\n            'prediction': -1\n        },\n        'Rule 6': {\n            'description': 'Modifiers with sulfanyl groups adjacent to carboxylic acid yield high',\n            'patterns': [\n                '[SX2H][CX4][CX3](=O)[OX2H1]',  # Thiol group adjacent to carboxylic acid\n            ],\n            'prediction': 1\n        },\n        'Rule 7': {\n            'description': 'Modifiers that are aromatic carboxylic acids with para-nitro groups yield high',\n            'patterns': [\n                '[cH]:[cH]:[c](:[cH]):[cH][c][CX3](=O)[OX2H1]',  # Aromatic carboxylic acid\n            ],\n            'sub_patterns': [\n                '[c][NX3](=O)[OX1-]',  # Para-nitro group\n            ],\n            'prediction': 1\n        },\n        'Rule 8': {\n            'description': 'Modifiers with long aliphatic chains terminated with polar groups yield low',\n            'patterns': [\n                'C{5,}[OX2H,NX3;H2,H1]',  # Aliphatic chain of at least 5 carbons ending with polar group\n            ],\n            'prediction': -1\n        },\n        'Rule 9': {\n            'description': 'Modifiers with additional carbonyl groups near carboxylic acid yield low',\n            'patterns': [\n                '[CX3](=O)[CX3](=O)[OX2H1]',  # Adjacent carbonyl groups to carboxylic acid\n            ],\n            'prediction': -1\n        },\n        'Rule 10': {\n            'description': 'Modifiers with aromatic carboxylic acids linked via amide bonds yield low',\n            'patterns': [\n                '[c][CX3](=O)[NX3][CX3](=O)[OX2H1]',  # Amide bond linking aromatic ring to carboxylic acid\n            ],\n            'prediction': -1\n        },\n        'Rule 11': {\n            'description': 'Modifiers that are \u03b1-amino acids with heteroaromatic side chains yield high',\n            'patterns': [\n                '[NX3;H2,H1][CX4][CX3](=O)[OX2H1][c,n][c,n][c,n]',  # \u03b1-Amino acid with heteroaromatic side chain\n            ],\n            'prediction': 1\n        },\n        'Rule 12': {\n            'description': 'Modifiers with perfluoroalkyl groups yield low',\n            'patterns': [\n                'C(F)(F)(F)',  # Trifluoromethyl group\n            ],\n            'prediction': -1\n        },\n        'Rule 13': {\n            'description': 'Modifiers with multiple hydroxyl groups near carboxylic acid yield high',\n            'patterns': [\n                '[CX4](O)(O)[CX3](=O)[OX2H1]',  # Multiple hydroxyl groups near carboxylic acid\n            ],\n            'prediction': 1\n        },\n        'Rule 14': {\n            'description': 'Modifiers with ether linkages between carboxylic acid and side chains yield low',\n            'patterns': [\n                '[CX3](=O)[OX2][CX4][OX2]',  # Ether linkage between carboxylic acid and side chain\n            ],\n            'prediction': -1\n        },\n        'Rule 15': {\n            'description': 'Modifiers with aromatic ketones adjacent to carboxylic acid yield high',\n            'patterns': [\n                '[c][CX3](=O)[c][CX3](=O)[OX2H1]',  # Aromatic ketone adjacent to carboxylic acid\n            ],\n            'prediction': 1\n        },\n    }\n    \n    # Compile SMARTS patterns\n    for rule_key in patterns.keys():\n        rule = patterns[rule_key]\n        compiled_patterns = []\n        for smarts in rule['patterns']:\n            pat = Chem.MolFromSmarts(smarts)\n            if pat is not None:\n                compiled_patterns.append(pat)\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile sub-patterns if any\n        if 'sub_patterns' in rule:\n            compiled_sub_patterns = []\n            for smarts in rule['sub_patterns']:\n                pat = Chem.MolFromSmarts(smarts)\n                if pat is not None:\n                    compiled_sub_patterns.append(pat)\n            rule['compiled_sub_patterns'] = compiled_sub_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_exclude_patterns = []\n            for smarts in rule['exclude_patterns']:\n                pat = Chem.MolFromSmarts(smarts)\n                if pat is not None:\n                    compiled_exclude_patterns.append(pat)\n            rule['compiled_exclude_patterns'] = compiled_exclude_patterns\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(patterns))\n            continue\n        row = []\n        for rule_key in patterns.keys():\n            rule = patterns[rule_key]\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'compiled_exclude_patterns' in rule:\n                    for pat in rule['compiled_exclude_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                if not match:\n                    row.append(0)\n                    continue\n                # Check required patterns\n                for pat in rule['compiled_patterns']:\n                    if not mol.HasSubstructMatch(pat):\n                        match = False\n                        break\n                if not match:\n                    row.append(0)\n                    continue\n                # Check sub-patterns if any (e.g., for para-substituents)\n                if 'compiled_sub_patterns' in rule:\n                    sub_match = False\n                    for pat in rule['compiled_sub_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            sub_match = True\n                            break\n                    if not sub_match:\n                        match = False\n                if not match:\n                    row.append(0)\n                    continue\n                # Check count patterns if any\n                if 'count_patterns' in rule:\n                    for smarts, min_count in rule['count_patterns'].items():\n                        pattern = Chem.MolFromSmarts(smarts)\n                        if pattern is not None:\n                            matches = mol.GetSubstructMatches(pattern)\n                            if len(matches) < min_count:\n                                match = False\n                                break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=patterns.keys())\n    return df"
}