{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit according to the specified rules. Each rule corresponds to a specific structural pattern defined using SMARTS, and the function `rule2matrix` returns a DataFrame where each column represents a rule, and each row corresponds to a SMILES string from the input list.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\n",
    "code": "def rule2matrix(smiles_list):\n    # Define the rules with their associated SMARTS patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are alpha-amino acids with side-chain carboxyl groups yield a high yield.',\n            'patterns': [\n                '[NX3;H2][CX4H][CX4][CX3](=O)[OX2H1]',  # Alpha-amino acid backbone with side-chain carboxyl\n                '[CX3](=O)[OX2H1]'  # Side-chain carboxyl group\n            ],\n            'exclude_patterns': [],\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'Modifiers that are aliphatic carboxylic acids with unbranched carbon chains of five or more carbons and no polar substituents yield a high yield.',\n            'patterns': [\n                '[CX3](=O)[OX2H1][CH2][CH2][CH2][CH2][CH3]',  # Unbranched aliphatic carboxylic acid with 5 carbons\n            ],\n            'exclude_patterns': [\n                '[#6][!C;!H]'  # Exclude polar substituents\n            ],\n            'prediction': 1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers that are aromatic carboxylic acids substituted at the para position with strong electron-withdrawing groups yield a high yield.',\n            'patterns': [\n                'c1ccc(cc1)[CX3](=O)[OX2H1]',  # Aromatic carboxylic acid\n                'c1ccc([NX3+](=O)[O-])cc1'  # Para-substituted with nitro group\n            ],\n            'exclude_patterns': [],\n            'prediction': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers that are aromatic carboxylic acids with aldehyde groups directly attached to the aromatic ring yield a low yield.',\n            'patterns': [\n                'c1cc([CX3H]=O)ccc1[CX3](=O)[OX2H1]',  # Aromatic carboxylic acid with aldehyde\n            ],\n            'exclude_patterns': [],\n            'prediction': -1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers that are aliphatic carboxylic acids containing thiol groups yield a high yield; aromatic thiol carboxylic acids yield a low yield.',\n            'patterns': [\n                '[CX3](=O)[OX2H1][CX4][SX2H]',  # Aliphatic carboxylic acid with thiol\n            ],\n            'exclude_patterns': [],\n            'prediction': 1\n        },\n        {\n            'number': 5.1,\n            'description': 'Aromatic thiol carboxylic acids yield a low yield.',\n            'patterns': [\n                'c1cc([SX2H])ccc1[CX3](=O)[OX2H1]',  # Aromatic carboxylic acid with thiol\n            ],\n            'exclude_patterns': [],\n            'prediction': -1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers that are pyridine carboxylic acids with the carboxyl group directly attached to the pyridine ring yield a high yield.',\n            'patterns': [\n                'n1ccccc1[CX3](=O)[OX2H1]',  # Pyridine carboxylic acid\n            ],\n            'exclude_patterns': [],\n            'prediction': 1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers with multiple hydroxyl groups near the carboxyl group yield a high yield.',\n            'patterns': [\n                '[CX3](=O)[OX2H1][C;!H0]([OX2H])[C;!H0]([OX2H])[C;!H0]([OX2H])',  # Multiple hydroxyls near carboxyl\n            ],\n            'exclude_patterns': [],\n            'prediction': 1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers containing amide functional groups adjacent to the carboxylic acid yield a low yield.',\n            'patterns': [\n                '[CX3](=O)[NX3][CX3](=O)[OX2H1]',  # Amide adjacent to carboxylic acid\n            ],\n            'exclude_patterns': [],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers that are polyether carboxylic acids with ether linkages distant from the carboxyl group yield a low yield.',\n            'patterns': [\n                '[OX2][CX4][CX4][OX2][CX4][CX4][CX3](=O)[OX2H1]',  # Polyether chain ending with carboxylic acid\n            ],\n            'exclude_patterns': [],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers containing perfluorinated chains yield a low yield.',\n            'patterns': [\n                '[CX4]([F,Cl,Br,I])([F,Cl,Br,I])[CX4]([F,Cl,Br,I])([F,Cl,Br,I])[CX3](=O)[OX2H1]',  # Perfluorinated chain with carboxylic acid\n            ],\n            'exclude_patterns': [],\n            'prediction': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers that are aromatic carboxylic acids with methoxy groups on the aromatic ring yield a high yield.',\n            'patterns': [\n                'c1cc(OC)c(cc1)[CX3](=O)[OX2H1]',  # Methoxy-substituted aromatic carboxylic acid\n            ],\n            'exclude_patterns': [],\n            'prediction': 1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers that are simple aromatic carboxylic acids with alkyl substituents yield a low yield.',\n            'patterns': [\n                'c1cc([CX4H3])ccc1[CX3](=O)[OX2H1]',  # Alkyl-substituted aromatic carboxylic acid\n            ],\n            'exclude_patterns': [],\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers containing heterocyclic rings with additional coordinating heteroatoms yield a high yield.',\n            'patterns': [\n                '[n,o,s]1cccc1[CX3](=O)[OX2H1]',  # Heterocyclic ring with carboxylic acid\n            ],\n            'exclude_patterns': [],\n            'prediction': 1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers that are aromatic carboxylic acids with hydroxyl groups ortho to the carboxyl group yield a low yield.',\n            'patterns': [\n                'c1cc(c(c(c1)O)[CX3](=O)[OX2H1])',  # Ortho-hydroxylated aromatic carboxylic acid\n            ],\n            'exclude_patterns': [],\n            'prediction': -1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers with bulky substituents adjacent to coordinating groups yield a low yield.',\n            'patterns': [\n                '[CX3](=O)[OX2H1][CX4][CX3](=O)[CX4]([CX4]([CX4H3])[CX4H3])[CF3]',  # Bulky substituent near carboxyl\n            ],\n            'exclude_patterns': [],\n            'prediction': -1\n        },\n    ]\n\n    # Compile SMARTS patterns\n    for rule in rules:\n        compiled_patterns = []\n        for smarts in rule.get('patterns', []):\n            mol = Chem.MolFromSmarts(smarts)\n            compiled_patterns.append(mol)\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        compiled_excludes = []\n        for smarts in rule.get('exclude_patterns', []):\n            mol = Chem.MolFromSmarts(smarts)\n            compiled_excludes.append(mol)\n        rule['compiled_exclude_patterns'] = compiled_excludes\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                for pat in rule['compiled_exclude_patterns']:\n                    if mol.HasSubstructMatch(pat):\n                        match = False\n                        break\n                if not match:\n                    row.append(0)\n                    continue\n                # Check required patterns\n                for pat in rule['compiled_patterns']:\n                    if not mol.HasSubstructMatch(pat):\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df\n"
}