{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit. It applies 15 predefined rules to each molecule, assigning values based on the rules' structural descriptions and predicted target values.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for various functional groups and structural features\n    \n    # Functional groups and patterns for rules\n    # Rule 1: \u03b1-amino acids with coordinating functional groups within three carbons of the \u03b1-carbon\n    alpha_amino_acid = '[C@@H](N*)C(=O)O'  # Basic \u03b1-amino acid backbone\n    coordinating_groups_within_three_carbons = [\n        '[C;X4][C;X4][C;X4](O)',     # Hydroxyl group within three carbons\n        '[C;X4][C;X4][C;X4](N)',     # Amino group within three carbons\n        '[C;X4][C;X4][C;X4](S)',     # Sulfhydryl group within three carbons\n        '[C;X4][C;X4](C(=O)O)',     # Carboxyl group within three carbons\n    ]\n    \n    # Rule 2: \u03b1-amino acids with non-coordinating side chains\n    non_coordinating_alpha_amino_acid = alpha_amino_acid  # Same backbone without additional groups\n    \n    # Rule 3: Aromatic carboxylic acids with electron-withdrawing substituents at the para position\n    aromatic_carboxylic_acid = 'c1ccc(cc1)C(=O)O'\n    electron_withdrawing_para = [\n        'c1ccc([N+](=O)[O-])cc1',    # Nitro group at para position\n        'c1ccc(Br)cc1',              # Bromine at para position\n        'c1ccc(Cl)cc1',              # Chlorine at para position\n        'c1ccc(F)cc1',               # Fluorine at para position\n        'c1ccc(I)cc1',               # Iodine at para position\n    ]\n    \n    # Rule 4: Aromatic carboxylic acids with electron-donating substituents directly attached\n    electron_donating_direct = [\n        'c1ccc(O)cc1',               # Hydroxyl group directly attached\n        'c1ccc(OC)cc1',              # Methoxy group directly attached\n        'c1ccc(C)cc1',               # Methyl group directly attached\n    ]\n    \n    # Rule 5: Nitrogen-containing heterocyclic carboxylic acids\n    nitrogen_heterocycle_carboxylic_acid = [\n        'n1cccc1C(=O)O',             # Pyridine-3-carboxylic acid\n        'n1ccnc1C(=O)O',             # Pyrimidine carboxylic acid\n        'c1cnc(C(=O)O)cn1',          # Pyrazole-4-carboxylic acid\n    ]\n    \n    # Rule 6: Bulky aromatic systems directly adjacent to the carboxyl group\n    bulky_aromatic_adjacent = 'c1ccccc1cC(=O)O'  # Biphenyl carboxylic acid as example\n    \n    # Rule 7: Aromatic ring bearing coordinating groups connected via flexible chain (3-5 carbons)\n    aromatic_with_flexible_chain = [\n        '[OX2H][CX4][CX4][CX4][c]',  # Hydroxyl group connected via 3-carbon chain to aromatic ring\n        '[NX3H2][CX4][CX4][CX4][c]', # Amino group connected via 3-carbon chain to aromatic ring\n    ]\n    \n    # Rule 8: Flexible polyether chains terminating in carboxylic acid\n    polyether_chain = 'OCCOCCOCC(=O)O'  # Polyether chain example\n    \n    # Rule 9: Additional coordinating groups within three carbons of carboxyl group in aliphatic chains\n    coordinating_groups_near_carboxyl = [\n        '[C;X4][C;X4][OX2H]',        # Hydroxyl within three carbons of carboxyl\n        '[C;X4][C;X4][NX3H2]',       # Amino within three carbons of carboxyl\n        '[C;X4][C;X4][SX2H]',        # Thiol within three carbons of carboxyl\n    ]\n    \n    # Rule 10: Strong electron-withdrawing perfluoroalkyl groups adjacent to carboxyl group\n    perfluoroalkyl_adjacent = 'C(F)(F)C(=O)O'  # Example with CF2 group\n    \n    # Rule 11: Functional groups located more than three carbons away from carboxyl group\n    distant_functional_groups = [\n        '[C;X4][C;X4][C;X4][C;X4][OX2H]',  # Hydroxyl group more than three carbons away\n        '[C;X4][C;X4][C;X4][C;X4][NX3H2]', # Amino group more than three carbons away\n    ]\n    \n    # Rule 12: Unbranched medium-chain aliphatic carboxylic acids without additional functional groups\n    unbranched_aliphatic_acid = 'CCCCCCCC(=O)O'  # Octanoic acid example\n    \n    # Rule 13: Aldehyde, ketone, or acylamide groups adjacent to carboxyl group\n    adjacent_electrophilic_groups = [\n        '[CX3](=O)[CX3H1]',          # Ketone adjacent to carboxyl\n        '[CX3H1](=O)[CX3](=O)O',     # Aldehyde adjacent to carboxyl\n        'NC(=O)[CX3](=O)O',          # Amide adjacent to carboxyl\n    ]\n    \n    # Rule 14: Conjugated systems adjacent to carboxyl group with heteroatoms\n    conjugated_systems_with_heteroatoms = [\n        '[c][c][c](=O)O',            # Aromatic system adjacent to carboxyl\n        '[c][n][c](=O)O',            # Heteroaromatic adjacent to carboxyl\n    ]\n    \n    # Rule 15: Aromatic carboxylic acids with electron-donating groups serving as coordinating sites\n    aromatic_with_donating_groups = [\n        'c1ccc(N)cc1C(=O)O',         # Amino group on aromatic ring\n        'c1ccc(O)cc1C(=O)O',         # Hydroxyl group on aromatic ring\n    ]\n    \n    # Compile all patterns\n    patterns = {\n        1: {\n            'patterns': [alpha_amino_acid] + coordinating_groups_within_three_carbons,\n            'prediction': 1\n        },\n        2: {\n            'patterns': [non_coordinating_alpha_amino_acid],\n            'exclude': coordinating_groups_within_three_carbons,\n            'prediction': -1\n        },\n        3: {\n            'patterns': [aromatic_carboxylic_acid] + electron_withdrawing_para,\n            'prediction': 1\n        },\n        4: {\n            'patterns': electron_donating_direct + [aromatic_carboxylic_acid],\n            'prediction': -1\n        },\n        5: {\n            'patterns': nitrogen_heterocycle_carboxylic_acid,\n            'prediction': 1\n        },\n        6: {\n            'patterns': [bulky_aromatic_adjacent],\n            'prediction': -1\n        },\n        7: {\n            'patterns': aromatic_with_flexible_chain,\n            'prediction': 1\n        },\n        8: {\n            'patterns': [polyether_chain],\n            'prediction': -1\n        },\n        9: {\n            'patterns': coordinating_groups_near_carboxyl,\n            'prediction': 1\n        },\n        10: {\n            'patterns': [perfluoroalkyl_adjacent],\n            'prediction': -1\n        },\n        11: {\n            'patterns': distant_functional_groups,\n            'prediction': -1\n        },\n        12: {\n            'patterns': [unbranched_aliphatic_acid],\n            'prediction': 1\n        },\n        13: {\n            'patterns': adjacent_electrophilic_groups,\n            'prediction': -1\n        },\n        14: {\n            'patterns': conjugated_systems_with_heteroatoms,\n            'prediction': 1\n        },\n        15: {\n            'patterns': aromatic_with_donating_groups,\n            'prediction': 1\n        },\n    }\n    \n    # Compile SMARTS patterns\n    for rule_num, rule in patterns.items():\n        compiled_patterns = []\n        for smarts in rule.get('patterns', []):\n            mol = Chem.MolFromSmarts(smarts)\n            if mol:\n                compiled_patterns.append(mol)\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile exclude patterns if any\n        if 'exclude' in rule:\n            compiled_excludes = []\n            for smarts in rule['exclude']:\n                mol = Chem.MolFromSmarts(smarts)\n                if mol:\n                    compiled_excludes.append(mol)\n            rule['compiled_exclude'] = compiled_excludes\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*15)\n            continue\n        row = []\n        for rule_num in range(1,16):\n            rule = patterns[rule_num]\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'compiled_exclude' in rule:\n                    for pat in rule['compiled_exclude']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for pat in rule['compiled_patterns']:\n                    if not mol.HasSubstructMatch(pat):\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {i}' for i in range(1,16)])\n    return df\n"
}