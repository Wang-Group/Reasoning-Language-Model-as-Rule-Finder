{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDkit, following the specified rules.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    import pandas as pd\n    from rdkit import Chem\n    from rdkit.Chem import AllChem\n    \n    # Define SMARTS patterns for functional groups and structural features\n    \n    # Rule 1: Aliphatic carboxylic acids with chain lengths of 6 to 8 carbons and lacking terminal polar functional groups such as amino or hydroxyl groups tend to give high yield.\n    rule1_pattern = Chem.MolFromSmarts(\"[CH3][CH2]{4,6}[CX3](=O)[OX2H1]\")\n    rule1_exclude_patterns = [\n        Chem.MolFromSmarts(\"[NX3;H2]\"),  # Primary amino group\n        Chem.MolFromSmarts(\"[OX2H]\")      # Hydroxyl group\n    ]\n    \n    # Rule 2a: Amino acids with acidic side chains or containing multiple carboxylate groups tend to give high yield.\n    amino_acid_backbone = Chem.MolFromSmarts(\"[NX3;H2][CX4H][CX3](=O)[OX2H1]\")\n    carboxylic_acid = Chem.MolFromSmarts(\"[CX3](=O)[OX2H1]\")\n    \n    # Rule 2b: Amino acids with hydrophobic aromatic side chains lacking heteroatoms tend to give low yield.\n    aromatic_ring = Chem.MolFromSmarts(\"c1ccccc1\")\n    \n    # Rule 3: Amino acids with aromatic heterocycles in the side chain (e.g., tryptophan) tend to give high yield.\n    aromatic_heterocycle = Chem.MolFromSmarts(\"[n,o,s]\")  # Aromatic heteroatoms\n    \n    # Rule 4: N-acetylated amino acids tend to give low yield.\n    n_acetyl_group = Chem.MolFromSmarts(\"[NX3][CX3](=O)[#6]\")\n    \n    # Rule 5a: Aromatic carboxylic acids substituted with strong electron-withdrawing groups such as nitro or bromomethyl tend to give high yield.\n    aromatic_carboxylic_acid = Chem.MolFromSmarts(\"c[C](=O)[O]\")\n    nitro_group = Chem.MolFromSmarts(\"[NX3+(=O)[O-]]\")\n    bromomethyl_group = Chem.MolFromSmarts(\"[CH2Br]\")\n    \n    # Rule 5b: Aromatic carboxylic acids substituted with electron-donating groups like methyl or hydroxyl, or with reactive groups like aldehyde tend to give low yield.\n    methyl_group = Chem.MolFromSmarts(\"[CH3]\")\n    hydroxyl_group = Chem.MolFromSmarts(\"[OX2H]\")\n    aldehyde_group = Chem.MolFromSmarts(\"[CX3H](=O)\")\n    \n    # Rule 6a: Modifiers containing aliphatic thiol groups (-SH) tend to give high yield.\n    aliphatic_thiol = Chem.MolFromSmarts(\"[CX4][SX2H]\")\n    \n    # Rule 6b: Modifiers with thiol groups attached directly to aromatic rings tend to give low yield.\n    aromatic_thiol = Chem.MolFromSmarts(\"[c][SX2H]\")\n    \n    # Rule 7: Modifiers containing multiple hydroxyl groups near the carboxylic acid tend to give high yield.\n    # For simplicity, we check for at least two hydroxyl groups in the molecule\n    \n    # Rule 8: Modifiers containing ether linkages within aliphatic chains tend to give low yield.\n    ether_linkage = Chem.MolFromSmarts(\"[CX4][OX2][CX4]\")\n    \n    # Rule 9: Modifiers with perfluorinated alkyl chains or trifluoromethyl groups tend to give low yield.\n    trifluoromethyl_group = Chem.MolFromSmarts(\"[CX4](F)(F)F\")\n    perfluoro_alkyl_chain = Chem.MolFromSmarts(\"[CX4](F)(F)(F)[CX4](F)(F)F\")\n    \n    # Rule 10: Modifiers containing aldehyde groups attached directly to aromatic rings tend to give low yield.\n    aromatic_aldehyde = Chem.MolFromSmarts(\"[c][CX3H](=O)\")\n    \n    # Rule 11: Amino acids with aliphatic side chains longer than five carbons and terminal amino groups tend to give low yield.\n    long_aliphatic_chain_with_terminal_amino = Chem.MolFromSmarts(\"[NX3;H2][CX4][CH2][CH2][CH2][CH2][CH2][NX3;H2]\")\n    \n    # Rule 12: Modifiers containing indole groups (e.g., tryptophan) tend to give high yield.\n    indole_group = Chem.MolFromSmarts(\"c1cc2c(c1)[nH]c2\")\n    \n    # Rule 13: Modifiers with conjugated ketone groups adjacent to carboxylic acids tend to give high yield.\n    conjugated_ketone_adjacent_to_carboxylic_acid = Chem.MolFromSmarts(\"[CX3](=O)[CX3]=[CX3](=O)\")\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*13)\n            continue\n        row = []\n        try:\n            # Rule 1\n            match1 = mol.HasSubstructMatch(rule1_pattern)\n            exclude1 = any(mol.HasSubstructMatch(pat) for pat in rule1_exclude_patterns)\n            if match1 and not exclude1:\n                row.append(1)\n            else:\n                row.append(0)\n            \n            # Rule 2\n            match2a = mol.HasSubstructMatch(amino_acid_backbone) and len(mol.GetSubstructMatches(carboxylic_acid)) >= 2\n            match2b = mol.HasSubstructMatch(amino_acid_backbone) and mol.HasSubstructMatch(aromatic_ring)\n            if match2a:\n                row.append(1)\n            elif match2b:\n                row.append(-1)\n            else:\n                row.append(0)\n            \n            # Rule 3\n            match3 = mol.HasSubstructMatch(amino_acid_backbone) and mol.HasSubstructMatch(aromatic_heterocycle)\n            if match3:\n                row.append(1)\n            else:\n                row.append(0)\n            \n            # Rule 4\n            match4 = mol.HasSubstructMatch(n_acetyl_group)\n            if match4:\n                row.append(-1)\n            else:\n                row.append(0)\n            \n            # Rule 5\n            match5a = mol.HasSubstructMatch(aromatic_carboxylic_acid) and (mol.HasSubstructMatch(nitro_group) or mol.HasSubstructMatch(bromomethyl_group))\n            match5b = mol.HasSubstructMatch(aromatic_carboxylic_acid) and (mol.HasSubstructMatch(methyl_group) or mol.HasSubstructMatch(hydroxyl_group) or mol.HasSubstructMatch(aldehyde_group))\n            if match5a:\n                row.append(1)\n            elif match5b:\n                row.append(-1)\n            else:\n                row.append(0)\n            \n            # Rule 6\n            match6a = mol.HasSubstructMatch(aliphatic_thiol)\n            match6b = mol.HasSubstructMatch(aromatic_thiol)\n            if match6a:\n                row.append(1)\n            elif match6b:\n                row.append(-1)\n            else:\n                row.append(0)\n            \n            # Rule 7\n            hydroxyl_matches = mol.GetSubstructMatches(hydroxyl_group)\n            if len(hydroxyl_matches) >=2 and mol.HasSubstructMatch(carboxylic_acid):\n                row.append(1)\n            else:\n                row.append(0)\n            \n            # Rule 8\n            match8 = mol.HasSubstructMatch(ether_linkage)\n            if match8:\n                row.append(-1)\n            else:\n                row.append(0)\n            \n            # Rule 9\n            match9 = mol.HasSubstructMatch(trifluoromethyl_group) or mol.HasSubstructMatch(perfluoro_alkyl_chain)\n            if match9:\n                row.append(-1)\n            else:\n                row.append(0)\n            \n            # Rule 10\n            match10 = mol.HasSubstructMatch(aromatic_aldehyde)\n            if match10:\n                row.append(-1)\n            else:\n                row.append(0)\n            \n            # Rule 11\n            match11 = mol.HasSubstructMatch(long_aliphatic_chain_with_terminal_amino)\n            if match11:\n                row.append(-1)\n            else:\n                row.append(0)\n            \n            # Rule 12\n            match12 = mol.HasSubstructMatch(indole_group)\n            if match12:\n                row.append(1)\n            else:\n                row.append(0)\n            \n            # Rule 13\n            match13 = mol.HasSubstructMatch(conjugated_ketone_adjacent_to_carboxylic_acid)\n            if match13:\n                row.append(1)\n            else:\n                row.append(0)\n            \n        except Exception as e:\n            # In case of any error, append 0s for this molecule\n            row = [0]*13\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {i}' for i in range(1,14)])\n    return df\n"
}