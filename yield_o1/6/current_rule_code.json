{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. Each column represents one rule, and each row corresponds to one SMILES string. The code applies multiple SMARTS patterns for each rule and uses RDKit's substructure search capabilities to identify matches. The rules are derived from structural features specified in the natural language rules provided. The code incorporates the suggestions provided to enhance the accuracy and coverage of the SMARTS patterns.",
    "imports": "import pandas as pd\nfrom rdkit import Chem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and structural features\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX1H]'\n    \n    from rdkit import Chem\n    import pandas as pd\n    \n    # Rule 1: Modifiers containing carboxylic acid and amino group within two carbon atoms\n    # Including amino group attached directly to alpha carbon\n    rule1_patterns = [\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4]([NX3;H2,H1])'),  # Amino group attached to alpha carbon\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][NX3;H2,H1]'),  # Amino group connected via one carbon\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][CX4][NX3;H2,H1]'),  # Amino group connected via two carbons\n    ]\n    \n    # Rule 2: Modifiers with carboxylic acid and multiple hydroxyl groups on adjacent carbons near the carboxyl group\n    rule2_pattern = Chem.MolFromSmarts('[CX3](=O)[OX1H][C;H1]([OX2H])[C;H1]([OX2H])[C;H1]([OX2H])')\n    \n    # Rule 3: Modifiers with carboxylic acid and aliphatic thiol groups within two to three carbons\n    rule3_patterns = [\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][SX2H]'),  # Thiol connected via one carbon\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][CX4][SX2H]'),  # Thiol connected via two carbons\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][CX4][CX4][SX2H]'),  # Thiol connected via three carbons\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4]([CX4][SX2H])'),  # Branched connection to thiol\n    ]\n    \n    # Rule 4: Modifiers with carboxylic acid and electron-withdrawing groups on aromatic rings (e.g., nitro or halogens)\n    # Pattern for aromatic ring with carboxylic acid and EWG attached\n    rule4_pattern = Chem.MolFromSmarts('c1ccc(cc1[CX3](=O)[OX1H])[F,Cl,Br,I,$(N(=O)=O)]')\n    \n    # Rule 5: Modifiers with carboxylic acid and electron-donating groups on aromatic rings yielding low yield\n    # Pattern for aromatic ring with carboxylic acid and EDG attached\n    rule5_pattern = Chem.MolFromSmarts('c1ccc(cc1[CX3](=O)[OX1H])[OX2H,NX3H2,$(OC)]')\n    \n    # Rule 6: Modifiers with carboxylic acid and nitrogen heterocycles directly attached or in short chains\n    rule6_patterns = [\n        Chem.MolFromSmarts('[n][c][CX3](=O)[OX1H]'),  # Nitrogen heterocycle directly attached to carboxylic acid\n        Chem.MolFromSmarts('[n][c][CX4][CX3](=O)[OX1H]'),  # Connected via one carbon\n        Chem.MolFromSmarts('[n][c][CX4][CX4][CX3](=O)[OX1H]'),  # Connected via two carbons\n    ]\n    \n    # Rule 7: Modifiers with bulky hydrophobic side chains yielding variable yields\n    # High yield if additional donor atoms are present\n    rule7_high_yield_patterns = [\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][CX4]([NX3;H2,H1])[c]'),  # Carboxylic acid connected to amino group and aromatic ring\n    ]\n    rule7_low_yield_patterns = [\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][CX4][c]'),  # Carboxylic acid connected to aromatic ring without donor atoms\n    ]\n    \n    # Rule 8: Modifiers with flexible ether linkages in aliphatic chains yielding low yield\n    # Pattern broadened as per suggestion\n    rule8_patterns = [\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][OX2][CX4]'),  # Ether linkage after one carbon\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][CX4][OX2][CX4]'),  # Ether linkage after two carbons\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][CX4][CX4][OX2][CX4]'),  # Ether linkage after three carbons\n    ]\n    \n    # Rule 9: Modifiers with carboxylic acid and additional carbonyl groups leading to competing coordination yielding low yield\n    rule9_pattern = Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][CX3](=O)')  # Carboxylic acid with adjacent carbonyl group\n    \n    # Rule 10: Aliphatic carboxylic acids without additional donor groups yielding low yield\n    # Need to exclude molecules with additional donor groups near the carboxylic acid\n    rule10_pattern = Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][CX4]')  # Carboxylic acid followed by two carbons\n    # Exclude patterns\n    rule10_excludes = [\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][!#6]'),  # Heteroatom connected to the first carbon after COOH\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][CX4][!#6]'),  # Heteroatom connected to the second carbon\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][*]=[O,N,S]'),  # Carbonyl group adjacent to carboxylic acid\n    ]\n    \n    # Rule 11: Modifiers with chelating groups in rigid ring systems yielding high yield\n    rule11_pattern = Chem.MolFromSmarts('O=C1C=CC(=O)C=C1C(=O)O')  # Chelating groups in cyclic structure\n    \n    # Rule 12: Modifiers with carboxylic acid and electron-withdrawing fluoroalkyl or sulfonyl groups yielding low yield\n    rule12_patterns = [\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][CX4]([CX3](F)(F)F)'),  # Carboxylic acid connected to trifluoromethyl group\n        Chem.MolFromSmarts('[CX3](=O)[OX1H][*][SX4](=O)(=O)[O]'),  # Carboxylic acid connected to sulfonyl group\n    ]\n    \n    # Rule 13: Modifiers with carboxylic acid and thioether groups yielding low yield\n    rule13_pattern = Chem.MolFromSmarts('[CX3](=O)[OX1H][CX4][SX2][CX4]')  # Carboxylic acid connected to thioether\n    \n    # Rule 14: Modifiers with carboxylic acid and adjacent amide groups yielding low yield\n    rule14_pattern = Chem.MolFromSmarts('[CX3](=O)[OX1H][NX3][CX3](=O)')  # Carboxylic acid adjacent to amide group\n    \n    # Construct the list of rules with their associated patterns and predictions\n    rules = [\n        {'name': 'Rule 1', 'patterns': rule1_patterns, 'prediction': 1},\n        {'name': 'Rule 2', 'patterns': [rule2_pattern], 'prediction': 1},\n        {'name': 'Rule 3', 'patterns': rule3_patterns, 'prediction': 1},\n        {'name': 'Rule 4', 'patterns': [rule4_pattern], 'prediction': 1},\n        {'name': 'Rule 5', 'patterns': [rule5_pattern], 'prediction': -1},\n        {'name': 'Rule 6', 'patterns': rule6_patterns, 'prediction': 1},\n        {'name': 'Rule 7 High Yield', 'patterns': rule7_high_yield_patterns, 'prediction': 1},\n        {'name': 'Rule 7 Low Yield', 'patterns': rule7_low_yield_patterns, 'prediction': -1},\n        {'name': 'Rule 8', 'patterns': rule8_patterns, 'prediction': -1},\n        {'name': 'Rule 9', 'patterns': [rule9_pattern], 'prediction': -1},\n        {'name': 'Rule 10', 'patterns': [rule10_pattern], 'excludes': rule10_excludes, 'prediction': -1},\n        {'name': 'Rule 11', 'patterns': [rule11_pattern], 'prediction': 1},\n        {'name': 'Rule 12', 'patterns': rule12_patterns, 'prediction': -1},\n        {'name': 'Rule 13', 'patterns': [rule13_pattern], 'prediction': -1},\n        {'name': 'Rule 14', 'patterns': [rule14_pattern], 'prediction': -1}\n    ]\n\n    # Initialize results list\n    results = []\n\n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns if any\n                if 'excludes' in rule:\n                    for exclude in rule['excludes']:\n                        if mol.HasSubstructMatch(exclude):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for patt in rule['patterns']:\n                    if not mol.HasSubstructMatch(patt):\n                        match = False\n                        break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[rule['name'] for rule in rules])\n    return df"
}