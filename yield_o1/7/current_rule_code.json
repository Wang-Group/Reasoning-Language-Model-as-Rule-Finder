{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit. It applies 15 chemical rules to each SMILES string and outputs a DataFrame where each column corresponds to one rule. Each rule is represented as a SMARTS pattern, and the code uses substructure matching to determine if a SMILES string matches a rule. The output matrix contains 1, -1, or 0 depending on the rule matching and the associated prediction.",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups\n    # General patterns\n    carboxylic_acid = '[CX3](=O)[OX1H0-,OX2H1]'\n    amino_group = '[NX3;H2,H1]'\n    alpha_amino_acid = '[NX3;H2,H1][CX4H][CX3](=O)[OX1H0-,OX2H1]'\n    aliphatic_chain = '[C;X4H2][C;X4H2][C;X4H2][C;X4H2]'\n    hydroxyl_group = '[OX2H]'\n    thiol_group = '[SX2H]'\n    ether_linkage = '[CX4][OX2][CX4]'\n    aromatic_ring = '[a]'\n    nitro_group = '[NX3](=O)[O-]'\n    halogen = '[F,Cl,Br,I]'\n    keto_group = '[CX3](=O)[#6]'\n    aldehyde_group = '[CX3H](=O)'\n    nitrogen_heterocycle = '[n]'\n    aromatic_nitrogen = '[n]'\n    perfluorinated_chain = '[CX4]([F])([F])[F]'\n    acylated_amino_group = '[NX3][CX3](=O)'\n    \n    # Rules list\n    rules = [\n        {\n            'number': 1,\n            'description': 'High yield: \u03b1-amino acids with side-chain carboxyl groups (-COOH).',\n            'patterns': [alpha_amino_acid, carboxylic_acid],\n            'count_threshold': {carboxylic_acid: 2},  # At least two carboxylic acid groups\n            'prediction': 1\n        },\n        {\n            'number': 2,\n            'description': 'High yield: Long-chain aliphatic carboxylic acids without additional functional groups.',\n            'patterns': [aliphatic_chain, carboxylic_acid],\n            'exclude_patterns': [hydroxyl_group, amino_group, thiol_group, ether_linkage],\n            'prediction': 1\n        },\n        {\n            'number': 2.1,\n            'description': 'Low yield: Aliphatic acids with additional polar groups along the chain.',\n            'patterns': [aliphatic_chain, carboxylic_acid],\n            'include_patterns': [hydroxyl_group, amino_group, thiol_group, ether_linkage],\n            'prediction': -1\n        },\n        {\n            'number': 3,\n            'description': 'High yield: Aromatic carboxylic acids with electron-withdrawing groups (EWGs) at the para position.',\n            'patterns': [carboxylic_acid],\n            'include_patterns': [nitro_group, halogen],\n            'prediction': 1\n        },\n        {\n            'number': 3.1,\n            'description': 'Low yield: Aromatic carboxylic acids with electron-donating groups (EDGs) at the para position.',\n            'patterns': [carboxylic_acid],\n            'include_patterns': [hydroxyl_group, '[OX2][CX4]', amino_group],\n            'prediction': -1\n        },\n        {\n            'number': 4,\n            'description': 'High yield: Nitrogen-containing heterocyclic carboxylic acids without bulky substituents.',\n            'patterns': [carboxylic_acid, nitrogen_heterocycle],\n            'prediction': 1\n        },\n        {\n            'number': 5,\n            'description': 'High yield: \u03b1-amino acids with nitrogen-containing aromatic side chains.',\n            'patterns': [alpha_amino_acid, aromatic_nitrogen],\n            'prediction': 1\n        },\n        {\n            'number': 5.1,\n            'description': 'Low yield: \u03b1-amino acids with non-nitrogenous aromatic side chains.',\n            'patterns': [alpha_amino_acid, '[c]'],\n            'exclude_patterns': [aromatic_nitrogen],\n            'prediction': -1\n        },\n        {\n            'number': 6,\n            'description': 'High yield: Aliphatic carboxylic acids with thiol groups (-SH) on the chain.',\n            'patterns': [aliphatic_chain, carboxylic_acid, thiol_group],\n            'exclude_patterns': [aromatic_ring],\n            'prediction': 1\n        },\n        {\n            'number': 6.1,\n            'description': 'Low yield: Thiol groups directly attached to an aromatic ring.',\n            'patterns': [thiol_group, aromatic_ring],\n            'prediction': -1\n        },\n        {\n            'number': 7,\n            'description': 'Low yield: Perfluorinated aliphatic carboxylic acids.',\n            'patterns': [perfluorinated_chain, carboxylic_acid],\n            'prediction': -1\n        },\n        {\n            'number': 8,\n            'description': 'Low yield: Aromatic carboxylic acids with aldehyde groups (-CHO) adjacent to the carboxyl group.',\n            'patterns': [carboxylic_acid, aldehyde_group],\n            'prediction': -1\n        },\n        {\n            'number': 9,\n            'description': 'Low yield: Aliphatic carboxylic acids with ether linkages (-O-) within the chain.',\n            'patterns': [aliphatic_chain, carboxylic_acid, ether_linkage],\n            'exclude_patterns': [aromatic_ring],\n            'prediction': -1\n        },\n        {\n            'number': 10,\n            'description': 'High yield: Polyhydroxy aliphatic acids (sugar acids).',\n            'patterns': [carboxylic_acid],\n            'count_threshold': {hydroxyl_group: 2},\n            'prediction': 1\n        },\n        {\n            'number': 11,\n            'description': 'Low yield: Acylated amino acids (amide derivatives).',\n            'patterns': [alpha_amino_acid, acylated_amino_group],\n            'prediction': -1\n        },\n        {\n            'number': 12,\n            'description': 'Low yield: Aromatic carboxylic acids with bulky substituents or extended conjugation.',\n            'patterns': [carboxylic_acid],\n            'include_patterns': ['[c][c][c][c][c][c]'],\n            'prediction': -1\n        },\n        {\n            'number': 13,\n            'description': 'High yield: Aromatic compounds with adjacent keto (=O) and carboxyl (-COOH) groups.',\n            'patterns': [carboxylic_acid, keto_group],\n            'prediction': 1\n        },\n        {\n            'number': 14,\n            'description': 'High yield: Aromatic carboxylic acids with methoxy groups (-OCH\u2083) and additional carbonyl groups within the side chain.',\n            'patterns': [carboxylic_acid, '[OX2][CX4][H3C]', keto_group],\n            'prediction': 1\n        },\n        {\n            'number': 15,\n            'description': 'Low yield: Aliphatic dicarboxylic acids with keto groups.',\n            'patterns': [carboxylic_acid, keto_group],\n            'count_threshold': {carboxylic_acid: 2},\n            'exclude_patterns': [aromatic_ring],\n            'prediction': -1\n        }\n    ]\n    \n    # Compile patterns\n    for rule in rules:\n        compiled_patterns = []\n        for p in rule['patterns']:\n            if isinstance(p, list):\n                compiled_group = [Chem.MolFromSmarts(sub_p) for sub_p in p]\n                compiled_patterns.append(compiled_group)\n            else:\n                compiled_patterns.append(Chem.MolFromSmarts(p))\n        rule['compiled_patterns'] = compiled_patterns\n        # Compile include patterns if any\n        if 'include_patterns' in rule:\n            compiled_include_patterns = [Chem.MolFromSmarts(p) for p in rule['include_patterns']]\n            rule['compiled_include_patterns'] = compiled_include_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_exclude_patterns = [Chem.MolFromSmarts(p) for p in rule['exclude_patterns']]\n            rule['compiled_exclude_patterns'] = compiled_exclude_patterns\n    \n    # Initialize results\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = True\n                # Check exclude patterns\n                if 'compiled_exclude_patterns' in rule:\n                    for pat in rule['compiled_exclude_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                    if not match:\n                        row.append(0)\n                        continue\n                # Check required patterns\n                for pat in rule['compiled_patterns']:\n                    if isinstance(pat, list):\n                        # At least one pattern in the group should match\n                        group_match = False\n                        for sub_pat in pat:\n                            if mol.HasSubstructMatch(sub_pat):\n                                group_match = True\n                                break\n                        if not group_match:\n                            match = False\n                            break\n                    else:\n                        if not mol.HasSubstructMatch(pat):\n                            match = False\n                            break\n                if not match:\n                    row.append(0)\n                    continue\n                # Check include patterns (at least one must match)\n                if 'compiled_include_patterns' in rule:\n                    include_match = False\n                    for pat in rule['compiled_include_patterns']:\n                        if mol.HasSubstructMatch(pat):\n                            include_match = True\n                            break\n                    if not include_match:\n                        match = False\n                if not match:\n                    row.append(0)\n                    continue\n                # Check count thresholds if any\n                if 'count_threshold' in rule:\n                    for smarts, threshold in rule['count_threshold'].items():\n                        sub_pat = Chem.MolFromSmarts(smarts)\n                        matches = mol.GetSubstructMatches(sub_pat)\n                        if len(matches) < threshold:\n                            match = False\n                            break\n                if match:\n                    row.append(rule['prediction'])\n                else:\n                    row.append(0)\n            except:\n                row.append(0)\n        results.append(row)\n    # Create DataFrame\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df"
}