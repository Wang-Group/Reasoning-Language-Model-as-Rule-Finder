{
    "prefix": "This code converts a list of SMILES strings into a feature matrix using RDKit, based on the specified rules. Each rule corresponds to a specific structural pattern, and the matrix indicates whether each SMILES string matches the rule and predicts a high (1) or low (-1) yield, or does not match the rule (0).",
    "imports": "import pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem",
    "code": "def rule2matrix(smiles_list):\n    # Define SMARTS patterns for functional groups and substructures\n    # Carboxylic acid group (-COOH)\n    carboxylic_acid = '[CX3](=O)[OX2H1]'\n    # Amino acid backbone (alpha-amino acid)\n    alpha_amino_acid = '[NX3][CX4H]([*])[CX3](=O)[OX1H0-,OX2H1]'\n    # Additional carboxylic acid group in side chain\n    side_chain_carboxylic_acid = '[CX3](=O)[OX2H1]'\n    \n    # Electron-withdrawing groups (EWGs) on aromatic ring\n    ewg_on_aromatic = '[c][NX3+](=O)[O-]', '[c][F,Cl,Br,I]', '[c][C](=O)[O;H1,-]'\n    # Electron-donating groups (EDGs) on aromatic ring\n    edg_on_aromatic = '[c][OX2H]', '[c][OX2][#6]', '[c][NX3;H2,H1][#6]'\n    \n    # Nitrogen heterocycles\n    nitrogen_heterocycle = '[n]'\n    \n    # Aliphatic thiol adjacent to carboxylic acid\n    aliphatic_thiol_adjacent_carboxy = '[SX2H][CX4][CX3](=O)[OX2H1]'\n    # Aromatic thiol\n    aromatic_thiol = '[c][SX2H]'\n    \n    # Hydroxyl groups adjacent to carboxylic acid\n    hydroxyl_adjacent_carboxy = '[OX2H][CX4][CX3](=O)[OX2H1]'\n    # Hydroxyl groups distant from carboxylic acid\n    hydroxyl_distant_carboxy = '[CX3](=O)[OX2H1]~[*]~[OX2H]'\n    \n    # Amino groups within three carbons of carboxylic acid\n    amino_within_three_carbons = '[NX3;H2,H1][CX4,CH2][CX4,CH2][CX3](=O)[OX2H1]'\n    # Amino groups distant from carboxylic acid\n    amino_distant = '[NX3;H2,H1]~[*]~[*]~[*]~[CX3](=O)[OX2H1]'\n    \n    # Ether linkages in backbone\n    ether_linkage = '[#6][OX2][#6]'\n    \n    # Fluorinated aliphatic chains\n    fluorinated_chain = '[CX4](F)(F)(F)'\n    \n    # Reactive carbonyl groups adjacent to carboxylic acid\n    reactive_carbonyl_adjacent_carboxy = '[CX3]=[OX1][CX3](=O)[OX2H1]'\n    \n    # Acylated amino groups\n    acylated_amino = '[NX3][CX3](=O)[#6]'\n    \n    # Biaryl structures\n    biaryl = '[c]-[c]-[c](=O)[OX2H1]'\n    \n    # Fused aromatic rings with additional oxygen functionalities\n    fused_aromatic_oxygen = '[c]1[c][c][o][c][c]1[CX3](=O)[OX2H1]'\n    \n    # Beta-phenylpropanoic acid structures\n    beta_phenylpropanoic_acid = '[c][CX4][CX2][CX3](=O)[OX2H1]'\n    \n    # Aromatic amino groups\n    aromatic_amino = '[c][NX3;H2,H1]'\n    \n    # Define the rules with their associated patterns and predictions\n    rules = [\n        {\n            'number': 1,\n            'description': 'Modifiers that are \u03b1-amino acids with additional carboxylic acid groups (acidic side chains) result in a high yield; \u03b1-amino acids with neutral or basic side chains result in a low yield.',\n            'high_patterns': [[alpha_amino_acid], [side_chain_carboxylic_acid]],\n            'low_patterns': [[alpha_amino_acid]],\n            'prediction_high': 1,\n            'prediction_low': -1\n        },\n        {\n            'number': 2,\n            'description': 'Aromatic carboxylic acids with electron-withdrawing substituents (EWGs) on the ring result in a high yield; those with electron-donating substituents (EDGs) result in a low yield.',\n            'high_patterns': [[carboxylic_acid], ewg_on_aromatic],\n            'low_patterns': [[carboxylic_acid], edg_on_aromatic],\n            'prediction_high': 1,\n            'prediction_low': -1\n        },\n        {\n            'number': 3,\n            'description': 'Modifiers that are aromatic carboxylic acids containing nitrogen heterocycles result in a high yield due to additional coordination via the nitrogen atom.',\n            'high_patterns': [[carboxylic_acid], [nitrogen_heterocycle]],\n            'prediction_high': 1\n        },\n        {\n            'number': 4,\n            'description': 'Modifiers with aliphatic thiol groups (\u2013SH) adjacent to the carboxylic acid result in a high yield; those with thiol groups on aromatic rings result in a low yield.',\n            'high_patterns': [[aliphatic_thiol_adjacent_carboxy]],\n            'low_patterns': [[aromatic_thiol]],\n            'prediction_high': 1,\n            'prediction_low': -1\n        },\n        {\n            'number': 5,\n            'description': 'Modifiers with aliphatic carboxylic acids having adjacent hydroxyl groups result in a high yield; those with hydroxyl groups distant from the carboxylic acid result in a low yield.',\n            'high_patterns': [[hydroxyl_adjacent_carboxy]],\n            'low_patterns': [[hydroxyl_distant_carboxy]],\n            'prediction_high': 1,\n            'prediction_low': -1\n        },\n        {\n            'number': 6,\n            'description': 'Modifiers with aliphatic carboxylic acids having amino groups within three carbons of the carboxylic acid result in a high yield; those with amino groups more distant result in a low yield.',\n            'high_patterns': [[amino_within_three_carbons]],\n            'low_patterns': [[amino_distant]],\n            'prediction_high': 1,\n            'prediction_low': -1\n        },\n        {\n            'number': 7,\n            'description': 'Modifiers that are simple aliphatic carboxylic acids without additional functional groups result in a high yield due to minimal steric hindrance and effective coordination.',\n            'high_patterns': [[carboxylic_acid]],\n            'exclude_patterns': [\n                [alpha_amino_acid], [nitrogen_heterocycle], [aliphatic_thiol_adjacent_carboxy], [hydroxyl_adjacent_carboxy], [amino_within_three_carbons], [ether_linkage], [fluorinated_chain], [reactive_carbonyl_adjacent_carboxy], [acylated_amino], [aromatic_amino]\n            ],\n            'prediction_high': 1\n        },\n        {\n            'number': 8,\n            'description': 'Modifiers with flexible ether linkages within their backbone result in a low yield due to decreased coordination efficiency from increased conformational freedom.',\n            'low_patterns': [[ether_linkage], [carboxylic_acid]],\n            'prediction_low': -1\n        },\n        {\n            'number': 9,\n            'description': 'Modifiers with highly fluorinated aliphatic chains result in a low yield due to decreased electron density on coordinating atoms and increased hydrophobicity.',\n            'low_patterns': [[fluorinated_chain], [carboxylic_acid]],\n            'prediction_low': -1\n        },\n        {\n            'number': 10,\n            'description': 'Modifiers containing reactive carbonyl groups (aldehydes or ketones) adjacent to the carboxylic acid result in a low yield due to potential side reactions and reduced coordination ability.',\n            'low_patterns': [[reactive_carbonyl_adjacent_carboxy]],\n            'prediction_low': -1\n        },\n        {\n            'number': 11,\n            'description': 'Modifiers with acylated amino groups result in a low yield due to blocking of potential coordination sites necessary for effective metal binding.',\n            'low_patterns': [[acylated_amino], [carboxylic_acid]],\n            'prediction_low': -1\n        },\n        {\n            'number': 12,\n            'description': 'Modifiers with aromatic carboxylic acids possessing amino groups result in a high yield due to additional coordination via the amino group.',\n            'high_patterns': [[aromatic_amino], [carboxylic_acid]],\n            'prediction_high': 1\n        },\n        {\n            'number': 13,\n            'description': 'Modifiers with aromatic rings directly attached to additional aromatic rings (biaryl structures) result in a low yield due to steric hindrance and decreased coordination efficiency.',\n            'low_patterns': [[biaryl]],\n            'prediction_low': -1\n        },\n        {\n            'number': 14,\n            'description': 'Modifiers with fused aromatic rings containing additional oxygen functionalities adjacent to carboxylic acids result in a high yield due to enhanced coordination through multiple oxygen atoms.',\n            'high_patterns': [[fused_aromatic_oxygen]],\n            'prediction_high': 1\n        },\n        {\n            'number': 15,\n            'description': 'Modifiers with \u03b2-phenylpropanoic acid structures result in a low yield due to steric hindrance affecting coordination with the catalyst.',\n            'low_patterns': [[beta_phenylpropanoic_acid]],\n            'prediction_low': -1\n        }\n    ]\n    \n    # Compile SMARTS patterns\n    for rule in rules:\n        # Compile high yield patterns\n        compiled_high_patterns = []\n        for group in rule.get('high_patterns', []):\n            compiled_group = [Chem.MolFromSmarts(p) for p in group]\n            compiled_high_patterns.append(compiled_group)\n        rule['compiled_high_patterns'] = compiled_high_patterns\n        # Compile low yield patterns\n        compiled_low_patterns = []\n        for group in rule.get('low_patterns', []):\n            compiled_group = [Chem.MolFromSmarts(p) for p in group]\n            compiled_low_patterns.append(compiled_group)\n        rule['compiled_low_patterns'] = compiled_low_patterns\n        # Compile exclude patterns if any\n        if 'exclude_patterns' in rule:\n            compiled_excludes = []\n            for group in rule['exclude_patterns']:\n                compiled_group = [Chem.MolFromSmarts(p) for p in group]\n                compiled_excludes.append(compiled_group)\n            rule['compiled_exclude_patterns'] = compiled_excludes\n    \n    # Initialize results list\n    results = []\n    \n    # Process each SMILES string\n    for smi in smiles_list:\n        mol = Chem.MolFromSmiles(smi)\n        if mol is None:\n            # If the molecule cannot be parsed, append a row of zeros\n            results.append([0]*len(rules))\n            continue\n        row = []\n        for rule in rules:\n            try:\n                match = False\n                # Check exclude patterns if any\n                if 'exclude_patterns' in rule:\n                    for group in rule['compiled_exclude_patterns']:\n                        for pat in group:\n                            if mol.HasSubstructMatch(pat):\n                                match = False\n                                break\n                        if match == False:\n                            break\n                    else:\n                        match = True\n                else:\n                    match = True\n                if match:\n                    # Check high yield patterns\n                    high_match = True\n                    for compiled_group in rule['compiled_high_patterns']:\n                        group_match = False\n                        for pat in compiled_group:\n                            if mol.HasSubstructMatch(pat):\n                                group_match = True\n                                break\n                        if not group_match:\n                            high_match = False\n                            break\n                    # Check low yield patterns\n                    low_match = True\n                    for compiled_group in rule['compiled_low_patterns']:\n                        group_match = False\n                        for pat in compiled_group:\n                            if mol.HasSubstructMatch(pat):\n                                group_match = True\n                                break\n                        if not group_match:\n                            low_match = False\n                            break\n                    if high_match and 'prediction_high' in rule:\n                        row.append(rule['prediction_high'])\n                    elif low_match and 'prediction_low' in rule:\n                        row.append(rule['prediction_low'])\n                    else:\n                        row.append(0)\n                else:\n                    row.append(0)\n            except Exception as e:\n                # In case of any error, append 0\n                row.append(0)\n        results.append(row)\n    # Create DataFrame with results\n    df = pd.DataFrame(results, columns=[f'Rule {rule['number']}' for rule in rules])\n    return df"
}